## Description.yml
Builtin:
## State for Builtins
  - ID: kvx__cs
    declaration: |
      typedef struct {
        unsigned ic: 1;
        unsigned io: 1;
        unsigned dz: 1;
        unsigned ov: 1;
        unsigned un: 1;
        unsigned in: 1;
        unsigned u1: 2;
        unsigned rm: 2;
        unsigned fs: 1;
        unsigned ne: 4;
        unsigned wu: 1;
        unsigned cc: 16;
      } __builtin_kvx_cs_t;
      extern __builtin_kvx_cs_t *__builtin_kvx__cs;
    definition: |
      __builtin_kvx_cs_t *__builtin_kvx__cs = 0;
## ALU Builtins
  - ID: kvx_insf
    prototype: >
      uint64_t __builtin_kvx_insf(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:INSF
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4, stopbit = operand3, bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t operand1 = ((operand2 << startbit) & mask) | (operand1 & ~mask);
      return operand1;
  - ID: kvx_extfz
    prototype: >
      uint64_t __builtin_kvx_extfz(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:EXTFZ
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4, stopbit = operand3, bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t masked = operand2 & mask;
      uint64_t operand1 = masked >> startbit;
      return operand1;
  - ID: kvx_extfs
    prototype: >
      int64_t __builtin_kvx_extfs(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:EXTFS
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4 & 0x1F;
      unsigned stopbit = operand3 & 0x1F;
      unsigned bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t masked1 = operand2 & mask;
      uint64_t masked2 = operand2 | ~mask;
      uint64_t condition = (mask & ~(mask>>1)) & operand2;
      uint64_t masked = (condition == 0)? masked1: masked2;
      int64_t operand1 = masked >> startbit;
      return operand1;
Convention:
  - ID: regular
    argument: [ R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11 ]
    callee: [ R14, R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31 ]
    caller: [ R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R15, R16, R17, R32, R33, R34, R35, R36, R37, R38, R39, R40, R41, R42, R43, R44, R45, R46, R47, R48, R49, R50, R51, R52, R53, R54, R55, R56, R57, R58, R59, R60, R61, R62, R63 ]
    handler: [ ]
    veneer: [ R16, R17 ]
    frame: [ R14 ]
    global: [ ]
    local: [ R13 ]
    reserved: [ R12, R13 ]
    result: [ R0, R1, R2, R3 ]
    program: [ PC ]
    return: [ RA ]
    stack: [ R12 ]
    static: [ ]
    struct: [ R15 ]
Macro:
  - ID: BCV
    execution: &executionBCV |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBCV |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA2
    execution: &executionBIA2 |
      stage RR:
      new mask = 1;
      new buffer = @2 << 1;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA2 |
      (SEQ
        (WRITE.mask (CONST.1))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.1)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA4
    execution: &executionBIA4 |
      stage RR:
      new mask = 3;
      new buffer = @2 << 2;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA4 |
      (SEQ
        (WRITE.mask (CONST.3))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.2)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA8
    execution: &executionBIA8 |
      stage RR:
      new mask = 7;
      new buffer = @2 << 3;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA8 |
      (SEQ
        (WRITE.mask (CONST.7))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.3)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA16
    execution: &executionBIA16 |
      stage RR:
      new mask = 15;
      new buffer = @2 << 4;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA16 |
      (SEQ
        (WRITE.mask (CONST.15))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.4)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA32
    execution: &executionBIA32 |
      stage RR:
      new mask = 31;
      new buffer = @2 << 5;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA32 |
      (SEQ
        (WRITE.mask (CONST.31))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.5)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA64
    execution: &executionBIA64 |
      stage RR:
      new mask = 63;
      new buffer = @2;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA64 |
      (SEQ
        (WRITE.mask (CONST.63))
        (WRITE.buffer (METHOD.%2))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: RVV
    execution: &executionRVV |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorRVV |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: SET
    execution: &executionSET |
      stage ID:
      new argument2 = %2;
      @Instruction
    behavior: &behaviorSET |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (MACRO.Instruction))
  - ID: GET
    execution: &executionGET |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorGET |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: RSWAP
    execution: &executionRSWAP |
      stage RR:
      new argument2 = %2;
      new argument1 = %1;
      @Instruction
      stage E1:
      %1 = result1;
      %2 = result2;
    behavior: &behaviorRSWAP |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (MACRO.Instruction))
  - ID: DWI
    execution: &executionDWI |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWI |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWR
    execution: &executionDWR |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWR |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWRR
    execution: &executionDWRR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWRR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWRRM
    execution: &executionDWRRM |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DW2RR
    execution: &executionDW2RR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRM
    execution: &executionDW2RRM |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRR1
    execution: &executionDW2RRR1 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRR1 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRR1M
    execution: &executionDW2RRR1M |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRR1M |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: CWRR
    execution: &executionCWRR |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorCWRR |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: CWRRM
    execution: &executionCWRRM |
      stage ID:
      new splat32 = %5;
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorCWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: CMWRR
    execution: &executionCMWRR |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
    behavior: &behaviorCMWRR |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction))
  - ID: CMWRRM
    execution: &executionCMWRRM |
      stage ID:
      new splat32 = %5;
      new argument4 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
    behavior: &behaviorCMWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction))
  - ID: XWI
    execution: &executionXWI |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      %1 = result1;
    behavior: &behaviorXWI |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: WZWR
    execution: &executionWZWR |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZWR |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1
          (ZX.32 (READ.result1))))
  - ID: WZWRR
    execution: &executionWZWRR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZWRR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1
          (ZX.32 (READ.result1))))
  - ID: WZW2RR
    execution: &executionWZW2RR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZW2RR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1
          (ZX.32 (READ.result1))))
  - ID: WZW2RRR1
    execution: &executionWZW2RRR1 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZW2RRR1 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1
          (ZX.32 (READ.result1))))
  - ID: WRSRD
    execution: &executionWRSRD |
      stage ID:
      new silent = %3;
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
      }
      %1 = result1;
    behavior: &behaviorWRSRD |
      (SEQ
        (WRITE.silent (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: WRSF
    execution: &executionWRSF |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage SF:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorWRSF |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.SF.%1
          (READ.result1)))
  - ID: WRE1
    execution: &executionWRE1 |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorWRE1 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: MOVETD
    execution: &executionMOVETD |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
      CS.XMF = 1;
    behavior: &behaviorMOVETD |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: MOVETQ
    execution: &executionMOVETQ |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
      CS.XMF = 1;
    behavior: &behaviorMOVETQ |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: FDDE4
    execution: &executionFDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      new argument3 = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
      }
      %1 = result1;
    behavior: &behaviorFDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                (READ.CS_io)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDDDDE4
    execution: &executionFDDDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDDDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDDDE4
    execution: &executionFDDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FSSS
    execution: &executionFSSS |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFSSS |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FQQDD
    execution: &executionFQQDD |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFQQDD |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FMA
    execution: &executionFMA |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFMA |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FMULC
    execution: &executionFMULC |
      stage ID:
      new silent = %6;
      new rounding = %5;
      new conjugate = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFMULC |
      (SEQ
        (WRITE.silent (ACCESS.ID.%6))
        (WRITE.rounding (ACCESS.ID.%5))
        (WRITE.conjugate (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDMA
    execution: &executionFDMA |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDMA |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FFMAC
    execution: &executionFFMAC |
      stage ID:
      new silent = %6;
      new rounding = %5;
      new conjugate = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFFMAC |
      (SEQ
        (WRITE.silent (ACCESS.ID.%6))
        (WRITE.rounding (ACCESS.ID.%5))
        (WRITE.conjugate (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDMDA
    execution: &executionFDMDA |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDMDA |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: LSBO
    execution: &executionLSBO |
      stage ID:
      new variant = %4;
      new offset = %2;
      stage RR:
      new base = %3;
      new address = base + offset;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLSBO |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: LQBO
    execution: &executionLQBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %4;
      new offset = %2;
      stage RR:
      new base = %3;
      new address = base + offset;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLQBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: FXBO
    execution: &executionFXBO |
      stage ID:
      new offset = %2;
      stage RR:
      new base = %1;
      new address = base + offset;
    behavior: &behaviorFXBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.base (ACCESS.RR.%1))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset))))
  - ID: LVBO
    execution: &executionLVBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %4;
      new offset = %2;
      new dri = @1;
      stage RR:
      new base = %3;
      new address = base + offset;
      stage E1:
      CS.XMF = 1;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLVBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: LVPBO
    execution: &executionLVPBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %5;
      new hindex = %4;
      new offset = %2;
      new dri = @1 << 1;
      stage RR:
      new base = %3;
      new address = base + offset;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      CS.XMF = 1;
      @Instruction
      new result1_0 = result1.64[0];
      new result1_1 = result1.64[1];
      new result1_2 = result1.64[2] << 64;
      new result1_3 = result1.64[3] << 64;
      %1:0 = insert_128(argument1_0, result1_0 | result1_2, hindex);
      %1:1 = insert_128(argument1_1, result1_1 | result1_3, hindex);
    behavior: &behaviorLVPBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.hindex (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.dri (SHL (METHOD.%1) (CONST.1)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (READ.64[0].result1))
        (WRITE.result1_1 (READ.64[1].result1))
        (WRITE.result1_2 (SHL (READ.64[2].result1) (CONST.64)))
        (WRITE.result1_3 (SHL (READ.64[3].result1) (CONST.64)))
        (COMMIT.E3.%1:0 (APPLY.insert_128 (READ.argument1_0) (IOR (READ.result1_0) (READ.result1_2)) (READ.hindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_128 (READ.argument1_1) (IOR (READ.result1_1) (READ.result1_3)) (READ.hindex))))
  - ID: LVQBO
    execution: &executionLVQBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %5;
      new qindex = %4;
      new offset = %2;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new address = base + offset;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      new argument1_2 = %1:2;
      new argument1_3 = %1:3;
      CS.XMF = 1;
      @Instruction
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      stage E3:
      %1:0 = insert_64(argument1_0, result1_0, qindex);
      %1:1 = insert_64(argument1_1, result1_1, qindex);
      %1:2 = insert_64(argument1_2, result1_2, qindex);
      %1:3 = insert_64(argument1_3, result1_3, qindex);
    behavior: &behaviorLVQBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.qindex (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_2 (ACCESS.E1.%1:2))
        (WRITE.argument1_3 (ACCESS.E1.%1:3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.E3.%1:0 (APPLY.insert_64 (READ.argument1_0) (READ.result1_0) (READ.qindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_64 (READ.argument1_1) (READ.result1_1) (READ.qindex)))
        (COMMIT.E3.%1:2 (APPLY.insert_64 (READ.argument1_2) (READ.result1_2) (READ.qindex)))
        (COMMIT.E3.%1:3 (APPLY.insert_64 (READ.argument1_3) (READ.result1_3) (READ.qindex))))
  - ID: SBO
    execution: &executionSBO |
      stage ID:
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: SQBO
    execution: &executionSQBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSQBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: SVBO
    properties: &propertiesSVBO { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    execution: &executionSVBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new offset = %1;
      new dri = @3;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.dri (METHOD.%3))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVPBO
    properties: &propertiesSVPBO { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    execution: &executionSVPBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new hindex = %4;
      new offset = %1;
      new dri = @3 << 1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3 = 0;
      if (hindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_0_1, argument3_1_1);
      if (hindex == 1)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_0_3, argument3_1_3);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVPBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.hindex (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.dri (SHL (METHOD.%3) (CONST.1)))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_0_1) (READ.argument3_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_0_3) (READ.argument3_1_3)))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVQBO
    execution: &executionSVQBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new qindex = %4;
      new offset = %1;
      new dri = @3 << 2;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3_2 = %3:2;
      new argument3_2_0 = argument3_2.64[0];
      new argument3_2_1 = argument3_2.64[1];
      new argument3_2_2 = argument3_2.64[2];
      new argument3_2_3 = argument3_2.64[3];
      new argument3_3 = %3:3;
      new argument3_3_0 = argument3_3.64[0];
      new argument3_3_1 = argument3_3.64[1];
      new argument3_3_2 = argument3_3.64[2];
      new argument3_3_3 = argument3_3.64[3];
      new argument3 = 0;
      if (qindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_2_0, argument3_3_0);
      if (qindex == 1)
        argument3 = join_64_x4(argument3_0_1, argument3_1_1, argument3_2_1, argument3_3_1);
      if (qindex == 2)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_2_2, argument3_3_2);
      if (qindex == 3)
        argument3 = join_64_x4(argument3_0_3, argument3_1_3, argument3_2_3, argument3_3_3);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVQBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.qindex (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.dri (SHL (METHOD.%3) (CONST.2)))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3_2 (ACCESS.E1.%3:2))
        (WRITE.argument3_2_0 (READ.64[0].argument3_2))
        (WRITE.argument3_2_1 (READ.64[1].argument3_2))
        (WRITE.argument3_2_2 (READ.64[2].argument3_2))
        (WRITE.argument3_2_3 (READ.64[3].argument3_2))
        (WRITE.argument3_3 (ACCESS.E1.%3:3))
        (WRITE.argument3_3_0 (READ.64[0].argument3_3))
        (WRITE.argument3_3_1 (READ.64[1].argument3_3))
        (WRITE.argument3_3_2 (READ.64[2].argument3_3))
        (WRITE.argument3_3_3 (READ.64[3].argument3_3))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_2_0) (READ.argument3_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_1) (READ.argument3_1_1) (READ.argument3_2_1) (READ.argument3_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_2_2) (READ.argument3_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_3) (READ.argument3_1_3) (READ.argument3_2_3) (READ.argument3_3_3)))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: LSPB
    execution: &executionLSPB |
      stage ID:
      new variant = %5;
      new argument4 = %4;
      stage RR:
      new argument2 = %2;
      new address = %3;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLSPB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address (ACCESS.RR.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LSPBO
    execution: &executionLSPBO |
      stage ID:
      new offset = %6;
      new variant = %5;
      new argument4 = %4;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLSPBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LQPB
    execution: &executionLQPB |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %5;
      new argument4 = %4;
      stage RR:
      new address = %3;
      new argument2 = %2;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLQPB |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LQPBO
    execution: &executionLQPBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new offset = %6;
      new variant = %5;
      new argument4 = %4;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLQPBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LQMB
    execution: &executionLQMB |
      stage ID:
      new variant = %5;
      new lsumask = %4;
      stage RR:
      new address = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      @Instruction
      stage CR:
      %1 = (result1 & passbytes) | (argument1 & clearbytes);
    behavior: &behaviorLQMB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (MACRO.Instruction)
        (COMMIT.CR.%1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes)))))
  - ID: LQMBO
    execution: &executionLQMBO |
      stage ID:
      new offset = %6;
      new variant = %5;
      new lsumask = %4;
      stage RR:
      new base = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      new address = base + offset;
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      @Instruction
      stage CR:
      %1 = (result1 & passbytes) | (argument1 & clearbytes);
    behavior: &behaviorLQMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (MACRO.Instruction)
        (COMMIT.CR.%1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes)))))
  - ID: LVMB
    execution: &executionLVMB |
      stage ID:
      new variant = %5;
      new lsumask = %4;
      new dri = @1;
      stage RR:
      new address = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      stage CR:
      %1 = (result1 & passbytes) | (argument1 & clearbytes);
    behavior: &behaviorLVMB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.CR.%1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes)))))
  - ID: LVMBO
    execution: &executionLVMBO |
      stage ID:
      new offset = %6;
      new variant = %5;
      new lsumask = %4;
      new dri = @1;
      stage RR:
      new base = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      new address = base + offset;
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      stage CR:
      %1 = (result1 & passbytes) | (argument1 & clearbytes);
    behavior: &behaviorLVMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.CR.%1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes)))))
  - ID: LVPMB
    execution: &executionLVPMB |
      stage ID:
      new variant = %6;
      new lsumask = %5;
      new hindex = %4;
      new dri = @1 << 1;
      stage RR:
      new address = %3;
      new argument2 = %2;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_0_0 = argument1_0.64[0];
      new argument1_0_1 = argument1_0.64[1];
      new argument1_0_2 = argument1_0.64[2];
      new argument1_0_3 = argument1_0.64[3];
      new argument1_1 = %1:1;
      new argument1_1_0 = argument1_1.64[0];
      new argument1_1_1 = argument1_1.64[1];
      new argument1_1_2 = argument1_1.64[2];
      new argument1_1_3 = argument1_1.64[3];
      new argument1 = 0;
      if (hindex == 0)
        argument1 = join_64_x4(argument1_0_0, argument1_1_0, argument1_0_1, argument1_1_1);
      if (hindex == 1)
        argument1 = join_64_x4(argument1_0_2, argument1_1_2, argument1_0_3, argument1_1_3);
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      result1 = (result1 & passbytes) | (argument1 & clearbytes);
      new result1_0 = result1.64[0];
      new result1_1 = result1.64[1];
      new result1_2 = result1.64[2] << 64;
      new result1_3 = result1.64[3] << 64;
      %1:0 = insert_128(argument1_0, result1_0 |result1_2, hindex);
      %1:1 = insert_128(argument1_1, result1_1 |result1_3, hindex);
    behavior: &behaviorLVPMB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.lsumask (ACCESS.ID.%5))
        (WRITE.hindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.1)))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_0_0 (READ.64[0].argument1_0))
        (WRITE.argument1_0_1 (READ.64[1].argument1_0))
        (WRITE.argument1_0_2 (READ.64[2].argument1_0))
        (WRITE.argument1_0_3 (READ.64[3].argument1_0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_1_0 (READ.64[0].argument1_1))
        (WRITE.argument1_1_1 (READ.64[1].argument1_1))
        (WRITE.argument1_1_2 (READ.64[2].argument1_1))
        (WRITE.argument1_1_3 (READ.64[3].argument1_1))
        (WRITE.argument1 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_0) (READ.argument1_1_0) (READ.argument1_0_1) (READ.argument1_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_2) (READ.argument1_1_2) (READ.argument1_0_3) (READ.argument1_1_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes))))
        (WRITE.result1_0 (READ.64[0].result1))
        (WRITE.result1_1 (READ.64[1].result1))
        (WRITE.result1_2 (SHL (READ.64[2].result1) (CONST.64)))
        (WRITE.result1_3 (SHL (READ.64[3].result1) (CONST.64)))
        (COMMIT.E3.%1:0 (APPLY.insert_128 (READ.argument1_0) (IOR (READ.result1_0) (READ.result1_2)) (READ.hindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_128 (READ.argument1_1) (IOR (READ.result1_1) (READ.result1_3)) (READ.hindex))))
  - ID: LVPMBO
    execution: &executionLVPMBO |
      stage ID:
      new offset = %7;
      new variant = %6;
      new lsumask = %5;
      new hindex = %4;
      new dri = @1 << 1;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_0_0 = argument1_0.64[0];
      new argument1_0_1 = argument1_0.64[1];
      new argument1_0_2 = argument1_0.64[2];
      new argument1_0_3 = argument1_0.64[3];
      new argument1_1 = %1:1;
      new argument1_1_0 = argument1_1.64[0];
      new argument1_1_1 = argument1_1.64[1];
      new argument1_1_2 = argument1_1.64[2];
      new argument1_1_3 = argument1_1.64[3];
      new argument1 = 0;
      if (hindex == 0)
        argument1 = join_64_x4(argument1_0_0, argument1_1_0, argument1_0_1, argument1_1_1);
      if (hindex == 1)
        argument1 = join_64_x4(argument1_0_2, argument1_1_2, argument1_0_3, argument1_1_3);
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      result1 = (result1 & passbytes) | (argument1 & clearbytes);
      new result1_0 = result1.64[0];
      new result1_1 = result1.64[1];
      new result1_2 = result1.64[2] << 64;
      new result1_3 = result1.64[3] << 64;
      %1:0 = insert_128(argument1_0, result1_0 |result1_2, hindex);
      %1:1 = insert_128(argument1_1, result1_1 |result1_3, hindex);
    behavior: &behaviorLVPMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%7))
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.lsumask (ACCESS.ID.%5))
        (WRITE.hindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.1)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_0_0 (READ.64[0].argument1_0))
        (WRITE.argument1_0_1 (READ.64[1].argument1_0))
        (WRITE.argument1_0_2 (READ.64[2].argument1_0))
        (WRITE.argument1_0_3 (READ.64[3].argument1_0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_1_0 (READ.64[0].argument1_1))
        (WRITE.argument1_1_1 (READ.64[1].argument1_1))
        (WRITE.argument1_1_2 (READ.64[2].argument1_1))
        (WRITE.argument1_1_3 (READ.64[3].argument1_1))
        (WRITE.argument1 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_0) (READ.argument1_1_0) (READ.argument1_0_1) (READ.argument1_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_2) (READ.argument1_1_2) (READ.argument1_0_3) (READ.argument1_1_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes))))
        (WRITE.result1_0 (READ.64[0].result1))
        (WRITE.result1_1 (READ.64[1].result1))
        (WRITE.result1_2 (SHL (READ.64[2].result1) (CONST.64)))
        (WRITE.result1_3 (SHL (READ.64[3].result1) (CONST.64)))
        (COMMIT.E3.%1:0 (APPLY.insert_128 (READ.argument1_0) (IOR (READ.result1_0) (READ.result1_2)) (READ.hindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_128 (READ.argument1_1) (IOR (READ.result1_1) (READ.result1_3)) (READ.hindex))))
  - ID: LVQMB
    execution: &executionLVQMB |
      stage ID:
      new variant = %6;
      new lsumask = %5;
      new qindex = %4;
      new dri = @1 << 2;
      stage RR:
      new address = %3;
      new argument2 = %2;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_0_0 = argument1_0.64[0];
      new argument1_0_1 = argument1_0.64[1];
      new argument1_0_2 = argument1_0.64[2];
      new argument1_0_3 = argument1_0.64[3];
      new argument1_1 = %1:1;
      new argument1_1_0 = argument1_1.64[0];
      new argument1_1_1 = argument1_1.64[1];
      new argument1_1_2 = argument1_1.64[2];
      new argument1_1_3 = argument1_1.64[3];
      new argument1_2 = %1:2;
      new argument1_2_0 = argument1_2.64[0];
      new argument1_2_1 = argument1_2.64[1];
      new argument1_2_2 = argument1_2.64[2];
      new argument1_2_3 = argument1_2.64[3];
      new argument1_3 = %1:3;
      new argument1_3_0 = argument1_3.64[0];
      new argument1_3_1 = argument1_3.64[1];
      new argument1_3_2 = argument1_3.64[2];
      new argument1_3_3 = argument1_3.64[3];
      new argument1 = 0;
      if (qindex == 0)
        argument1 = join_64_x4(argument1_0_0, argument1_1_0, argument1_2_0, argument1_3_0);
      if (qindex == 1)
        argument1 = join_64_x4(argument1_0_1, argument1_1_1, argument1_2_1, argument1_3_1);
      if (qindex == 2)
        argument1 = join_64_x4(argument1_0_2, argument1_1_2, argument1_2_2, argument1_3_2);
      if (qindex == 3)
        argument1 = join_64_x4(argument1_0_3, argument1_1_3, argument1_2_3, argument1_3_3);
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      result1 = (result1 & passbytes) | (argument1 & clearbytes);
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      %1:0 = insert_64(argument1_0, result1_0, qindex);
      %1:1 = insert_64(argument1_1, result1_1, qindex);
      %1:2 = insert_64(argument1_2, result1_2, qindex);
      %1:3 = insert_64(argument1_3, result1_3, qindex);
    behavior: &behaviorLVQMB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.lsumask (ACCESS.ID.%5))
        (WRITE.qindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_0_0 (READ.64[0].argument1_0))
        (WRITE.argument1_0_1 (READ.64[1].argument1_0))
        (WRITE.argument1_0_2 (READ.64[2].argument1_0))
        (WRITE.argument1_0_3 (READ.64[3].argument1_0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_1_0 (READ.64[0].argument1_1))
        (WRITE.argument1_1_1 (READ.64[1].argument1_1))
        (WRITE.argument1_1_2 (READ.64[2].argument1_1))
        (WRITE.argument1_1_3 (READ.64[3].argument1_1))
        (WRITE.argument1_2 (ACCESS.E1.%1:2))
        (WRITE.argument1_2_0 (READ.64[0].argument1_2))
        (WRITE.argument1_2_1 (READ.64[1].argument1_2))
        (WRITE.argument1_2_2 (READ.64[2].argument1_2))
        (WRITE.argument1_2_3 (READ.64[3].argument1_2))
        (WRITE.argument1_3 (ACCESS.E1.%1:3))
        (WRITE.argument1_3_0 (READ.64[0].argument1_3))
        (WRITE.argument1_3_1 (READ.64[1].argument1_3))
        (WRITE.argument1_3_2 (READ.64[2].argument1_3))
        (WRITE.argument1_3_3 (READ.64[3].argument1_3))
        (WRITE.argument1 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_0) (READ.argument1_1_0) (READ.argument1_2_0) (READ.argument1_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_1) (READ.argument1_1_1) (READ.argument1_2_1) (READ.argument1_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_2) (READ.argument1_1_2) (READ.argument1_2_2) (READ.argument1_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_3) (READ.argument1_1_3) (READ.argument1_2_3) (READ.argument1_3_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes))))
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.E3.%1:0 (APPLY.insert_64 (READ.argument1_0) (READ.result1_0) (READ.qindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_64 (READ.argument1_1) (READ.result1_1) (READ.qindex)))
        (COMMIT.E3.%1:2 (APPLY.insert_64 (READ.argument1_2) (READ.result1_2) (READ.qindex)))
        (COMMIT.E3.%1:3 (APPLY.insert_64 (READ.argument1_3) (READ.result1_3) (READ.qindex))))
  - ID: LVQMBO
    execution: &executionLVQMBO |
      stage ID:
      new offset = %7;
      new variant = %6;
      new lsumask = %5;
      new qindex = %4;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      stage E1:
      new argument1_0 = %1:0;
      new argument1_0_0 = argument1_0.64[0];
      new argument1_0_1 = argument1_0.64[1];
      new argument1_0_2 = argument1_0.64[2];
      new argument1_0_3 = argument1_0.64[3];
      new argument1_1 = %1:1;
      new argument1_1_0 = argument1_1.64[0];
      new argument1_1_1 = argument1_1.64[1];
      new argument1_1_2 = argument1_1.64[2];
      new argument1_1_3 = argument1_1.64[3];
      new argument1_2 = %1:2;
      new argument1_2_0 = argument1_2.64[0];
      new argument1_2_1 = argument1_2.64[1];
      new argument1_2_2 = argument1_2.64[2];
      new argument1_2_3 = argument1_2.64[3];
      new argument1_3 = %1:3;
      new argument1_3_0 = argument1_3.64[0];
      new argument1_3_1 = argument1_3.64[1];
      new argument1_3_2 = argument1_3.64[2];
      new argument1_3_3 = argument1_3.64[3];
      new argument1 = 0;
      if (qindex == 0)
        argument1 = join_64_x4(argument1_0_0, argument1_1_0, argument1_2_0, argument1_3_0);
      if (qindex == 1)
        argument1 = join_64_x4(argument1_0_1, argument1_1_1, argument1_2_1, argument1_3_1);
      if (qindex == 2)
        argument1 = join_64_x4(argument1_0_2, argument1_1_2, argument1_2_2, argument1_3_2);
      if (qindex == 3)
        argument1 = join_64_x4(argument1_0_3, argument1_1_3, argument1_2_3, argument1_3_3);
      new bytemask = lsumask_bytemask(lsumask, argument2);
      new passbytes = lsumask_passbytes(lsumask, argument2);
      new clearbytes = lsumask_clearbytes(lsumask, argument2);
      CS.XMF = 1;
      @Instruction
      result1 = (result1 & passbytes) | (argument1 & clearbytes);
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      %1:0 = insert_64(argument1_0, result1_0, qindex);
      %1:1 = insert_64(argument1_1, result1_1, qindex);
      %1:2 = insert_64(argument1_2, result1_2, qindex);
      %1:3 = insert_64(argument1_3, result1_3, qindex);
    behavior: &behaviorLVQMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%7))
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.lsumask (ACCESS.ID.%5))
        (WRITE.qindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_0_0 (READ.64[0].argument1_0))
        (WRITE.argument1_0_1 (READ.64[1].argument1_0))
        (WRITE.argument1_0_2 (READ.64[2].argument1_0))
        (WRITE.argument1_0_3 (READ.64[3].argument1_0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_1_0 (READ.64[0].argument1_1))
        (WRITE.argument1_1_1 (READ.64[1].argument1_1))
        (WRITE.argument1_1_2 (READ.64[2].argument1_1))
        (WRITE.argument1_1_3 (READ.64[3].argument1_1))
        (WRITE.argument1_2 (ACCESS.E1.%1:2))
        (WRITE.argument1_2_0 (READ.64[0].argument1_2))
        (WRITE.argument1_2_1 (READ.64[1].argument1_2))
        (WRITE.argument1_2_2 (READ.64[2].argument1_2))
        (WRITE.argument1_2_3 (READ.64[3].argument1_2))
        (WRITE.argument1_3 (ACCESS.E1.%1:3))
        (WRITE.argument1_3_0 (READ.64[0].argument1_3))
        (WRITE.argument1_3_1 (READ.64[1].argument1_3))
        (WRITE.argument1_3_2 (READ.64[2].argument1_3))
        (WRITE.argument1_3_3 (READ.64[3].argument1_3))
        (WRITE.argument1 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_0) (READ.argument1_1_0) (READ.argument1_2_0) (READ.argument1_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_1) (READ.argument1_1_1) (READ.argument1_2_1) (READ.argument1_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_2) (READ.argument1_1_2) (READ.argument1_2_2) (READ.argument1_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument1
            (APPLY.256.join_64_x4
              (READ.argument1_0_3) (READ.argument1_1_3) (READ.argument1_2_3) (READ.argument1_3_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument2)))
        (WRITE.passbytes
          (APPLY.256.lsumask_passbytes (READ.lsumask) (READ.argument2)))
        (WRITE.clearbytes
          (APPLY.256.lsumask_clearbytes (READ.lsumask) (READ.argument2)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (READ.result1) (READ.passbytes))
            (AND (READ.argument1) (READ.clearbytes))))
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.E3.%1:0 (APPLY.insert_64 (READ.argument1_0) (READ.result1_0) (READ.qindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_64 (READ.argument1_1) (READ.result1_1) (READ.qindex)))
        (COMMIT.E3.%1:2 (APPLY.insert_64 (READ.argument1_2) (READ.result1_2) (READ.qindex)))
        (COMMIT.E3.%1:3 (APPLY.insert_64 (READ.argument1_3) (READ.result1_3) (READ.qindex))))
  - ID: XP2RBB
    execution: &executionXP2RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 1;
      new where = (@1 << 1) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP2RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.1)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.1)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP2RBBO
    execution: &executionXP2RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 1;
      new where = (@1 << 1) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP2RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.1)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.1)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP4RBB
    execution: &executionXP4RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 3;
      new where = (@1 << 2) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      XVR[where] = result1;
      stage CR:
    behavior: &behaviorXP4RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.3)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.2)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP4RBBO
    execution: &executionXP4RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 3;
      new where = (@1 << 2) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP4RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.3)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.2)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP8RBB
    execution: &executionXP8RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 7;
      new where = (@1 << 3) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP8RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.7)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.3)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP8RBBO
    execution: &executionXP8RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 7;
      new where = (@1 << 3) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP8RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.7)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.3)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP16RBB
    execution: &executionXP16RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 15;
      new where = (@1 << 4) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP16RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.15)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.4)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP16RBBO
    execution: &executionXP16RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 15;
      new where = (@1 << 4) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP16RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.15)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.4)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP32RBB
    execution: &executionXP32RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 31;
      new where = (@1 << 5) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP32RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.31)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.5)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP32RBBO
    execution: &executionXP32RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 31;
      new where = (@1 << 5) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP32RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.31)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.5)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP64RBB
    execution: &executionXP64RBB |
      stage ID:
      new variant = %4;
      stage RR:
      new address = %3;
      new target = %2;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 63;
      new where = (@1 << 6) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP64RBB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.63)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.6)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: XP64RBBO
    execution: &executionXP64RBBO |
      stage ID:
      new offset = %5;
      new variant = %4;
      stage RR:
      new base = %3;
      new target = %2;
      new address = base + offset;
      new shift = (target & 31) * 8;
      new index = (target >> 5) & 63;
      new where = (@1 << 6) + index;
      new dri = where;
      stage E1:
      new argument1 = XVR[where];
      new bytemask = (1 << %0.MemorySize) - 1;
      new targetbytes = bits2bytes(bytemask) << shift;
      CS.XMF = 1;
      @Instruction
      result1 = ((result1 << shift) & targetbytes) | (argument1 & ~targetbytes);
      stage CR:
      XVR[where] = result1;
    behavior: &behaviorXP64RBBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.target (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.shift
          (MUL (AND (READ.target) (CONST.31)) (CONST.8)))
        (WRITE.index
          (AND (SHR (READ.target) (CONST.5)) (CONST.63)))
        (WRITE.where
          (ADD (SHL (METHOD.%1) (CONST.6)) (READ.index)))
        (WRITE.dri (READ.where))
        (WRITE.argument1
          (F2I.256 (LOAD.E1 (AGGL.XVR (READ.where) (CONST.1)))))
        (WRITE.bytemask
          (SUB (SHL (CONST.1) (PROPERTY.MemorySize.%0)) (CONST.1)))
        (WRITE.targetbytes
          (SHL (APPLY.256.bits2bytes (READ.bytemask)) (READ.shift)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1
          (IOR
            (AND (SHL (READ.result1) (READ.shift)) (READ.targetbytes))
            (AND (READ.argument1) (NOT (READ.targetbytes)))))
        (STORE.CR
          (AGGL.XVR (READ.where) (CONST.1)) (I2F.256 (READ.result1))))
  - ID: SSPB
    execution: &executionSSPB |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSSPB |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SSPBO
    execution: &executionSSPBO |
      stage ID:
      new argument4 = %4;
      new offset = %5;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSSPBO |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SQPB
    execution: &executionSQPB |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new argument4 = %4;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSQPB |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SQPBO
    execution: &executionSQPBO |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new argument4 = %4;
      new offset = %5;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSQPBO |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SQMB
    execution: &executionSQMB |
      stage ID:
      new lsumask = %4;
      stage RR:
      new address = %2;
      new argument1 = %1;
      stage E1:
      new argument3 = %3;
      new bytemask = lsumask_bytemask(lsumask, argument1);
      @Instruction
    behavior: &behaviorSQMB |
      (SEQ
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (MACRO.Instruction))
  - ID: SQMBO
    execution: &executionSQMBO |
      stage ID:
      new offset = %5;
      new lsumask = %4;
      stage RR:
      new base = %2;
      new argument1 = %1;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      new bytemask = lsumask_bytemask(lsumask, argument1);
      @Instruction
    behavior: &behaviorSQPMO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (MACRO.Instruction))
  - ID: SVMB
    execution: &executionSVMB |
      stage ID:
      new lsumask = %4;
      new dri = @3;
      stage RR:
      new address = %2;
      new argument1 = %1;
      stage E1:
      new argument3 = %3;
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVMB |
      (SEQ
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%3))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVMBO
    execution: &executionSVMBO |
      stage ID:
      new offset = %5;
      new lsumask = %4;
      new dri = @3;
      stage RR:
      new base = %2;
      new argument1 = %1;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVPMO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%3))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVPMB
    execution: &executionSVPMB |
      stage ID:
      new hindex = %5;
      new lsumask = %4;
      new dri = @3 << 1;
      stage RR:
      new address = %2;
      new argument1 = %1;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3 = 0;
      if (hindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_0_1, argument3_1_1);
      if (hindex == 1)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_0_3, argument3_1_3);
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVPMB |
      (SEQ
        (WRITE.hindex (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%3) (CONST.1)))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_0_1) (READ.argument3_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_0_3) (READ.argument3_1_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVPMBO
    execution: &executionSVPMBO |
      stage ID:
      new offset = %6;
      new hindex = %5;
      new lsumask = %4;
      new dri = @3 << 1;
      stage RR:
      new base = %2;
      new argument1 = %1;
      new address = base + offset;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3 = 0;
      if (hindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_0_1, argument3_1_1);
      if (hindex == 1)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_0_3, argument3_1_3);
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVPMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.hindex (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%3) (CONST.1)))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_0_1) (READ.argument3_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_0_3) (READ.argument3_1_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVQMB
    execution: &executionSVQMB |
      stage ID:
      new qindex = %5;
      new lsumask = %4;
      new dri = @3 << 2;
      stage RR:
      new address = %2;
      new argument1 = %1;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3_2 = %3:2;
      new argument3_2_0 = argument3_2.64[0];
      new argument3_2_1 = argument3_2.64[1];
      new argument3_2_2 = argument3_2.64[2];
      new argument3_2_3 = argument3_2.64[3];
      new argument3_3 = %3:3;
      new argument3_3_0 = argument3_3.64[0];
      new argument3_3_1 = argument3_3.64[1];
      new argument3_3_2 = argument3_3.64[2];
      new argument3_3_3 = argument3_3.64[3];
      new argument3 = 0;
      if (qindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_2_0, argument3_3_0);
      if (qindex == 1)
        argument3 = join_64_x4(argument3_0_1, argument3_1_1, argument3_2_1, argument3_3_1);
      if (qindex == 2)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_2_2, argument3_3_2);
      if (qindex == 3)
        argument3 = join_64_x4(argument3_0_3, argument3_1_3, argument3_2_3, argument3_3_3);
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVQMB |
      (SEQ
        (WRITE.qindex (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%3) (CONST.2)))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3_2 (ACCESS.E1.%3:2))
        (WRITE.argument3_2_0 (READ.64[0].argument3_2))
        (WRITE.argument3_2_1 (READ.64[1].argument3_2))
        (WRITE.argument3_2_2 (READ.64[2].argument3_2))
        (WRITE.argument3_2_3 (READ.64[3].argument3_2))
        (WRITE.argument3_3 (ACCESS.E1.%3:3))
        (WRITE.argument3_3_0 (READ.64[0].argument3_3))
        (WRITE.argument3_3_1 (READ.64[1].argument3_3))
        (WRITE.argument3_3_2 (READ.64[2].argument3_3))
        (WRITE.argument3_3_3 (READ.64[3].argument3_3))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_2_0) (READ.argument3_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_1) (READ.argument3_1_1) (READ.argument3_2_1) (READ.argument3_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_2_2) (READ.argument3_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_3) (READ.argument3_1_3) (READ.argument3_2_3) (READ.argument3_3_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVQMBO
    properties: &propertiesSVQMBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%6': Offset, '%CS': NoEffects }
    execution: &executionSVQMBO |
      stage ID:
      new offset = %6;
      new qindex = %5;
      new lsumask = %4;
      new dri = @3 << 2;
      stage RR:
      new base = %2;
      new argument1 = %1;
      new address = base + offset;
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3_2 = %3:2;
      new argument3_2_0 = argument3_2.64[0];
      new argument3_2_1 = argument3_2.64[1];
      new argument3_2_2 = argument3_2.64[2];
      new argument3_2_3 = argument3_2.64[3];
      new argument3_3 = %3:3;
      new argument3_3_0 = argument3_3.64[0];
      new argument3_3_1 = argument3_3.64[1];
      new argument3_3_2 = argument3_3.64[2];
      new argument3_3_3 = argument3_3.64[3];
      new argument3 = 0;
      if (qindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_2_0, argument3_3_0);
      if (qindex == 1)
        argument3 = join_64_x4(argument3_0_1, argument3_1_1, argument3_2_1, argument3_3_1);
      if (qindex == 2)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_2_2, argument3_3_2);
      if (qindex == 3)
        argument3 = join_64_x4(argument3_0_3, argument3_1_3, argument3_2_3, argument3_3_3);
      new bytemask = lsumask_bytemask(lsumask, argument1);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVQMBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.qindex (ACCESS.ID.%5))
        (WRITE.lsumask (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%3) (CONST.2)))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3_2 (ACCESS.E1.%3:2))
        (WRITE.argument3_2_0 (READ.64[0].argument3_2))
        (WRITE.argument3_2_1 (READ.64[1].argument3_2))
        (WRITE.argument3_2_2 (READ.64[2].argument3_2))
        (WRITE.argument3_2_3 (READ.64[3].argument3_2))
        (WRITE.argument3_3 (ACCESS.E1.%3:3))
        (WRITE.argument3_3_0 (READ.64[0].argument3_3))
        (WRITE.argument3_3_1 (READ.64[1].argument3_3))
        (WRITE.argument3_3_2 (READ.64[2].argument3_3))
        (WRITE.argument3_3_3 (READ.64[3].argument3_3))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_2_0) (READ.argument3_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_1) (READ.argument3_1_1) (READ.argument3_2_1) (READ.argument3_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_2_2) (READ.argument3_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_3) (READ.argument3_1_3) (READ.argument3_2_3) (READ.argument3_3_3)))
          (SKIP))
        (WRITE.bytemask
          (APPLY.32.lsumask_bytemask (READ.lsumask) (READ.argument1)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: LBOA
    execution: &executionLBOA |
      stage ID:
      new coherency = %3;
      stage RR:
      new address = %2;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLBOA |
      (SEQ
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.address (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: ASBO
    properties: &propertiesASBO { '%0': MemoryEffect, '%1': Loaded, '%2': Base, '%4': Offset }
    execution: &executionASBO |
      stage ID:
      new offset = %4;
      new coherency = %3;
      stage RR:
      new base = %2;
      new address = base + offset;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorASBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%4))
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: AWB
    execution: &executionAWB |
      stage ID:
      new coherency = %3;
      stage RR:
      new address = %1;
      stage E1:
      new argument2 = %2;
      @Instruction
    behavior: &behaviorAWB |
      (SEQ
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.address (ACCESS.RR.%1))
        (WRITE.argument2 (ACCESS.E1.%2))
        (MACRO.Instruction))
  - ID: AWBO
    properties: &propertiesAWBO { '%0': MemoryWrite, '%1': Base, '%4': Offset, '%2': Stored }
    execution: &executionAWBO |
      stage ID:
      new offset = %4;
      new coherency = %3;
      stage RR:
      new base = %1;
      new address = base + offset;
      stage E1:
      new argument2 = %2;
      @Instruction
    behavior: &behaviorAWBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%4))
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.base (ACCESS.RR.%1))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument2 (ACCESS.E1.%2))
        (MACRO.Instruction))
  - ID: AAB
    execution: &executionAAB |
      stage ID:
      new coherency = %3;
      stage RR:
      new address = %1;
      stage E1:
      new argument2 = %2;
      @Instruction
      stage SR:
      %2 = result2;
    behavior: &behaviorAAB |
      (SEQ
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.address (ACCESS.RR.%1))
        (WRITE.argument2 (ACCESS.E1.%2))
        (MACRO.Instruction)
        (COMMIT.SR.%2 (READ.result2)))
  - ID: AABO
    properties: &propertiesAABO { '%0': MemoryEffect, '%1': Base, '%2': Loaded, '%4': Offset }
    execution: &executionAABO |
      stage ID:
      new offset = %4;
      new coherency = %3;
      stage RR:
      new base = %1;
      new address = base + offset;
      stage E1:
      new argument2 = %2;
      @Instruction
      stage SR:
      %2 = result2;
    behavior: &behaviorAABO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%4))
        (WRITE.coherency (ACCESS.ID.%3))
        (WRITE.base (ACCESS.RR.%1))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument2 (ACCESS.E1.%2))
        (MACRO.Instruction)
        (COMMIT.SR.%2 (READ.result2)))
  - ID: ARPB
    execution: &executionARPB |
      stage ID:
      new boolcas = %5;
      new coherency = %4;
      stage RR:
      new address = %2;
      stage E1:
      new arguments = %3;
      @Instruction
      stage SR:
      %1 = result1;
    behavior: &behaviorARPB |
      (SEQ
        (WRITE.boolcas (ACCESS.ID.%5))
        (WRITE.coherency (ACCESS.ID.%4))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.arguments (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%1 (READ.result1)))
  - ID: ARPBO
    execution: &executionARPBO |
      stage ID:
      new offset = %6;
      new boolcas = %5;
      new coherency = %4;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new arguments = %3;
      @Instruction
      stage SR:
      %1 = result1;
    behavior: &behaviorARPBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%6))
        (WRITE.boolcas (ACCESS.ID.%5))
        (WRITE.coherency (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.arguments (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%1 (READ.result1)))
  - ID: LSBI
    execution: &executionLSBI |
      stage ID:
      new variant = %5;
      new doscale = %4;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLSBI |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: LQBI
    execution: &executionLQBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %5;
      new doscale = %4;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLQBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: FXBI
    execution: &executionFXBI |
      stage ID:
      new doscale = %3;
      stage RR:
      new base = %2;
      new index = %1;
      new scaling = doscale ? 64 : 1;
      new address = base + (index * scaling);
      @Instruction
    behavior: &behaviorFXBI |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%3))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (CONST.64)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (MACRO.Instruction))
  - ID: FXSW
    execution: &executionFXSW |
      stage ID:
      new cachelev = %3;
      stage RR:
      new way = %2;
      new set = %1;
      @Instruction
    behavior: &behaviorFXSW |
      (SEQ
        (WRITE.cachelev (ACCESS.ID.%3))
        (WRITE.way (ACCESS.RR.%2))
        (WRITE.set (ACCESS.RR.%1))
        (MACRO.Instruction))
  - ID: LVBI
    execution: &executionLVBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %5;
      new doscale = %4;
      new dri = @1;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      CS.XMF = 1;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLVBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: LVPBI
    execution: &executionLVPBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %6;
      new doscale = %5;
      new hindex = %4;
      new dri = @1 << 1;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      CS.XMF = 1;
      @Instruction
      new result1_0 = result1.64[0];
      new result1_1 = result1.64[1];
      new result1_2 = result1.64[2] << 64;
      new result1_3 = result1.64[3] << 64;
      %1:0 = insert_128(argument1_0, result1_0 |result1_2, hindex);
      %1:1 = insert_128(argument1_1, result1_1 |result1_3, hindex);
    behavior: &behaviorLVPBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.doscale (ACCESS.ID.%5))
        (WRITE.hindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.1)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (READ.64[0].result1))
        (WRITE.result1_1 (READ.64[1].result1))
        (WRITE.result1_2 (SHL (READ.64[2].result1) (CONST.64)))
        (WRITE.result1_3 (SHL (READ.64[3].result1) (CONST.64)))
        (COMMIT.E3.%1:0 (APPLY.insert_128 (READ.argument1_0) (IOR (READ.result1_0) (READ.result1_2)) (READ.hindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_128 (READ.argument1_1) (IOR (READ.result1_1) (READ.result1_3)) (READ.hindex))))
  - ID: LVQBI
    execution: &executionLVQBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new variant = %6;
      new doscale = %5;
      new qindex = %4;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      new argument1_2 = %1:2;
      new argument1_3 = %1:3;
      CS.XMF = 1;
      @Instruction
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      %1:0 = insert_64(argument1_0, result1_0, qindex);
      %1:1 = insert_64(argument1_1, result1_1, qindex);
      %1:2 = insert_64(argument1_2, result1_2, qindex);
      %1:3 = insert_64(argument1_3, result1_3, qindex);
    behavior: &behaviorLVQBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.doscale (ACCESS.ID.%5))
        (WRITE.qindex (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument1_0 (ACCESS.E1.%1:0))
        (WRITE.argument1_1 (ACCESS.E1.%1:1))
        (WRITE.argument1_2 (ACCESS.E1.%1:2))
        (WRITE.argument1_3 (ACCESS.E1.%1:3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.E3.%1:0 (APPLY.insert_64 (READ.argument1_0) (READ.result1_0) (READ.qindex)))
        (COMMIT.E3.%1:1 (APPLY.insert_64 (READ.argument1_1) (READ.result1_1) (READ.qindex)))
        (COMMIT.E3.%1:2 (APPLY.insert_64 (READ.argument1_2) (READ.result1_2) (READ.qindex)))
        (COMMIT.E3.%1:3 (APPLY.insert_64 (READ.argument1_3) (READ.result1_3) (READ.qindex))))
  - ID: SSBI
    execution: &executionSSBI |
      stage ID:
      new doscale = %4;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSSBI |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: SQBI
    execution: &executionSQBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new doscale = %4;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSQBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: SVBI
    execution: &executionSVBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new doscale = %4;
      new dri = @3;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%3))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVPBI
    execution: &executionSVPBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new hindex = %5;
      new doscale = %4;
      new dri = @3 << 1;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3 = 0;
      if (hindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_0_1, argument3_1_1);
      if (hindex == 1)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_0_3, argument3_1_3);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVPBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.hindex (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (SHR (METHOD.%3) (CONST.1)))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.hindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_0_1) (READ.argument3_1_1)))
          (SKIP))
        (IF
          (EQ (READ.hindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_0_3) (READ.argument3_1_3)))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: SVQBI
    execution: &executionSVQBI |
      stage ID:
      new bytemask = 0xFFFFFFFF;
      new qindex = %5;
      new doscale = %4;
      new dri = @3 << 2;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument3_2 = %3:2;
      new argument3_2_0 = argument3_2.64[0];
      new argument3_2_1 = argument3_2.64[1];
      new argument3_2_2 = argument3_2.64[2];
      new argument3_2_3 = argument3_2.64[3];
      new argument3_3 = %3:3;
      new argument3_3_0 = argument3_3.64[0];
      new argument3_3_1 = argument3_3.64[1];
      new argument3_3_2 = argument3_3.64[2];
      new argument3_3_3 = argument3_3.64[3];
      new argument3 = 0;
      if (qindex == 0)
        argument3 = join_64_x4(argument3_0_0, argument3_1_0, argument3_2_0, argument3_3_0);
      if (qindex == 1)
        argument3 = join_64_x4(argument3_0_1, argument3_1_1, argument3_2_1, argument3_3_1);
      if (qindex == 2)
        argument3 = join_64_x4(argument3_0_2, argument3_1_2, argument3_2_2, argument3_3_2);
      if (qindex == 3)
        argument3 = join_64_x4(argument3_0_3, argument3_1_3, argument3_2_3, argument3_3_3);
      CS.XMF = 1;
      @Instruction
    behavior: &behaviorSVQBI |
      (SEQ
        (WRITE.bytemask (CONST.0xFFFFFFFF))
        (WRITE.qindex (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (SHR (METHOD.%3) (CONST.2)))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3_0 (ACCESS.E1.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.E1.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument3_2 (ACCESS.E1.%3:2))
        (WRITE.argument3_2_0 (READ.64[0].argument3_2))
        (WRITE.argument3_2_1 (READ.64[1].argument3_2))
        (WRITE.argument3_2_2 (READ.64[2].argument3_2))
        (WRITE.argument3_2_3 (READ.64[3].argument3_2))
        (WRITE.argument3_3 (ACCESS.E1.%3:3))
        (WRITE.argument3_3_0 (READ.64[0].argument3_3))
        (WRITE.argument3_3_1 (READ.64[1].argument3_3))
        (WRITE.argument3_3_2 (READ.64[2].argument3_3))
        (WRITE.argument3_3_3 (READ.64[3].argument3_3))
        (WRITE.argument3 (CONST.0))
        (IF
          (EQ (READ.qindex) (CONST.0))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_0) (READ.argument3_1_0) (READ.argument3_2_0) (READ.argument3_3_0)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.1))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_1) (READ.argument3_1_1) (READ.argument3_2_1) (READ.argument3_3_1)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.2))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_2) (READ.argument3_1_2) (READ.argument3_2_2) (READ.argument3_3_2)))
          (SKIP))
        (IF
          (EQ (READ.qindex) (CONST.3))
          (WRITE.argument3
            (APPLY.256.join_64_x4
              (READ.argument3_0_3) (READ.argument3_1_3) (READ.argument3_2_3) (READ.argument3_3_3)))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
Format:
  ## BCU: steering=00
  - ID: BCU_NOB
    what: BCU Opcode Error
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - bcucode7: "000000"
      - tcacode2: "0000"
      - tcacode5: "00"
      - bcucode6: { ERROP: "000000" }
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    scheduling: ALL
  - ID: BCU_PCREL11
    what: BCU PCREL11 Dummy
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { PCREL11: "00" }
      - ccbcomp: "0000"
      - pcrel11: "-----------"
      - registerY: "000000"
      - registerZ: "______"
    encoding: simple
    operands: [ pcrel11 ]
    syntax: "%0 %1"
    scheduling: ALL
    execution:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.RR.%1))
  - ID: BCU_PCREL11.X
    what: BCU PCREL Dummy
    fields2:
      - parallel2: "-"
    fields1:
      - steerimx: "00"
      - exunum2: "00"
      - upper27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "00"
      - bcucode1: { PCREL38: "00" }
      - ccbcomp: "0000"
      - lower11: "-----------"
      - registerY: "000000"
      - registerZ: "______"
    encoding: double
    operands: [ { pcrel38: [ upper27, lower11 ] } ]
    syntax: "%0 %1"
    scheduling: ALL
    execution:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.RR.%1))
  - ID: BCU_BREAK
    what: BCU Break
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - bcucode7: "000000"
      - exucode4: "00"
      - silent: { BREAK: "1" }
      - rounding: "000"
      - bcucode6: "000000"
      - brkunused: "____"
      - brknumber: "--"
    encoding: simple
    operands: [ brknumber ]
    syntax: "%0 %1"
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_XMOVEFD
    what: BCU Move From Coprocessor Double Word
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMOVEFD: "000" }
      - registerW: "------"
      - exucode4: "00"
      - exubit15: "1"
      - exubit14: "1"
      - qselectC: "--"
      - registerCc: "------"
      - unused6: "______"
    encoding: simple
    operands: [ { singleReg: registerW }, { xworddReg: [ registerCc, qselectC ] } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBCV
    behavior: *behaviorBCV
  - ID: BCU_XMOVEFQ
    what: BCU Move From Coprocessor Quadruple Word
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMOVEFQ: "000" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exubit15: "0"
      - exubit14: "0"
      - exubit13: "0"
      - hselectC: "-"
      - registerCb: "------"
      - unused6: "______"
    encoding: simple
    operands: [ { pairedReg: registerM }, { xwordqReg: [ registerCb, hselectC ] } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBCV
    behavior: *behaviorBCV
  - ID: BCU_XMOVEFO
    what: BCU Move From Coprocessor Octuple Word
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMOVEFO: "000" }
      - registerN: "----"
      - bcucode4: "01"
      - exucode4: "00"
      - silent: "1"
      - log2size: "000"
      - registerC: "------"
      - byteshift: "______"
    encoding: simple
    operands: [ { quadReg: registerN }, { xwordoReg: registerC } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBCV
    behavior: *behaviorBCV
  - ID: BCU_XACCESSO2
    what: BCU XACCESSO from 2-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCg: "-----"
      - buffcode1: "0"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer2Reg: registerCg }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA2
    behavior: *behaviorBIA2
  - ID: BCU_XACCESSO4
    what: BCU XACCESSO from 4-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCh: "----"
      - buffcode2: "01"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer4Reg: registerCh }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA4
    behavior: *behaviorBIA4
  - ID: BCU_XACCESSO8
    what: BCU XACCESSO from 8-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCi: "---"
      - buffcode3: "011"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer8Reg: registerCi }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA8
    behavior: *behaviorBIA8
  - ID: BCU_XACCESSO16
    what: BCU XACCESSO from 16-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCj: "--"
      - buffcode4: "0111"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer16Reg: registerCj }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA16
    behavior: *behaviorBIA16
  - ID: BCU_XACCESSO32
    what: BCU XACCESSO from 32-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCk: "-"
      - buffcode5: "01111"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer32Reg: registerCk }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA32
    behavior: *behaviorBIA32
  - ID: BCU_XACCESSO64
    what: BCU XACCESSO from 64-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - registerN: "----"
      - bcucode4: "11"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XACCESSO: "000" }
      - registerCl: "-"
      - buffcode5: "11111"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { buffer64Reg: registerCl }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionBIA64
    behavior: *behaviorBIA64
  - ID: BCU_XCOPYO
    what: BCU XCOPYO
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "0"
      - log2size: { XCOPYO: "000" }
      - registerC: "------"
      - byteshift: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBCV
    behavior: *behaviorBCV
  - ID: BCU_XALIGNO2
    what: BCU XALIGNO from 2-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCg: "-----"
      - buffcode1: "0"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer2Reg: registerCg }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA2
    behavior: *behaviorBIA2
  - ID: BCU_XALIGNO4
    what: BCU XALIGNO from 4-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCh: "----"
      - buffcode2: "01"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer4Reg: registerCh }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA4
    behavior: *behaviorBIA4
  - ID: BCU_XALIGNO8
    what: BCU XALIGNO from 8-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCi: "---"
      - buffcode3: "011"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer8Reg: registerCi }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA8
    behavior: *behaviorBIA8
  - ID: BCU_XALIGNO16
    what: BCU XALIGNO from 16-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCj: "--"
      - buffcode4: "0111"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer16Reg: registerCj }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA16
    behavior: *behaviorBIA16
  - ID: BCU_XALIGNO32
    what: BCU XALIGNO from 32-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCk: "-"
      - buffcode5: "01111"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer32Reg: registerCk }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA32
    behavior: *behaviorBIA32
  - ID: BCU_XALIGNO64
    what: BCU XALIGNO from 64-Register Buffer
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "00"
      - silent: "1"
      - log2size: { XALIGNO: "000" }
      - registerCl: "-"
      - buffcode5: "11111"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { buffer64Reg: registerCl }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionBIA64
    behavior: *behaviorBIA64
  - ID: BCU_RVV
    what: BCU Reshape Vector to Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: "10"
      - silent: "0"
      - log2size: { "[ WEAVEV, VALIDV ]": "000..001" }
      - registerC: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionRVV
    behavior: *behaviorRVV
  - ID: BCU_XFSCALEWO
    what: BCU Floating Point Scale Word Octuple
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "001"
      - registerA: "------"
      - exucode4: { XFSCALEWO: "11" }
      - silent: "-"
      - rounding: "---"
      - registerC: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { singleReg: registerZ }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new pow2scale = _SX_6(%3);
      new argument2 = %2;
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.pow2scale (SX.6(ACCESS.RR.%3)))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
          (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
          (COMMIT.E4.%1
            (READ.result1)))
  - ID: EXT_MMABW0
    what: Extension Matrix Multiply Add Bytes to Words 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XMMA4164BW: "00" }
      - exucode5: "____"
      - registerCp: "-----"
      - exubit6: "0"
      - registerDp: "-----"
      - exubit0: "0"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, { xwordxReg: registerDp } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: &executionMMA4164BW |
      stage RR:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument2_0 = %2:0;
      new argument2_0_0 = argument2_0.64[0];
      new argument2_0_1 = argument2_0.64[1];
      new argument2_0_2 = argument2_0.64[2];
      new argument2_0_3 = argument2_0.64[3];
      new argument2_1 = %2:1;
      new argument2_1_0 = argument2_1.64[0];
      new argument2_1_1 = argument2_1.64[1];
      new argument2_1_2 = argument2_1.64[2];
      new argument2_1_3 = argument2_1.64[3];
      new argument2_r_0 = join_64_x2(argument2_0_0, argument2_1_0);
      new argument2_r_1 = join_64_x2(argument2_0_1, argument2_1_1);
      new argument2_r_2 = join_64_x2(argument2_0_2, argument2_1_2);
      new argument2_r_3 = join_64_x2(argument2_0_3, argument2_1_3);
      new argument3_r_0 = join_64_x2(argument3_0_0, argument3_1_0);
      new argument3_r_1 = join_64_x2(argument3_0_1, argument3_1_1);
      new argument3_r_2 = join_64_x2(argument3_0_2, argument3_1_2);
      new argument3_r_3 = join_64_x2(argument3_0_3, argument3_1_3);
      new argument1_0 = %1:0;
      new argument1_0_0 = argument1_0.32[0];
      new argument1_0_1 = argument1_0.32[1];
      new argument1_1_0 = argument1_0.32[2];
      new argument1_1_1 = argument1_0.32[3];
      new argument1_2_0 = argument1_0.32[4];
      new argument1_2_1 = argument1_0.32[5];
      new argument1_3_0 = argument1_0.32[6];
      new argument1_3_1 = argument1_0.32[7];
      new argument1_1 = %1:1;
      new argument1_0_2 = argument1_1.32[0];
      new argument1_0_3 = argument1_1.32[1];
      new argument1_1_2 = argument1_1.32[2];
      new argument1_1_3 = argument1_1.32[3];
      new argument1_2_2 = argument1_1.32[4];
      new argument1_2_3 = argument1_1.32[5];
      new argument1_3_2 = argument1_1.32[6];
      new argument1_3_3 = argument1_1.32[7];
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: &behaviorMMA4164BW |
      (SEQ
        (WRITE.argument3_0 (ACCESS.RR.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.RR.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (READ.64[0].argument2_0))
        (WRITE.argument2_0_1 (READ.64[1].argument2_0))
        (WRITE.argument2_0_2 (READ.64[2].argument2_0))
        (WRITE.argument2_0_3 (READ.64[3].argument2_0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_1_0 (READ.64[0].argument2_1))
        (WRITE.argument2_1_1 (READ.64[1].argument2_1))
        (WRITE.argument2_1_2 (READ.64[2].argument2_1))
        (WRITE.argument2_1_3 (READ.64[3].argument2_1))
        (WRITE.argument2_r_0 (APPLY.128.join_64_x2 (READ.argument2_0_0) (READ.argument2_1_0)))
        (WRITE.argument2_r_1 (APPLY.128.join_64_x2 (READ.argument2_0_1) (READ.argument2_1_1)))
        (WRITE.argument2_r_2 (APPLY.128.join_64_x2 (READ.argument2_0_2) (READ.argument2_1_2)))
        (WRITE.argument2_r_3 (APPLY.128.join_64_x2 (READ.argument2_0_3) (READ.argument2_1_3)))
        (WRITE.argument3_r_0 (APPLY.128.join_64_x2 (READ.argument3_0_0) (READ.argument3_1_0)))
        (WRITE.argument3_r_1 (APPLY.128.join_64_x2 (READ.argument3_0_1) (READ.argument3_1_1)))
        (WRITE.argument3_r_2 (APPLY.128.join_64_x2 (READ.argument3_0_2) (READ.argument3_1_2)))
        (WRITE.argument3_r_3 (APPLY.128.join_64_x2 (READ.argument3_0_3) (READ.argument3_1_3)))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_0_0 (READ.32[0].argument1_0))
        (WRITE.argument1_0_1 (READ.32[1].argument1_0))
        (WRITE.argument1_1_0 (READ.32[2].argument1_0))
        (WRITE.argument1_1_1 (READ.32[3].argument1_0))
        (WRITE.argument1_2_0 (READ.32[4].argument1_0))
        (WRITE.argument1_2_1 (READ.32[5].argument1_0))
        (WRITE.argument1_3_0 (READ.32[6].argument1_0))
        (WRITE.argument1_3_1 (READ.32[7].argument1_0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (WRITE.argument1_0_2 (READ.32[0].argument1_1))
        (WRITE.argument1_0_3 (READ.32[1].argument1_1))
        (WRITE.argument1_1_2 (READ.32[2].argument1_1))
        (WRITE.argument1_1_3 (READ.32[3].argument1_1))
        (WRITE.argument1_2_2 (READ.32[4].argument1_1))
        (WRITE.argument1_2_3 (READ.32[5].argument1_1))
        (WRITE.argument1_3_2 (READ.32[6].argument1_1))
        (WRITE.argument1_3_3 (READ.32[7].argument1_1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_MMABW1
    what: Extension Matrix Multiply Add Bytes to Words 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XMMAU4164BW: "01" }
      - exucode5: "____"
      - registerCp: "-----"
      - exubit6: "0"
      - registerDp: "-----"
      - exubit0: "0"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, { xwordxReg: registerDp } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA4164BW
    behavior: *behaviorMMA4164BW
  - ID: EXT_MMABW2
    what: Extension Matrix Multiply Add Bytes to Words 2
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XMMASU4164BW: "10" }
      - exucode5: "____"
      - registerCp: "-----"
      - exubit6: "0"
      - registerDp: "-----"
      - exubit0: "0"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, { xwordxReg: registerDp } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA4164BW
    behavior: *behaviorMMA4164BW
  - ID: EXT_MMABW3
    what: Extension Matrix Multiply Add Bytes to Words 3
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XMMAUS4164BW: "11" }
      - exucode5: "____"
      - registerCp: "-----"
      - exubit6: "0"
      - registerDp: "-----"
      - exubit0: "0"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, { xwordxReg: registerDp } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA4164BW
    behavior: *behaviorMMA4164BW
  - ID: EXT_MMABW
    what: Extension Matrix Multiply Add Bytes to Words 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { XMMA484BW: "00" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: &executionMMA484BW |
      stage RR:
      new argument3 = %3;
      new argument3_0 = argument3.64[0];
      new argument3_1 = argument3.64[1];
      new argument3_2 = argument3.64[2];
      new argument3_3 = argument3.64[3];
      new argument2 = %2;
      new argument2_0 = argument2.64[0];
      new argument2_1 = argument2.64[1];
      new argument2_2 = argument2.64[2];
      new argument2_3 = argument2.64[3];
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: &behaviorMMA484BW |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (READ.64[0].argument3))
        (WRITE.argument3_1 (READ.64[1].argument3))
        (WRITE.argument3_2 (READ.64[2].argument3))
        (WRITE.argument3_3 (READ.64[3].argument3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.64[0].argument2))
        (WRITE.argument2_1 (READ.64[1].argument2))
        (WRITE.argument2_2 (READ.64[2].argument2))
        (WRITE.argument2_3 (READ.64[3].argument2))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_MMAUBW
    what: Extension Matrix Multiply Add Bytes to Words 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { XMMAU484BW: "01" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_MMASUBW
    what: Extension Matrix Multiply Add Bytes to Words 2
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { XMMASU484BW: "10" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_MMAUSBW
    what: Extension Matrix Multiply Add Bytes to Words 3
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "010"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { XMMAUS484BW: "11" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_MADD44BW0
    what: Extension Multiply Add 4x4 Matrix Byte to Word 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "011"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { "[ XMADD44BW0, XMADDU44BW0, XMADDSU44BW0 ]": "00..10" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: |
      stage RR:
      new argument3 = %3;
      new argument3_0 = argument3.32[0];
      new argument3_1 = argument3.32[2];
      new argument3_2 = argument3.32[4];
      new argument3_3 = argument3.32[6];
      new argument2 = %2;
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[2];
      new argument2_2 = argument2.32[4];
      new argument2_3 = argument2.32[6];
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (READ.32[0].argument3))
        (WRITE.argument3_1 (READ.32[2].argument3))
        (WRITE.argument3_2 (READ.32[4].argument3))
        (WRITE.argument3_3 (READ.32[6].argument3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.32[0].argument2))
        (WRITE.argument2_1 (READ.32[2].argument2))
        (WRITE.argument2_2 (READ.32[4].argument2))
        (WRITE.argument2_3 (READ.32[6].argument2))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_MADD44BW1
    what: Extension Multiply Add 4x4 Matrix Byte to Word 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "011"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { "[ XMADD44BW1, XMADDU44BW1, XMADDSU44BW1 ]": "00..10" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: |
      stage RR:
      new argument3 = %3;
      new argument3_0 = argument3.32[1];
      new argument3_1 = argument3.32[3];
      new argument3_2 = argument3.32[5];
      new argument3_3 = argument3.32[7];
      new argument2 = %2;
      new argument2_0 = argument2.32[1];
      new argument2_1 = argument2.32[3];
      new argument2_2 = argument2.32[5];
      new argument2_3 = argument2.32[7];
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (READ.32[1].argument3))
        (WRITE.argument3_1 (READ.32[3].argument3))
        (WRITE.argument3_2 (READ.32[5].argument3))
        (WRITE.argument3_3 (READ.32[7].argument3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.32[1].argument2))
        (WRITE.argument2_1 (READ.32[3].argument2))
        (WRITE.argument2_2 (READ.32[5].argument2))
        (WRITE.argument2_3 (READ.32[7].argument2))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_MADDIFWO
    what: Extension Multiply Add Integer Floating Point Word Octuple
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerA: "------"
      - exucode4: { "[ XMADDIFWO, XMSBFIFWO ]": "00..01" }
      - silent: "-"
      - rounding: "---"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { xwordoReg: registerD }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    scheduling: EXT
    execution: &executionEXTVVVF |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1 = result1;
    behavior: &behaviorEXTVVVF |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
        (COMMIT.E4.%1
          (READ.result1)))
  - ID: EXT_FFMAHW
    what: Extension Floating Point Fused Multiply Add Half to Word
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XFFMA44HW: "10" }
      - silent: "-"
      - rounding: "---"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, { xwordoReg: registerD }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    scheduling: EXT
    execution: |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument3_0 = argument3.32[0];
      new argument3_1 = argument3.32[1];
      new argument3_2 = argument3.32[2];
      new argument3_3 = argument3.32[3];
      new argument3_4 = argument3.32[4];
      new argument3_5 = argument3.32[5];
      new argument3_6 = argument3.32[6];
      new argument3_7 = argument3.32[7];
      new argument2 = %2;
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[1];
      new argument2_2 = argument2.32[2];
      new argument2_3 = argument2.32[3];
      new argument2_4 = argument2.32[4];
      new argument2_5 = argument2.32[5];
      new argument2_6 = argument2.32[6];
      new argument2_7 = argument2.32[7];
      new argument1_0 = %1:0;
      new argument1_1 = %1:1;
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (READ.32[0].argument3))
        (WRITE.argument3_1 (READ.32[1].argument3))
        (WRITE.argument3_2 (READ.32[2].argument3))
        (WRITE.argument3_3 (READ.32[3].argument3))
        (WRITE.argument3_4 (READ.32[4].argument3))
        (WRITE.argument3_5 (READ.32[5].argument3))
        (WRITE.argument3_6 (READ.32[6].argument3))
        (WRITE.argument3_7 (READ.32[7].argument3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.32[0].argument2))
        (WRITE.argument2_1 (READ.32[1].argument2))
        (WRITE.argument2_2 (READ.32[2].argument2))
        (WRITE.argument2_3 (READ.32[3].argument2))
        (WRITE.argument2_4 (READ.32[4].argument2))
        (WRITE.argument2_5 (READ.32[5].argument2))
        (WRITE.argument2_6 (READ.32[6].argument2))
        (WRITE.argument2_7 (READ.32[7].argument2))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
        (COMMIT.E4.%1:0 (READ.result1_0))
        (COMMIT.E4.%1:1 (READ.result1_1)))
  - ID: EXT_FMMAHW
    what: Extension Floating-Point Matrix Multiply Add Half Words to Words
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XFMMA484HW: "11" }
      - silent: "-"
      - rounding: "---"
      - registerCp: "-----"
      - exubit6: "0"
      - registerDp: "-----"
      - exubit0: "0"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, { xwordxReg: registerDp }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3_0 = %3:0;
      new argument3_0_0 = argument3_0.64[0];
      new argument3_0_1 = argument3_0.64[1];
      new argument3_0_2 = argument3_0.64[2];
      new argument3_0_3 = argument3_0.64[3];
      new argument3_1 = %3:1;
      new argument3_1_0 = argument3_1.64[0];
      new argument3_1_1 = argument3_1.64[1];
      new argument3_1_2 = argument3_1.64[2];
      new argument3_1_3 = argument3_1.64[3];
      new argument2_0 = %2:0;
      new argument2_0_0 = argument2_0.64[0];
      new argument2_0_1 = argument2_0.64[1];
      new argument2_0_2 = argument2_0.64[2];
      new argument2_0_3 = argument2_0.64[3];
      new argument2_1 = %2:1;
      new argument2_1_0 = argument2_1.64[0];
      new argument2_1_1 = argument2_1.64[1];
      new argument2_1_2 = argument2_1.64[2];
      new argument2_1_3 = argument2_1.64[3];
      new argument2_r_0 = join_64_x2(argument2_0_0, argument2_1_0);
      new argument2_r_1 = join_64_x2(argument2_0_1, argument2_1_1);
      new argument2_r_2 = join_64_x2(argument2_0_2, argument2_1_2);
      new argument2_r_3 = join_64_x2(argument2_0_3, argument2_1_3);
      new argument3_r_0 = join_64_x2(argument3_0_0, argument3_1_0);
      new argument3_r_1 = join_64_x2(argument3_0_1, argument3_1_1);
      new argument3_r_2 = join_64_x2(argument3_0_2, argument3_1_2);
      new argument3_r_3 = join_64_x2(argument3_0_3, argument3_1_3);
      new argument1_0 = %1:0;
      new argument1_0_0_0 = argument1_0.32[0];
      new argument1_0_0_1 = argument1_0.32[1];
      new argument1_0_1_0 = argument1_0.32[2];
      new argument1_0_1_1 = argument1_0.32[3];
      new argument1_0_2_0 = argument1_0.32[4];
      new argument1_0_2_1 = argument1_0.32[5];
      new argument1_0_3_0 = argument1_0.32[6];
      new argument1_0_3_1 = argument1_0.32[7];
      new argument1_1 = %1:1;
      new argument1_1_0_0 = argument1_1.32[0];
      new argument1_1_0_1 = argument1_1.32[1];
      new argument1_1_1_0 = argument1_1.32[2];
      new argument1_1_1_1 = argument1_1.32[3];
      new argument1_1_2_0 = argument1_1.32[4];
      new argument1_1_2_1 = argument1_1.32[5];
      new argument1_1_3_0 = argument1_1.32[6];
      new argument1_1_3_1 = argument1_1.32[7];
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3_0 (ACCESS.RR.%3:0))
        (WRITE.argument3_0_0 (READ.64[0].argument3_0))
        (WRITE.argument3_0_1 (READ.64[1].argument3_0))
        (WRITE.argument3_0_2 (READ.64[2].argument3_0))
        (WRITE.argument3_0_3 (READ.64[3].argument3_0))
        (WRITE.argument3_1 (ACCESS.RR.%3:1))
        (WRITE.argument3_1_0 (READ.64[0].argument3_1))
        (WRITE.argument3_1_1 (READ.64[1].argument3_1))
        (WRITE.argument3_1_2 (READ.64[2].argument3_1))
        (WRITE.argument3_1_3 (READ.64[3].argument3_1))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (READ.64[0].argument2_0))
        (WRITE.argument2_0_1 (READ.64[1].argument2_0))
        (WRITE.argument2_0_2 (READ.64[2].argument2_0))
        (WRITE.argument2_0_3 (READ.64[3].argument2_0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_1_0 (READ.64[0].argument2_1))
        (WRITE.argument2_1_1 (READ.64[1].argument2_1))
        (WRITE.argument2_1_2 (READ.64[2].argument2_1))
        (WRITE.argument2_1_3 (READ.64[3].argument2_1))
        (WRITE.argument2_r_0 (APPLY.128.join_64_x2 (READ.argument2_0_0) (READ.argument2_1_0)))
        (WRITE.argument2_r_1 (APPLY.128.join_64_x2 (READ.argument2_0_1) (READ.argument2_1_1)))
        (WRITE.argument2_r_2 (APPLY.128.join_64_x2 (READ.argument2_0_2) (READ.argument2_1_2)))
        (WRITE.argument2_r_3 (APPLY.128.join_64_x2 (READ.argument2_0_3) (READ.argument2_1_3)))
        (WRITE.argument3_r_0 (APPLY.128.join_64_x2 (READ.argument3_0_0) (READ.argument3_1_0)))
        (WRITE.argument3_r_1 (APPLY.128.join_64_x2 (READ.argument3_0_1) (READ.argument3_1_1)))
        (WRITE.argument3_r_2 (APPLY.128.join_64_x2 (READ.argument3_0_2) (READ.argument3_1_2)))
        (WRITE.argument3_r_3 (APPLY.128.join_64_x2 (READ.argument3_0_3) (READ.argument3_1_3)))
        (WRITE.argument1_0 (ACCESS.RR.%1:0))
        (WRITE.argument1_0_0_0 (READ.32[0].argument1_0))
        (WRITE.argument1_0_0_1 (READ.32[1].argument1_0))
        (WRITE.argument1_0_1_0 (READ.32[2].argument1_0))
        (WRITE.argument1_0_1_1 (READ.32[3].argument1_0))
        (WRITE.argument1_0_2_0 (READ.32[4].argument1_0))
        (WRITE.argument1_0_2_1 (READ.32[5].argument1_0))
        (WRITE.argument1_0_3_0 (READ.32[6].argument1_0))
        (WRITE.argument1_0_3_1 (READ.32[7].argument1_0))
        (WRITE.argument1_1 (ACCESS.RR.%1:1))
        (WRITE.argument1_1_0_0 (READ.32[0].argument1_1))
        (WRITE.argument1_1_0_1 (READ.32[1].argument1_1))
        (WRITE.argument1_1_1_0 (READ.32[2].argument1_1))
        (WRITE.argument1_1_1_1 (READ.32[3].argument1_1))
        (WRITE.argument1_1_2_0 (READ.32[4].argument1_1))
        (WRITE.argument1_1_2_1 (READ.32[5].argument1_1))
        (WRITE.argument1_1_3_0 (READ.32[6].argument1_1))
        (WRITE.argument1_1_3_1 (READ.32[7].argument1_1))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
        (COMMIT.E4.%1:0 (READ.result1_0))
        (COMMIT.E4.%1:1 (READ.result1_1)))
  - ID: EXT_FNARROWWH
    what: Extension Floating Point Narrow Word to Half Word
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "101"
      - registerA: "------"
      - exucode4: { XFNARROW44WH: "00" }
      - silent: "-"
      - rounding: "---"
      - registerCp: "-----"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordxReg: registerCp }, rounding, silent ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: EXT
    execution: |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2_0 = %2:0;
      new argument2_0_0_0_1 = argument2_0.64[0];
      new argument2_1_0_1_1 = argument2_0.64[1];
      new argument2_2_0_2_1 = argument2_0.64[2];
      new argument2_3_0_3_1 = argument2_0.64[3];
      new argument2_1 = %2:1;
      new argument2_0_2_0_3 = argument2_1.64[0];
      new argument2_1_2_1_3 = argument2_1.64[1];
      new argument2_2_2_2_3 = argument2_1.64[2];
      new argument2_3_2_3_3 = argument2_1.64[3];
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1 = (result1_1 << 128) | _ZX_128(result1_0);
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0_0_1 (READ.64[0].argument2_0))
        (WRITE.argument2_1_0_1_1 (READ.64[1].argument2_0))
        (WRITE.argument2_2_0_2_1 (READ.64[2].argument2_0))
        (WRITE.argument2_3_0_3_1 (READ.64[3].argument2_0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_0_2_0_3 (READ.64[0].argument2_1))
        (WRITE.argument2_1_2_1_3 (READ.64[1].argument2_1))
        (WRITE.argument2_2_2_2_3 (READ.64[2].argument2_1))
        (WRITE.argument2_3_2_3_3 (READ.64[3].argument2_1))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E4.%1
          (IOR
            (SHL (READ.result1_1) (CONST.128))
            (ZX.128 (READ.result1_0)))))
  - ID: EXT_FMINMAX
    what: Extension Floating Point Minimum and Maximum
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "101"
      - registerA: "------"
      - exucode4: { "[ XFMINHX, XFMAXHX ]": "01..10" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: &executionEXTVVV |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorEXTVVV |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1
          (READ.result1)))
  - ID: EXT_CLAMPWO
    what: Extension Clamp Word Octuple
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "101"
      - registerA: "------"
      - exucode4: { XCLAMPWO: "11" }
      - exucode5: "____"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: *executionEXTVVV
    behavior: *behaviorEXTVVV
  - ID: EXT_TRUNCWB
    what: Extension Truncate Word to Byte Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "110"
      - registerA: "------"
      - exucode4: { XTRUNC48WB: "00" }
      - exucode5: "____"
      - registerCq: "----"
      - exucode7: "00"
      - registerD: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordvReg: registerCq } ]
    syntax: "%0 %1 = %2"
    scheduling: EXT
    execution: |
      stage RR:
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1
          (READ.result1)))
  - ID: EXT_XEXTBW
    what: Extension Extend Bytes to Words
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "110"
      - registerAq: "----"
      - tcacode3: { "[ XSX48BW, XZX48BW ]": "00..01" }
      - exucode4: "01"
      - exucode5: "____"
      - registerC: "------"
      - registerD: "______"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordoReg: registerC } ]
    syntax: "%0 %1 = %2"
    scheduling: EXT
    execution: |
      stage RR:
      new argument2 = %2;
      new argument2_0 = argument2.64[0];
      new argument2_1 = argument2.64[1];
      new argument2_2 = argument2.64[2];
      new argument2_3 = argument2.64[3];
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.64[0].argument2))
        (WRITE.argument2_1 (READ.64[1].argument2))
        (WRITE.argument2_2 (READ.64[2].argument2))
        (WRITE.argument2_3 (READ.64[3].argument2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_XSPLATOX
    what: Extension Coprocessor Splat Word Octuple to Hexadecuple
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerAp: "-----"
      - exubit18: "0"
      - exucode4: { XSPLATOX: "00" }
      - exubit15: "_"
      - shuffleX: "---"
      - registerC: "------"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordoReg: registerC }, shuffleX ]
    syntax: "%0%3 %1 = %2"
    scheduling: EXT
    execution: |
      stage ID:
      new shuffleX = %3;
      stage RR:
      new argument2 = %2;
      new argument2_0 = argument2;
      new argument2_1 = argument2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.shuffleX (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.argument2))
        (WRITE.argument2_1 (READ.argument2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_XCOPYX
    what: Extension Coprocessor Copy Word Hexadecuple
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerAp: "-----"
      - exubit18: "1"
      - exucode4: { XCOPYX: "00" }
      - exubit15: "_"
      - shuffleX: "---"
      - registerCp: "-----"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerCp }, shuffleX ]
    syntax: "%0%3 %1 = %2"
    scheduling: EXT
    execution: |
      stage ID:
      new shuffleX = %3;
      stage RR:
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.shuffleX (ACCESS.ID.%3))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_XSPLATOV
    what: Extension Coprocessor Splat Word Octuple to Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerAq: "----"
      - tcacode3: "00"
      - exucode4: { XSPLATOV: "01" }
      - tcacode4: "___"
      - shuffleV: "-"
      - registerC: "------"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordoReg: registerC }, shuffleV ]
    syntax: "%0%3 %1 = %2"
    scheduling: EXT
    execution: |
      stage ID:
      new shuffleV = %3;
      stage RR:
      new argument2 = %2;
      new argument2_0 = argument2;
      new argument2_1 = argument2;
      new argument2_2 = argument2;
      new argument2_3 = argument2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: |
      (SEQ
        (WRITE.shuffleV (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument2_0 (READ.argument2))
        (WRITE.argument2_1 (READ.argument2))
        (WRITE.argument2_2 (READ.argument2))
        (WRITE.argument2_3 (READ.argument2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_XCOPYV
    what: Extension Coprocessor Copy Word Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerAq: "----"
      - tcacode3: "01"
      - exucode4: { XCOPYV: "01" }
      - tcacode4: "___"
      - shuffleV: "-"
      - registerCq: "----"
      - exucode7: "00"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordvReg: registerCq }, shuffleV ]
    syntax: "%0%3 %1 = %2"
    scheduling: EXT
    execution: |
      stage ID:
      new shuffleV = %3;
      stage RR:
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: |
      (SEQ
        (WRITE.shuffleV (ACCESS.ID.%3))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_XSBMM8
    what: Extension Bit Matrix Multiply
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerA: "------"
      - exucode4: "10"
      - exucode5: { "[ XSBMM8DQ, XSBMMT8DQ ]": "1110..1111" }
      - registerC: "------"
      - registerB: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerB }, { xwordoReg: registerC } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: EXT_XBWO
    what: Extension Bitwise Octuple WOrd
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerA: "------"
      - exucode4: "11"
      - exucode5: { "[ XANDO, XNANDO, XIORO, XNIORO, XEORO, XNEORO, XANDNO, XIORNO ]": "0000..0111" }
      - registerC: "------"
      - registerB: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerB }, { xwordoReg: registerC } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: EXT
    execution: |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BCU_CB
    what: BCU Conditional Branches
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { CB: "01" }
      - branchcond: "----"
      - pcrel17: "-----------------"
      - registerZ: "------"
    encoding: simple
    operands: [ scalarcond: branchcond, { singleReg: registerZ }, pcrel17 ]
    syntax: "%0%1 %2? %3"
    properties: { '%0': Control;Conditional, '%3': Target }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
      new argument2 = %2;
      new argument3 = %3;
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.ID.%1))
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument3 (ACCESS.ID.%3)))
  - ID: BCU_HLS
    what: BCU Hardware Loop Setup
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { LOOPDO: "1110" }
      - pcrel17: "-----------------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, pcrel17 ]
    syntax: "%0 %1, %2"
    properties: { '%0': Control, '%2': Target }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
      new argument2 = %2;
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.ID.%1))
        (WRITE.argument2 (ACCESS.ID.%2)))
  - ID: BCU_TLB
    what: BCU TLB Management
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ TLBREAD, TLBPROBE, TLBWRITE ]": "00000..00010", "[ TLBDINVAL, TLBIINVAL ]": "00011..00100" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: ALL
  - ID: BCU_IPC
    what: BCU Instruction Pipeline Control
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ AWAIT, SLEEP, STOP, BARRIER ]": "01000..01011" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: ALL
  - ID: BCU_PGI
    what: BCU Processing Group Instructions
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WAITIT, SYNCGROUP ]": "01100..01101" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_WFX
    what: BCU Half-Word Effects
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemT2: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlyfxReg: systemT2 }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: BCU
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_WFXA
    what: BCU Half-Word Effects Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { aloneReg: systemAlone }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: ALL
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_WFXHW
    what: BCU Half-Word Effects [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemT4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { systemReg: systemT4 }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: BCU
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_SET
    what: BCU Set System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemT3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlysetReg: systemT3 }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETA
    what: BCU Set System Register Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { aloneReg: systemAlone }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALL
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETRA
    what: BCU Set System Register RA
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemRA: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlyraReg: systemRA }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETHW
    what: BCU Set System Registers [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemT4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { systemReg: systemT4 }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_GSR
    what: BCU Get System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { GET: "10001" }
      - bcucode8: "___"
      - systemS2: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { onlygetReg: systemS2 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionGET
    behavior: *behaviorGET
  - ID: BCU_GSRHW
    what: BCU Get System Registers [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { GET: "10001" }
      - bcucode8: "___"
      - systemS3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { systemReg: systemS3 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionGET
    behavior: *behaviorGET
  - ID: BCU_RSWAP
    what: BCU General and System Register Swap
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemS4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { onlyswapReg: systemS4 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_RSWAPA
    what: BCU General and System Register Swap Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { aloneReg: systemAlone } ]
    syntax: "%0 %1 = %2"
    scheduling: ALL
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_RSWAPHW
    what: BCU General and System Register Swap [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemS3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { systemReg: systemS3 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_IGSR
    what: BCU Indirect Get System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { IGET: "10011" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: |
      stage ID:
      new index = _ZX_9(%1);
      stage RR:
      @Instruction
      stage E1:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.index (ZX.9 (ACCESS.ID.%1)))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: BCU_RTS
    what: BCU Return from Call and System Calls
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ RET, RFE ]": "10100..10101" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: BCU
  - ID: BCU_IBC
    what: BCU Indirect Branch and Call from Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ IGOTO, ICALL ]": "10110..10111" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_SCI
    what: BCU Supervisor Call Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { SCALL: "1111" }
      - bcucode3: "11000"
      - bcucode5: "______"
      - sysnumber: "------------"
    encoding: simple
    operands: [ sysnumber ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_SCR
    what: BCU Supervisor Call Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { SCALL: "1111" }
      - bcucode3: "11001"
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_UB
    what: BCU Unconditional Branches
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { "[ GOTO, CALL ]": "10..11" }
      - pcrel27: "---------------------------"
    encoding: simple
    operands: [ pcrel27 ]
    syntax: "%0 %1"
    properties: { '%0': Control, '%1': Target }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  ## LSU: steering=01
  - ID: LSU_LSBO
    what: LSU Load Scalar Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: &loadsingle { "[ LBZ, LBS, LHZ, LHS ]": "000..011", "[ LWZ, LWS, LD ]": "100..110" }
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: &descriptionLSBO >
      The effective address is computed by adding the %3 to the %2.
    properties: &propertiesLSBO { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LSBO.X
    what: LSU Load Scalar Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: &fieldsX
      - steerimx: "00"
      - exunum2: "__"
      - upper27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LSBO: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.X
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LSBO.Y
    what: LSU Load Scalar Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: &fieldsY
      - steerimx3: "00"
      - exunum3: "__"
      - extend27: "---------------------------"
      - parallel2: "1"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LSBO: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.Y
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LQBO
    what: LSU Load Quadruple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LQBO.X
    what: LSU Load Quadruple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LQBO: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.X
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LQBO.Y
    what: LSU Load Quadruple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LQBO: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.Y
    execution: *executionLSBO
    behavior: *behaviorLSBO
  - ID: LSU_LOBO
    what: LSU Load Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW
    execution: *executionLQBO
    behavior: *behaviorLQBO
  - ID: LSU_LOBO.X
    what: LSU Load Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LOBO: 0..31 }
    encoding: double
    operands: [ { quadReg: registerN }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.X
    execution: *executionLQBO
    behavior: *behaviorLQBO
  - ID: LSU_LOBO.Y
    what: LSU Load Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LOBO: 0..31 }
    encoding: triple
    operands: [ { quadReg: registerN }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLSBO
    scheduling: LSU_AUXW.Y
    execution: *executionLQBO
    behavior: *behaviorLQBO
  - ID: LSU_FXBO
    what: LSU Memory Effects Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: &memoryeffects { "[ DTOUCHL, DINVALL, DPURGEL, DFLUSHL ]": "0000..0011", "[ I1TOUCHL, I1INVALS ]": "0100..0101" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, signed10 ]
    syntax: "%0 %2[%1]"
    description: &descriptionFXBO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesFXBO { '%0': MemoryEffect, '%1': Base, '%2': Offset }
    scheduling: LSU
    execution: *executionFXBO
    behavior: *behaviorFXBO
  - ID: LSU_FXBO.X
    what: LSU Memory Effects Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FXBO: 0..31 }
    encoding: double
    operands: [ { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %2[%1]"
    description: *descriptionFXBO
    properties: *propertiesFXBO
    scheduling: LSU.X
    execution: *executionFXBO
    behavior: *behaviorFXBO
  - ID: LSU_FXBO.Y
    what: LSU Memory Effects Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FXBO: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %2[%1]"
    description: *descriptionFXBO
    properties: *propertiesFXBO
    scheduling: LSU.Y
    execution: *executionFXBO
    behavior: *behaviorFXBO
  - ID: LSU_MCC
    what: LSU Memory and Cache Control
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: { D1INVAL: "1000", I1INVAL: "1100" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - unused16: "________________"
    encoding: simple
    syntax: "%0"
    scheduling: LSU
  - ID: LSU_FENCE
    what: LSU Memory Fence
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - accesses: "--"
      - lsucode2: { FENCE: "1111" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - unused16: "________________"
    encoding: simple
    operands: [ accesses ]
    syntax: "%0%1"
    scheduling: LSU
    execution: |
      stage ID:
      new accesses = %1;
      @Instruction
    behavior: |
      (SEQ
        (WRITE.accesses (ACCESS.ID.%1))
        (MACRO.Instruction))
  - ID: LSU_XLOBO
    what: LSU Extension Load Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: &propertiesLBOV { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLVBO
    behavior: *behaviorLVBO
  - ID: LSU_XLOBO.X
    what: LSU Extension Load Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOBO: 0..31 }
    encoding: double
    operands: [ { xwordoReg: registerG }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.X
    execution: *executionLVBO
    behavior: *behaviorLVBO
  - ID: LSU_XLOBO.Y
    what: LSU Extension Load Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOBO: 0..31 }
    encoding: triple
    operands: [ { xwordoReg: registerG }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.Y
    execution: *executionLVBO
    behavior: *behaviorLVBO
  - ID: LSU_XLOC2BO
    what: LSU Extension Load Octuple Cross 2 Base Offset
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordxReg: registerGp }, signed10, { singleReg: registerZ }, hindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU
    execution: *executionLVPBO
    behavior: *behaviorLVPBO
  - ID: LSU_XLOC2BO.X
    what: LSU Extension Load Octuple Cross 2 Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOC2BO: 0..31 }
    encoding: double
    operands: [ { xwordxReg: registerGp }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, hindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.X
    execution: *executionLVPBO
    behavior: *behaviorLVPBO
  - ID: LSU_XLOC2BO.Y
    what: LSU Extension Load Octuple Cross 2 Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOC2BO: 0..31 }
    encoding: triple
    operands: [ { xwordxReg: registerGp }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, hindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.Y
    execution: *executionLVPBO
    behavior: *behaviorLVPBO
  - ID: LSU_XLOC4BO
    what: LSU Extension Load Octuple Cross 4 Base Offset
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, signed10, { singleReg: registerZ }, qindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU
    execution: *executionLVQBO
    behavior: *behaviorLVQBO
  - ID: LSU_XLOC4BO.X
    what: LSU Extension Load Octuple Cross 4 Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOC4BO: 0..31 }
    encoding: double
    operands: [ { xwordvReg: registerGq }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, qindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.X
    execution: *executionLVQBO
    behavior: *behaviorLVQBO
  - ID: LSU_XLOC4BO.Y
    what: LSU Extension Load Octuple Cross 4 Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOC4BO: 0..31 }
    encoding: triple
    operands: [ { xwordvReg: registerGq }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, qindex, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBO
    properties: *propertiesLBOV
    scheduling: LSU.Y
    execution: *executionLVQBO
    behavior: *behaviorLVQBO
  - ID: LSU_SSBO
    what: LSU Store Scalar Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &storesingle { "[ SB, SH, SW, SD ]": "10000..10011" }
      - registerT: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: &descriptionSBO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesSBO { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SSBO.X
    what: LSU Store Scalar Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SSBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SSBO.Y
    what: LSU Store Scalar Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SSBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO
    what: LSU Store Quadruple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO.X
    what: LSU Store Quadruple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SQBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO.Y
    what: LSU Store Quadruple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SQBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SOBO
    what: LSU Store Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR
    execution: *executionSQBO
    behavior: *behaviorSQBO
  - ID: LSU_SOBO.X
    what: LSU Store Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SOBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSQBO
    behavior: *behaviorSQBO
  - ID: LSU_SOBO.Y
    what: LSU Store Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SOBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSQBO
    behavior: *behaviorSQBO
  - ID: LSU_COPYO
    what: LSU Copy Octuple Word
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { COPYO: "10100" }
      - registerN: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "__________"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { quadReg: registerN }, { quadReg: registerR } ]
    properties: &propertiesCOPYO { '%2': Stored }
    syntax: "%0 %1 = %2"
    scheduling: LSU_AUXR_AUXW
    execution: |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E3:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E3.%1 (READ.result1)))
  - ID: LSU_XSOBO
    what: LSU Extension Store Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVBO
    scheduling: LSU_CRRP
    execution: *executionSVBO
    behavior: *behaviorSVBO
  - ID: LSU_XSOBO.X
    what: LSU Extension Store Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVBO
    scheduling: LSU_CRRP.X
    execution: *executionSVBO
    behavior: *behaviorSVBO
  - ID: LSU_XSOBO.Y
    what: LSU Extension Store Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVBO
    behavior: *behaviorSVBO
  - ID: LSU_XSOC2BO
    what: LSU Extension Store Octuple Cross 2 Base Offset
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { xwordxReg: registerEp }, hindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVPBO
    scheduling: LSU_CRRP
    execution: *executionSVPBO
    behavior: *behaviorSVPBO
  - ID: LSU_XSOC2BO.X
    what: LSU Extension Store Octuple Cross 2 Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOC2BO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { xwordxReg: registerEp }, hindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVPBO
    scheduling: LSU_CRRP.X
    execution: *executionSVPBO
    behavior: *behaviorSVPBO
  - ID: LSU_XSOC2BO.Y
    what: LSU Extension Store Octuple Cross 2 Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOC2BO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { xwordxReg: registerEp }, hindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVPBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVPBO
    behavior: *behaviorSVPBO
  - ID: LSU_XSOC4BO
    what: LSU Extension Store Octuple Cross 4 Base Offset
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { xwordvReg: registerEq }, qindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: &propertiesSVQBO { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVQBO
    behavior: *behaviorSVQBO
  - ID: LSU_XSOC4BO.X
    what: LSU Extension Store Cross 4 Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOC4BO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { xwordvReg: registerEq }, qindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVQBO
    scheduling: LSU_CRRP.X
    execution: *executionSVQBO
    behavior: *behaviorSVQBO
  - ID: LSU_XSOC4BO.Y
    what: LSU Extension Store Octuple Cross 4 Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOC4BO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { xwordvReg: registerEq }, qindex ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSVQBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVQBO
    behavior: *behaviorSVQBO
  - ID: LSU_LSPB
    what: LSU Load Scalar Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: &descriptionLPB >
      The effective address is given by the %3. The predicate is computed on the %2 with the %4.
    properties: &propertiesLSPB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLSPB
    behavior: *behaviorLSPB
  - ID: LSU_LSPB.O
    what: LSU Load Scalar Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: &fieldsO
      - steerimx: "00"
      - exunum2: "__"
      - offset27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LSPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed27: offset27 } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: &descriptionLPBO >
      The effective address is given by adding the %5 to the %3. The predicate is computed on the %2 with the %4.
    properties: &propertiesLSPBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%6': Offset }
    scheduling: LSU_AUXW.X
    execution: *executionLSPBO
    behavior: *behaviorLSPBO
  - ID: LSU_LSPB.D
    what: LSU Load Scalar Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LSPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLSPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLSPBO
    behavior: *behaviorLSPBO
  - ID: LSU_LQPB
    what: LSU Load Quadruple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLSPB
    scheduling: LSU_AUXW
    execution: *executionLSPB
    behavior: *behaviorLSPB
  - ID: LSU_LQPB.O
    what: LSU Load Quadruple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LQPB: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed27: offset27 } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLSPBO
    scheduling: LSU_AUXW.X
    execution: *executionLSPBO
    behavior: *behaviorLSPBO
  - ID: LSU_LQPB.D
    what: LSU Load Quadruple Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LQPB: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLSPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLSPBO
    behavior: *behaviorLSPBO
  - ID: LSU_LOPB
    what: LSU Load Octuple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLSPB
    scheduling: LSU_AUXW
    execution: *executionLQPB
    behavior: *behaviorLQPB
  - ID: LSU_LOPB.O
    what: LSU Load Octuple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOPB: 0..31 }
    encoding: double
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed27: offset27 } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLSPBO
    scheduling: LSU_AUXW.X
    execution: *executionLQPBO
    behavior: *behaviorLQPBO
  - ID: LSU_LOPB.D
    what: LSU Load Octuple Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOPB: 0..31 }
    encoding: triple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLSPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLQPBO
    behavior: *behaviorLQPBO
  - ID: LSU_LOMB
    what: LSU Load Octuple Masked Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, lsomask, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: &propertiesLQMB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLQMB
    behavior: *behaviorLQMB
  - ID: LSU_LOMB.O
    what: LSU Load Octuple Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOMB: 0..31 }
    encoding: double
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, lsomask, variant, { signed27: offset27 } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: &propertiesLQMBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%6': Offset }
    scheduling: LSU_AUXW.X
    execution: *executionLQMBO
    behavior: *behaviorLQMBO
  - ID: LSU_LOMB.D
    what: LSU Load Octuple Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOMB: 0..31 }
    encoding: triple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, lsomask, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLQMBO
    scheduling: LSU_AUXW.Y
    execution: *executionLQMBO
    behavior: *behaviorLQMBO
  - ID: LSU_LSBI
    what: LSU Load Scalar Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: &descriptionLSBI >
      The effective address is computed by adding the %3 to the %2 and scaled by the %4.
    properties: &propertiesLSBI { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLSBI
    behavior: *behaviorLSBI
  - ID: LSU_LQBI
    what: LSU Load Quadruple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBI
    properties: *propertiesLSBI
    scheduling: LSU_AUXW
    execution: *executionLSBI
    behavior: *behaviorLSBI
  - ID: LSU_LOBI
    what: LSU Load Octuple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBI
    properties: *propertiesLSBI
    scheduling: LSU_AUXW
    execution: *executionLQBI
    behavior: *behaviorLQBI
  - ID: LSU_FXBI
    what: LSU Memory Effects Base + Index
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, doscale ]
    syntax: "%0%3 %1[%2]"
    description: &descriptionFXBI >
      The effective address is computed by adding the %2 to the %1.
    properties: &attributesFXBI { '%0': MemoryEffect, '%1': Offset, '%2': Base }
    scheduling: LSU
    execution: *executionFXBI
    behavior: *behaviorFXBI
  - ID: LSU_FXSW
    what: LSU Memory Effects by Set / Way
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "--"
      - lsucode2: { "[ DINVALSW, DPURGESW, DFLUSHSW ]": "1001..1011" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "_"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, cachelev ]
    syntax: "%0%3 %1, %2"
    properties: { '%0': MemoryEffect, '%1': Tested, '%2': Base }
    scheduling: LSU
    execution: *executionFXSW
    behavior: *behaviorFXSW
  - ID: LSU_XLOMB
    what: LSU Extension Load Octuple Masked Base
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, lsumask, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: &propertiesLVMB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLVMB
    behavior: *behaviorLVMB
  - ID: LSU_XLOMB.O
    what: LSU Extension Load Octuple Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOMB: 0..31 }
    encoding: double
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, lsumask, variant, { signed27: offset27 } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: &propertiesLVMBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%6': Offset, '%CS': NoEffects }
    scheduling: LSU.X
    execution: *executionLVMBO
    behavior: *behaviorLVMBO
  - ID: LSU_XLOMB.D
    what: LSU Extension Load Octuple Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOMB: 0..31 }
    encoding: triple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, lsumask, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %2? %1 = %6[%3]"
    description: *descriptionLPBO
    properties: *propertiesLVMBO
    scheduling: LSU.Y
    execution: *executionLVMBO
    behavior: *behaviorLVMBO
  - ID: LSU_XLOC2MB
    what: LSU Extension Load Octuple Cross 2 Masked Base
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordxReg: registerGp }, { singleReg: registerY }, { singleReg: registerZ }, hindex, lsumask, variant ]
    syntax: "%0%6%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: &propertiesLVPMB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLVPMB
    behavior: *behaviorLVPMB
  - ID: LSU_XLOC2MB.O
    what: LSU Extension Load Octuple Cross 2 Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOC2MB: 0..31 }
    encoding: double
    operands: [ { xwordxReg: registerGp }, { singleReg: registerY }, { singleReg: registerZ }, hindex, lsumask, variant, { signed27: offset27 } ]
    syntax: "%0%6%5%4 %2? %1 = %7[%3]"
    description: *descriptionLPBO
    properties: &propertiesLVPMBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%7': Offset, '%CS': NoEffects }
    scheduling: LSU.X
    execution: *executionLVPMBO
    behavior: *behaviorLVPMBO
  - ID: LSU_XLOC2MB.D
    what: LSU Extension Load Octuple Cross 2 Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOC2MB: 0..31 }
    encoding: triple
    operands: [ { xwordxReg: registerGp }, { singleReg: registerY }, { singleReg: registerZ }, hindex, lsumask, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%6%5%4 %2? %1 = %7[%3]"
    description: *descriptionLPBO
    properties: *propertiesLVPMBO
    scheduling: LSU.Y
    execution: *executionLVPMBO
    behavior: *behaviorLVPMBO
  - ID: LSU_XLOC4MB
    what: LSU Extension Load Octuple Cross 4 Masked Base
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, qindex, lsumask, variant ]
    syntax: "%0%6%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: &propertiesLVQMB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLVQMB
    behavior: *behaviorLVQMB
  - ID: LSU_XLOC4MB.O
    what: LSU Extension Load Octuple Cross 4 Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOC4MB: 0..31 }
    encoding: double
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, qindex, lsumask, variant, { signed27: offset27 } ]
    syntax: "%0%6%5%4 %2? %1 = %7[%3]"
    description: *descriptionLPBO
    properties: &propertiesLVQMBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%7': Offset, '%CS': NoEffects }
    scheduling: LSU.X
    execution: *executionLVQMBO
    behavior: *behaviorLVQMBO
  - ID: LSU_XLOC4MB.D
    what: LSU Extension Load Octuple Cross 4 Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLOC4MB: 0..31 }
    encoding: triple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, qindex, lsumask, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%6%5%4 %2? %1 = %7[%3]"
    description: *descriptionLPBO
    properties: *propertiesLVQMBO
    scheduling: LSU.Y
    execution: *executionLVQMBO
    behavior: *behaviorLVQMBO
  - ID: LSU_XPL2RBB
    what: LSU Extension Preload 2-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGg: "-----"
      - loadcode1: "0"
      - lsucode4: "11"
      - lsucode6: &opcodesXPRB { "[ XPLO, XPLQ, XPLD, XPLW, XPLH, XPLB ]": "0000..0101" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer2Reg: registerGg }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: &propertiesLVBPB { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionXP2RBB
    behavior: *behaviorXP2RBB
  - ID: LSU_XPL2RBB.O
    what: LSU Extension Preload 2-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGg: "-----"
      - loadcode1: "0"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer2Reg: registerGg }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: &propertiesLVBPBO { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%5': Offset, '%CS': NoEffects }
    scheduling: LSU.X
    execution: *executionXP2RBBO
    behavior: *behaviorXP2RBBO
  - ID: LSU_XPL2RBB.D
    what: LSU Extension Preload 2-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGg: "-----"
      - loadcode1: "0"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer2Reg: registerGg }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP2RBBO
    behavior: *behaviorXP2RBBO
  - ID: LSU_XPL4RBB
    what: LSU Extension Preload 4-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGh: "----"
      - loadcode2: "01"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer4Reg: registerGh }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: *propertiesLVBPB
    scheduling: LSU
    execution: *executionXP4RBB
    behavior: *behaviorXP4RBB
  - ID: LSU_XPL4RBB.O
    what: LSU Extension Preload 4-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGh: "----"
      - loadcode2: "01"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer4Reg: registerGh }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.X
    execution: *executionXP4RBBO
    behavior: *behaviorXP4RBBO
  - ID: LSU_XPL4RBB.D
    what: LSU Extension Preload 4-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGh: "----"
      - loadcode2: "01"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer4Reg: registerGh }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP4RBBO
    behavior: *behaviorXP4RBBO
  - ID: LSU_XPL8RBB
    what: LSU Extension Preload 8-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGi: "---"
      - loadcode3: "011"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer8Reg: registerGi }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: *propertiesLVBPB
    scheduling: LSU
    execution: *executionXP8RBB
    behavior: *behaviorXP8RBB
  - ID: LSU_XPL8RBB.O
    what: LSU Extension Preload 8-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGi: "---"
      - loadcode3: "011"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer8Reg: registerGi }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.X
    execution: *executionXP8RBBO
    behavior: *behaviorXP8RBBO
  - ID: LSU_XPL8RBB.D
    what: LSU Extension Preload 8-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGi: "---"
      - loadcode3: "011"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer8Reg: registerGi }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP8RBBO
    behavior: *behaviorXP8RBBO
  - ID: LSU_XPL16RBB
    what: LSU Extension Preload 16-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGj: "--"
      - loadcode4: "0111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer16Reg: registerGj }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: *propertiesLVBPB
    scheduling: LSU
    execution: *executionXP16RBB
    behavior: *behaviorXP16RBB
  - ID: LSU_XPL16RBB.O
    what: LSU Extension Preload 16-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGj: "--"
      - loadcode4: "0111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer16Reg: registerGj }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.X
    execution: *executionXP16RBBO
    behavior: *behaviorXP16RBBO
  - ID: LSU_XPL16RBB.D
    what: LSU Extension Preload 16-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGj: "--"
      - loadcode4: "0111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer16Reg: registerGj }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP16RBBO
    behavior: *behaviorXP16RBBO
  - ID: LSU_XPL32RBB
    what: LSU Extension Preload 32-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGk: "-"
      - loadcode5: "01111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer32Reg: registerGk }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: *propertiesLVBPB
    scheduling: LSU
    execution: *executionXP32RBB
    behavior: *behaviorXP32RBB
  - ID: LSU_XPL32RBB.O
    what: LSU Extension Preload 32-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGk: "-"
      - loadcode5: "01111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer32Reg: registerGk }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.X
    execution: *executionXP32RBBO
    behavior: *behaviorXP32RBBO
  - ID: LSU_XPL32RBB.D
    what: LSU Extension Preload 32-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGk: "-"
      - loadcode5: "01111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer32Reg: registerGk }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP32RBBO
    behavior: *behaviorXP32RBBO
  - ID: LSU_XPL64RBB
    what: LSU Extension Preload 64-Register Buffer Packed Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGl: "-"
      - loadcode5: "11111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { buffer64Reg: registerGl }, { singleReg: registerY }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1, %2 = [%3]"
    properties: *propertiesLVBPB
    scheduling: LSU
    execution: *executionXP64RBB
    behavior: *behaviorXP64RBB
  - ID: LSU_XPL64RBB.O
    what: LSU Extension Preload 64-Register Buffer Packed Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGl: "-"
      - loadcode5: "11111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: double
    operands: [ { buffer64Reg: registerGl }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed27: offset27 } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.X
    execution: *executionXP64RBBO
    behavior: *behaviorXP64RBBO
  - ID: LSU_XPL64RBB.D
    what: LSU Extension Preload 64-Register Buffer Packed Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: "011"
      - variant: "--"
      - registerGl: "-"
      - loadcode5: "11111"
      - lsucode4: "11"
      - lsucode6: *opcodesXPRB
      - registerY: "------"
      - registerZ: "------"
    encoding: triple
    operands: [ { buffer64Reg: registerGl }, { singleReg: registerY }, { singleReg: registerZ }, variant, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1, %2 = %5[%3]"
    properties: *propertiesLVBPBO
    scheduling: LSU.Y
    execution: *executionXP64RBBO
    behavior: *behaviorXP64RBBO
  - ID: LSU_SSPB
    what: LSU Store Scalar Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: &descriptionSPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesSSPB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSSPB
    behavior: *behaviorSSPB
  - ID: LSU_SSPB.O
    what: LSU Store Scalar Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SSPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: &descriptionSPBO >
      The effective address is given by adding the %5 to the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesSSPBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%5': Offset }
    scheduling: LSU_AUXR.X
    execution: *executionSSPBO
    behavior: *behaviorSSPBO
  - ID: LSU_SSPB.D
    what: LSU Store Scalar Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SSPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSSPBO
    behavior: *behaviorSSPBO
  - ID: LSU_SQPB
    what: LSU Store Quadruple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: *propertiesSSPB
    scheduling: LSU_AUXR
    execution: *executionSSPB
    behavior: *behaviorSSPB
  - ID: LSU_SQPB.O
    what: LSU Store Quadruple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SQPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSSPBO
    scheduling: LSU_AUXR.X
    execution: *executionSSPBO
    behavior: *behaviorSSPBO
  - ID: LSU_SQPB.D
    what: LSU Store Quadruple Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SQPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSSPBO
    behavior: *behaviorSSPBO
  - ID: LSU_SOPB
    what: LSU Store Octuple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: *propertiesSSPB
    scheduling: LSU_AUXR
    execution: *executionSQPB
    behavior: *behaviorSQPB
  - ID: LSU_SOPB.O
    what: LSU Store Octuple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSSPBO
    scheduling: LSU_AUXR.X
    execution: *executionSQPBO
    behavior: *behaviorSQPBO
  - ID: LSU_SOPB.D
    what: LSU Store Octuple Predicated Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSQPBO
    behavior: *behaviorSQPBO
  - ID: LSU_SOMB
    what: LSU Store Octuple Masked Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, lsomask ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: &propertiesSQMB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSQMB
    behavior: *behaviorSQMB
  - ID: LSU_SOMB.O
    what: LSU Store Octuple Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOMB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, lsomask, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: &propertiesSQMBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%5': Offset }
    scheduling: LSU_AUXR.X
    execution: *executionSQMBO
    behavior: *behaviorSQPMO
  - ID: LSU_SOMB.D
    what: LSU Store Octuple Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsomask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOMB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, lsomask, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSQMBO
    scheduling: LSU_AUXR.Y
    execution: *executionSQMBO
    behavior: *behaviorSQPMO
  - ID: LSU_XSOMB
    what: LSU Extension Store Octuple Masked Base
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, lsumask ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: &propertiesSVMB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVMB
    behavior: *behaviorSVMB
  - ID: LSU_XSOMB.O
    what: LSU Extension Store Octuple Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOMB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, lsumask, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: &propertiesSVMBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%5': Offset, '%CS': NoEffects }
    scheduling: LSU_CRRP.X
    execution: *executionSVMBO
    behavior: *behaviorSVPMO
  - ID: LSU_XSOMB.D
    what: LSU Extension Store Octuple Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOMB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, lsumask, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSVMBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVMBO
    behavior: *behaviorSVPMO
  - ID: LSU_XSOC2MB
    what: LSU Extension Store Octuple Cross 2 Masked Base
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordxReg: registerEp }, lsumask, hindex ]
    syntax: "%0%5%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: &propertiesSVPMB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVPMB
    behavior: *behaviorSVPMB
  - ID: LSU_XSOC2MB.O
    what: LSU Extension Store Octuple Cross 2 Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOC2MB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordxReg: registerEp }, lsumask, hindex, { signed27: offset27 } ]
    syntax: "%0%5%4 %1? %6[%2] = %3"
    description: *descriptionSPBO
    properties: &propertiesSVPMBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%6': Offset, '%CS': NoEffects }
    scheduling: LSU_CRRP.X
    execution: *executionSVPMBO
    behavior: *behaviorSVPMBO
  - ID: LSU_XSOC2MB.D
    what: LSU Extension Store Octuple Cross 2 Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOC2MB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordxReg: registerEp }, lsumask, hindex, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %1? %6[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSVPMBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVPMBO
    behavior: *behaviorSVPMBO
  - ID: LSU_XSOC4MB
    what: LSU Extension Store Octuple Cross 4 Masked Base
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordvReg: registerEq }, lsumask, qindex ]
    syntax: "%0%5%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: &propertiesSVQMB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVQMB
    behavior: *behaviorSVQMB
  - ID: LSU_XSOC4MB.O
    what: LSU Extension Store Octuple Cross 4 Masked Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOC4MB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordvReg: registerEq }, lsumask, qindex, { signed27: offset27 } ]
    syntax: "%0%5%4 %1? %6[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSVQMBO
    scheduling: LSU_CRRP.X
    execution: *executionSVQMBO
    behavior: *behaviorSVQMBO
  - ID: LSU_XSOC4MB.D
    what: LSU Extension Store Octuple Cross 4 Masked Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsumask: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSOC4MB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordvReg: registerEq }, lsumask, qindex, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %1? %6[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSVQMBO
    scheduling: LSU_CRRP.Y
    execution: *executionSVQMBO
    behavior: *behaviorSVQMBO
  - ID: LSU_ALSB
    what: LSU Atomic Load Scalar Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode6: &memoryatomicS { "[ ALW, ALD, ALCLRW, ALCLRD ]": "0000..0011" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, coherency ]
    syntax: "%0%3 %1 = [%2]"
    description: *descriptionLSBO
    properties: { '%0': MemoryEffect, '%1': Loaded, '%2': Base }
    scheduling: LSU_AUXW
    execution: *executionLBOA
    behavior: *behaviorLBOA
  - ID: LSU_ALSB.O
    what: LSU Atomic Load Scalar Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode6: *memoryatomicS
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ALSB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, coherency, { signed27: offset27 } ]
    syntax: "%0%3 %1 = %4[%2]"
    description: *descriptionLSBO
    properties: *propertiesASBO
    scheduling: LSU_AUXW.X
    execution: *executionASBO
    behavior: *behaviorASBO
  - ID: LSU_ALSB.D
    what: LSU Atomic Load Scalar Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode6: *memoryatomicS
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ALSB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, coherency, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%3 %1 = %4[%2]"
    description: *descriptionLSBO
    properties: *propertiesASBO
    scheduling: LSU_AUXW.Y
    execution: *executionASBO
    behavior: *behaviorASBO
  - ID: LSU_ASSB
    what: LSU Atomic Store Scalar Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: { "[ ASW, ASD ]": "0100..0101" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency ]
    syntax: "%0%3 [%1] = %2"
    description: *descriptionSBO
    properties: { '%0': MemoryWrite, '%1': Base, '%2': Stored }
    scheduling: LSU_AUXR
    execution: *executionAWB
    behavior: *behaviorAWB
  - ID: LSU_ASSB.O
    what: LSU Atomic Store Scalar Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: { "[ ASW, ASD ]": "0100..0101" }
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ASSB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency, { signed27: offset27 } ]
    syntax: "%0%3 %4[%1] = %2"
    description: *descriptionSBO
    properties: *propertiesAWBO
    scheduling: LSU_AUXR.X
    execution: *executionAWBO
    behavior: *behaviorAWBO
  - ID: LSU_ASSB.D
    what: LSU Atomic Store Scalar Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: { "[ ASW, ASD ]": "0100..0101" }
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ASSB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%3 %4[%1] = %2"
    description: *descriptionSBO
    properties: *propertiesAWBO
    scheduling: LSU_AUXR.Y
    execution: *executionAWBO
    behavior: *behaviorAWBO
  - ID: LSU_ALADDSB
    what: LSU Atomic Load Add Scalar Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: &memoryatomicA { "[ ALADDW, ALADDD ]": "0110..0111" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency ]
    syntax: "%0%3 [%1] = %2"
    description: *descriptionSBO
    properties: { '%0': MemoryEffect, '%1': Base, '%2': Loaded }
    scheduling: LSU_AUXR_AUXW
    execution: *executionAAB
    behavior: *behaviorAAB
  - ID: LSU_ALADDSB.O
    what: LSU Atomic Load Add Scalar Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: *memoryatomicA
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ALADDSB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency, { signed27: offset27 } ]
    syntax: "%0%3 %4[%1] = %2"
    description: *descriptionSBO
    properties: *propertiesAABO
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionAABO
    behavior: *behaviorAABO
  - ID: LSU_ALADDSB.D
    what: LSU Atomic Load Add Scalar Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerT: "------"
      - lsucode4: "11"
      - lsucode6: *memoryatomicA
      - registerY: "______"
      - registerZ: "------"
    samefields: { LSU_ALADDSB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerZ }, { singleReg: registerT }, coherency, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%3 %4[%1] = %2"
    description: *descriptionSBO
    properties: *propertiesAABO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionAABO
    behavior: *behaviorAABO
  - ID: LSU_ACSWAPSB
    what: LSU Atomic Compare and Swap Scalar Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode5: &memoryatomicRP { "[ ACSWAPW, ACSWAPD ]": "100..101" }
      - boolcas: "-"
      - registerO: "-----"
      - exubit6: "_"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { pairedReg: registerO }, coherency, boolcas ]
    syntax: "%0%5%4 %1, [%2] = %3"
    description: &descriptionARPB >
      The effective address is read from the %2.
    properties: &propertiesARPB { '%0': MemoryEffect, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR_AUXW
    execution: *executionARPB
    behavior: *behaviorARPB
  - ID: LSU_ACSWAPSB.O
    what: LSU Atomic Compare and Swap Scalar Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode5: *memoryatomicRP
      - boolcas: "-"
      - registerO: "-----"
      - exubit6: "_"
      - registerZ: "------"
    samefields: { LSU_ACSWAPSB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { pairedReg: registerO }, coherency, boolcas, { signed27: offset27 } ]
    syntax: "%0%5%4 %1, %6[%2] = %3"
    description: &descriptionARPBO >
      The effective address is computed by adding %6 to the %2.
    properties: &propertiesARPBO { '%0': MemoryEffect, '%2': Base, '%6': Offset, '%3': Stored }
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionARPBO
    behavior: *behaviorARPBO
  - ID: LSU_ACSWAPSB.D
    what: LSU Atomic Compare and Swap Scala Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerW: "------"
      - lsucode4: "11"
      - lsucode5: *memoryatomicRP
      - boolcas: "-"
      - registerO: "-----"
      - exubit6: "_"
      - registerZ: "------"
    samefields: { LSU_ACSWAPSB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { pairedReg: registerO }, coherency, boolcas, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %1, %6[%2] = %3"
    description: *descriptionARPBO
    properties: *propertiesARPBO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionARPBO
    behavior: *behaviorARPBO
  - ID: LSU_ACSWAPQB
    what: LSU Atomic Compare and Swap Quadruple Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: &memoryatomicRQ { ACSWAPQ: "110" }
      - boolcas: "-"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { quadReg: registerQ }, coherency, boolcas ]
    syntax: "%0%5%4 %1, [%2] = %3"
    description: *descriptionARPB
    properties: *propertiesARPB
    scheduling: LSU_AUXR_AUXW
    execution: *executionARPB
    behavior: *behaviorARPB
  - ID: LSU_ACSWAPQB.O
    what: LSU Atomic Compare and Swap Quadruple Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: *memoryatomicRQ
      - boolcas: "-"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerZ: "------"
    samefields: { LSU_ACSWAPQB: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { quadReg: registerQ }, coherency, boolcas, { signed27: offset27 } ]
    syntax: "%0%5%4 %1, %6[%2] = %3"
    description: *descriptionARPBO
    properties: *propertiesARPBO
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionARPBO
    behavior: *behaviorARPBO
  - ID: LSU_ACSWAPQB.D
    what: LSU Atomic Compare and Swap Quadruple Base Double Offset
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - coherency: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: *memoryatomicRQ
      - boolcas: "-"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerZ: "------"
    samefields: { LSU_ACSWAPQB: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { quadReg: registerQ }, coherency, boolcas, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%5%4 %1, %6[%2] = %3"
    description: *descriptionARPBO
    properties: *propertiesARPBO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionARPBO
    behavior: *behaviorARPBO
  - ID: LSU_XLBI
    what: LSU Extension Load Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "000"
      - variant: "--"
      - registerG: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLSBI
    properties: &propertiesLVBI { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLVBI
    behavior: *behaviorLVBI
  - ID: LSU_XLOC2BI
    what: LSU Extension Load Octuple Cross 2 Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "001"
      - variant: "--"
      - registerGp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordxReg: registerGp }, { singleReg: registerY }, { singleReg: registerZ }, hindex, doscale, variant ]
    syntax: "%0%6%5%4 %1 = %2[%3]"
    description: *descriptionLSBI
    properties: *propertiesLVBI
    scheduling: LSU
    execution: *executionLVPBI
    behavior: *behaviorLVPBI
  - ID: LSU_XLOC4BI
    what: LSU Extension Load Octuple Cross 4 Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XLO: "01" }
      - loadcode: "010"
      - variant: "--"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, qindex, doscale, variant ]
    syntax: "%0%6%5%4 %1 = %2[%3]"
    description: *descriptionLSBI
    properties: *propertiesLVBI
    scheduling: LSU
    execution: *executionLVQBI
    behavior: *behaviorLVQBI
  - ID: LSU_SSBI
    what: LSU Store Scalar Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: &descriptionSSBI >
      The effective address is computed by adding the %2 to the %1 and scaled by the %4.
    properties: &propertiesSSBI { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSSBI
    behavior: *behaviorSSBI
  - ID: LSU_SQBI
    what: LSU Store Quadruple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SQ: "10100" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSSBI
    properties: *propertiesSSBI
    scheduling: LSU_AUXR
    execution: *executionSSBI
    behavior: *behaviorSSBI
  - ID: LSU_SOBI
    what: LSU Store Octuple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: { SO: "10100" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSSBI
    properties: *propertiesSSBI
    scheduling: LSU_AUXR
    execution: *executionSQBI
    behavior: *behaviorSQBI
  - ID: LSU_XSOBI
    what: LSU Extension Store Octuple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10101"
      - registerE: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSSBI
    properties: &propertiesSVBI { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVBI
    behavior: *behaviorSVBI
  - ID: LSU_XSOC2BI
    what: LSU Extension Store Quadruple Cross 2 Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10110"
      - registerEp: "-----"
      - hindex: "-"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordxReg: registerEp }, doscale, hindex ]
    syntax: "%0%5%4 %1[%2] = %3"
    description: *descriptionSSBI
    properties: &propertiesSVPBI { '%0': MemoryWrite, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVPBI
    behavior: *behaviorSVPBI
  - ID: LSU_XSOC4BI
    what: LSU Extension Store Octuple Cross 4 Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: { XSO: "01" }
      - lsucode0: "10111"
      - registerEq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordvReg: registerEq }, doscale, qindex ]
    syntax: "%0%5%4 %1[%2] = %3"
    description: *descriptionSSBI
    properties: &propertiesSVQBI { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSVQBI
    behavior: *behaviorSVQBI
  ## ALU: steering=11
  - ID: ALU_MAKE
    what: ALU Make from Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - signed16: "----------------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed16 ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_MAKE.X
    what: ALU Make from Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - extend6: "------"
    samefields: { ALU_MAKE: 16..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed43: [ extend6, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY.X
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_MAKE.Y
    what: ALU Make from Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - unused6: "______"
    samefields: { ALU_MAKE: 16..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY.Y
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_DWRI
    what: ALU Write Read Double Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRI.X
    what: ALU Write Read Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRI.Y
    what: ALU Write Read Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_CWRI
    what: ALU Compare Write Read Immediate
    fields:
      - parallel: "-"
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CWRI.X
    what: ALU Compare Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_CWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CWRI.Y
    what: ALU Compare Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_CWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_XSDOI
    what: ALU Extension Splat Double To Octuple Word Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { XSPLATDO: "1110" }
      - registerA: "------"
      - exucode4: "01"
      - signed16: "----------------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, signed16 ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWL_CRWH
    execution: *executionXWI
    behavior: *behaviorXWI
  - ID: ALU_XSDOI.X
    what: ALU Extension Splat Double To Octuple Word Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { XSPLATDO: "1110" }
      - registerA: "------"
      - exucode4: "01"
      - lower10: "----------"
      - extend6: "------"
    samefields: { ALU_XSDOI: 16..31 }
    encoding: double
    operands: [ { xwordoReg: registerA }, { signed43: [ extend6, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWL_CRWH.X
    execution: *executionXWI
    behavior: *behaviorXWI
  - ID: ALU_XSDOI.Y
    what: ALU Extension Splat Double To Octuple Word Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { XSPLATDO: "1110" }
      - registerA: "------"
      - exucode4: "01"
      - lower10: "----------"
      - unused6: "______"
    samefields: { ALU_XSDOI: 16..31 }
    encoding: triple
    operands: [ { xwordoReg: registerA }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWL_CRWH.Y
    execution: *executionXWI
    behavior: *behaviorXWI
  - ID: ALU_DCMWRI
    what: ALU Double Conditional Move Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DCMWRI.X
    what: ALU Double Conditional Move Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DCMWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY.X
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DCMWRI.Y
    what: ALU Double Conditional Move Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DCMWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY.Y
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DBMWRI
    what: ALU Bit Matrix Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DBMWRI.X
    what: ALU Bit Matrix Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DBMWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DBMWRI.Y
    what: ALU Bit Matrix Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DBMWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WRB
    what: ALU Write Read Bitmask
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - wricode1: { "[ INSF, EXTFZ, EXTFS, CLRF ]": "00..11" }
      - stopbit2: "--"
      - registerW: "------"
      - exucode4: "11"
      - stopbit4: "----"
      - startbit: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { unsigned6: [ stopbit2, stopbit4 ] }, { unsigned6: startbit } ]
    syntax: "%0 %1 = %2, %3, %4"
    scheduling: ALU_TINY
    execution: |
      stage ID:
      new startbit = %4;
      new stopbit = %3;
      new bias = startbit <= stopbit;
      new mask = _ZX_64((2 << stopbit) - ((2 - bias) << startbit) + bias - 1);
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.startbit (ACCESS.ID.%4))
        (WRITE.stopbit (ACCESS.ID.%3))
        (WRITE.bias
          (B2I
            (LE
              (READ.startbit)
              (READ.stopbit))))
        (WRITE.mask
          (ZX.64
            (ADD
              (SUB
                (SHL
                  (CONST.2)
                  (READ.stopbit))
                (SHL
                  (SUB
                    (CONST.2)
                    (READ.bias))
                  (READ.startbit)))
              (SUB
                (READ.bias)
                (CONST.1)))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: ALU_PCREL
    what: ALU Add PC to Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - signed16: "----------------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed16 ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_PCREL.X
    what: ALU Add PC to Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - extend6: "------"
    samefields: { ALU_PCREL: 16..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed43: [ extend6, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL.X
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_PCREL.Y
    what: ALU Add PC to Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - unused6: "______"
    samefields: { ALU_PCREL: 16..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL.Y
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_WRIW
    what: ALU Write Read Immediate Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDW, ADDW, SBFW, MINW, MAXW, MINUW, MAXUW ]": "0001..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WRIW.X
    what: ALU Write Read Immediate Extended Word
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDW, ADDW, SBFW, MINW, MAXW, MINUW, MAXUW ]": "0001..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_WRIW: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_DWRR
    what: ALU Double Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSD, ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD ]": "0000..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDX32D, SBFX32D, ADDX64D, SBFX64D ]": "0000..1011", "[ ADDSD, SBFSD, ADDUSD, SBFUSD ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ ABDSD, ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "0000", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDX32D, SBFX32D, ADDX64D, SBFX64D, ADDSD, SBFSD, ADDUSD, SBFUSD ]": "0100" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRR.M
    what: ALU Double Write Read Read Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSD, ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD ]": "0000..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDX32D, SBFX32D, ADDX64D, SBFX64D ]": "0000..1011", "[ ADDSD, SBFSD, ADDUSD, SBFUSD ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ ABDSD, ABDD, ADDD, SBFD, MIND, MAXD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "0000", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDX32D, SBFX32D, ADDX64D, SBFX64D, ADDSD, SBFSD, ADDUSD, SBFUSD ]": "0100" }
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WWRR0
    what: ALU Word Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSW, ABDW, ADDW, SBFW, MINW, MAXW, MINUW, MAXUW ]": "0000..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WWRR0.W
    what: ALU Word Write Read Read 0 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { ABDSW: "0000" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0001"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WWRR0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPWRR0
    what: ALU Word Pair Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSWP, ABDWP, ADDWP, SBFWP, MINWP, MAXWP, MINUWP, MAXUWP ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPWRR0.M
    what: ALU Word Pair Write Read Read 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSWP, ABDWP, ADDWP, SBFWP, MINWP, MAXWP, MINUWP, MAXUWP ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0010"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPWRR0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQWRR0
    what: ALU Half Quadruple Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSHQ, ABDHQ, ADDHQ, SBFHQ, MINHQ, MAXHQ, MINUHQ, MAXUHQ ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQWRR0.M
    what: ALU Half Quadruple Write Read Read 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ABDSHQ, ABDHQ, ADDHQ, SBFHQ, MINHQ, MAXHQ, MINUHQ, MAXUHQ ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0011"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_HQWRR0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WWRR1
    what: ALU Word Write Read Read 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2W, SBFX2W, ADDX4W, SBFX4W, ADDX8W, SBFX8W, ADDX16W, SBFX16W, ADDX32W, SBFX32W, ADDX64W, SBFX64W ]": "0000..1011", "[ ADDSW, SBFSW, ADDUSW, SBFUSW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0101"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WWRR1.W
    what: ALU Word Write Read Read 1 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2W, SBFX2W, ADDX4W, SBFX4W, ADDX8W, SBFX8W, ADDX16W, SBFX16W, ADDX32W, SBFX32W, ADDX64W, SBFX64W ]": "0000..1011", "[ ADDSW, SBFSW, ADDUSW, SBFUSW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0101"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPWRR1
    what: ALU Word Pair Write Read Read 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WP, SBFX2WP, ADDX4WP, SBFX4WP, ADDX8WP, SBFX8WP, ADDX16WP, SBFX16WP ]": "0000..0111", "[ ADDSWP, SBFSWP, ADDUSWP, SBFUSWP ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPWRR1.M
    what: ALU Word Pair Write Read Read 1 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WP, SBFX2WP, ADDX4WP, SBFX4WP, ADDX8WP, SBFX8WP, ADDX16WP, SBFX16WP ]": "0000..0111", "[ ADDSWP, SBFSWP, ADDUSWP, SBFUSWP ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQWRR1
    what: ALU Write Read Read Half Word Quadruple 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2HQ, SBFX2HQ, ADDX4HQ, SBFX4HQ, ADDX8HQ, SBFX8HQ, ADDX16HQ, SBFX16HQ ]": "0000..0111", "[ ADDSHQ, SBFSHQ, ADDUSHQ, SBFUSHQ ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQWRR1.M
    what: ALU Half Quadruple Write Read Read 1 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2HQ, SBFX2HQ, ADDX4HQ, SBFX4HQ, ADDX8HQ, SBFX8HQ, ADDX16HQ, SBFX16HQ ]": "0000..0111", "[ ADDSHQ, SBFSHQ, ADDUSHQ, SBFUSHQ ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_HQWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WDWRR2
    what: ALU Word to Double Write Read Read 2
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WD, SBFX2WD, ADDX4WD, SBFX4WD, ADDX8WD, SBFX8WD, ADDX16WD, SBFX16WD, ADDX32WD, SBFX32WD, ADDX64WD, SBFX64WD ]": "0000..1011", "[ ADDWD, SBFWD ]": "1100..1101", "[ ADDCD, SBFCD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WDWRR2.W
    what: ALU Word to Double Write Read Read 2 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WD, SBFX2WD, ADDX4WD, SBFX4WD, ADDX8WD, SBFX8WD, ADDX16WD, SBFX16WD, ADDX32WD, SBFX32WD, ADDX64WD, SBFX64WD ]": "0000..1011", "[ ADDWD, SBFWD ]": "1100..1101", "[ ADDCD, SBFCD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1000"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WDWRR2: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WDWRR3
    what: ALU Word to Double Write Read Read 3
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2UWD, SBFX2UWD, ADDX4UWD, SBFX4UWD, ADDX8UWD, SBFX8UWD, ADDX16UWD, SBFX16UWD, ADDX32UWD, SBFX32UWD, ADDX64UWD, SBFX64UWD ]": "0000..1011", "[ ADDUWD, SBFUWD ]": "1100..1101", "[ ADDCD.I, SBFCD.I ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WDWRR3.W
    what: ALU Word to Double Write Read Read 2 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2UWD, SBFX2UWD, ADDX4UWD, SBFX4UWD, ADDX8UWD, SBFX8UWD, ADDX16UWD, SBFX16UWD, ADDX32UWD, SBFX32UWD, ADDX64UWD, SBFX64UWD ]": "0000..1011", "[ ADDUWD, SBFUWD ]": "1100..1101", "[ ADDCD.I, SBFCD.I ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1001"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WDWRR3: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_CWRR
    what: ALU Double Comparison Write Read Read
    fields:
      - parallel: "-"
      - steering: { COMPD: "11" }
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_DWRRS
    what: ALU Double Write Read Read Special
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUD, ABDUD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRRS.M
    what: ALU Double Write Read Read Special Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUD, ABDUD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1010"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_DCWRR
    what: ALU Double Comparison Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ COMPW, COMPWD, COMPUWD ]": "1011..1101" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_DCWRR.W
    what: ALU Double Comparison Write Read Read Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ COMPW, COMPWD, COMPUWD ]": "1011..1101" }
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DCWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WRRSW
    what: ALU Write Read Read Special Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUW, ABDUW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WRRSW.W
    what: ALU Write Read Read Special Word Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUW, ABDUW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPCNWRR
    what: ALU Comparison Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNWP: "01" }
      - exucode5: "1110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPCNWRR.M
    what: ALU Comparison Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNWP: "01" }
      - exucode5: "1110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_WPWRRS
    what: ALU Write Read Read Special Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUWP, ABDUWP ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPWRRS.M
    what: ALU Write Read Read Special Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUWP, ABDUWP ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQCWRR
    what: ALU Comparison Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNHQ: "01" }
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_HQCWRR.M
    what: ALU Comparison Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNHQ: "01" }
      - exucode5: "1111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_HQWRRS
    what: ALU Write Read Read Special Half Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUHQ, ABDUHQ ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQWRRS.M
    what: ALU Write Read Read Special Half Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUHQ, ABDUHQ ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_DCMWRR
    what: ALU Double Conditional Move Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_BWRR
    what: ALU Bit Matrix Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BWRR.M
    what: ALU Bit Matrix Write Read Read Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_BWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WPCMWRR
    what: ALU Move Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEWP: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, simdcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_WPCMWRR.M
    what: ALU Move Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEWP: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPCMWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, simdcond, splat32 ]
    syntax: "%0%4 %2? %1 = %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCMWRRM
    behavior: *behaviorCMWRRM
  - ID: ALU_CMWRRHQ
    what: ALU Move Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEHQ: "1" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, simdcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_CMWRRHQ.M
    what: ALU Move Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEHQ: "1" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_CMWRRHQ: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, simdcond, splat32 ]
    syntax: "%0%4 %2? %1 = %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCMWRRM
    behavior: *behaviorCMWRRM
  - ID: ALU_BWRD
    what: ALU Bit Write Read Double
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZD, CLSD, CBSD, CTZD ]": "0000..0011", CMASK32D: "0100" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0010"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_DSWRI
    what: ALU Double Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSD, SLLD, SRAD, SRLD, SLSD, SLUSD ]": "1000..1101", "[ ROLD, RORD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0010"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BWRW
    what: ALU Bit Write Read Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZW, CLSW, CBSW, CTZW ]": "0000..0011", CMASK32W: "0100" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0011"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionWZWR
    behavior: *behaviorWZWR
  - ID: ALU_WSWRI
    what: ALU Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSW, SLLW, SRAW, SRLW, SLSW, SLUSW ]": "1000..1101", "[ ROLW, RORW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0011"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_BWRWP
    what: ALU Bit Write Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZWP, CLSWP, CBSWP, CTZWP ]": "0000..0011", "[ ZXLHWP, ZXMHWP, SXLHWP, SXMHWP ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0100"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_WPSWRI
    what: ALU Word Pair Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSWPS, SLLWPS, SRAWPS, SRLWPS, SLSWPS, SLUSWPS ]": "1000..1101", "[ ROLWPS, RORWPS ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0100"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_LWRHQ
    what: ALU Arithmetic Write Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ZXLBHQ, ZXMBHQ, SXLBHQ, SXMBHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0101"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_HQSWRI
    what: ALU Shift Rotate Write Read Immediate Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSHQS, SLLHQS, SRAHQS, SRLHQS, SLSHQS, SLUSHQS ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0101"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DSWRR
    what: ALU Double Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ LANDD, LNANDD, LIORD, LNIORD ]": "0000..0011", "[ AVGD, AVGRD, AVGUD, AVGRUD ]": "0100..0111", "[ SRSD, SLLD, SRAD, SRLD, SLSD, SLUSD ]": "1000..1101", "[ ROLD, RORD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WSWRR
    what: ALU Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ LANDW, LNANDW, LIORW, LNIORW ]": "0000..0011", "[ AVGW, AVGRW, AVGUW, AVGRUW ]": "0100..0111", "[ SRSW, SLLW, SRAW, SRLW, SLSW, SLUSW ]": "1000..1101", "[ ROLW, RORW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WSWRR.W
    what: ALU Double Write Read Read 1 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ LANDW, LNANDW, LIORW, LNIORW ]": "0000..0011", "[ AVGW, AVGRW, AVGUW, AVGRUW ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0111"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WSWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPSWRR
    what: ALU Word Pair Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGWP, AVGRWP, AVGUWP, AVGRUWP ]": "0100..0111", "[ SRSWPS, SLLWPS, SRAWPS, SRLWPS, SLSWPS, SLUSWPS ]": "1000..1101", "[ ROLWPS, RORWPS ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPSWRR.M
    what: ALU Word Pair Shift Rotate Write Read Read Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGWP, AVGRWP, AVGUWP, AVGRUWP ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPSWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQSWRR
    what: ALU Shift Rotate Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGHQ, AVGRHQ, AVGUHQ, AVGRUHQ ]": "0100..0111", "[ SRSHQS, SLLHQS, SRAHQS, SRLHQS, SLSHQS, SLUSHQS ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQSWRR.M
    what: ALU Shift Rotate Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGHQ, AVGRHQ, AVGUHQ, AVGRUHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_HQSWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_BOWRR0
    what: ALU Write Read Read Byte Octuple 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDBO, SBFBO, ABDBO, ABDSBO, MINBO, MAXBO, MINUBO, MAXUBO ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BOWRR0.M
    what: ALU Write Read Read Byte Octuple 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDBO, SBFBO, ABDBO, ABDSBO, MINBO, MAXBO, MINUBO, MAXUBO ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1010"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_BOWRR1
    what: ALU Write Read Read Byte Octuple 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2BO, SBFX2BO, ADDX4BO, SBFX4BO, ADDX8BO, SBFX8BO, ADDX16BO, SBFX16BO ]": "0000..0111", "[ ADDSBO, SBFSBO, ADDUSBO, SBFUSBO ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BOWRR1.M
    what: ALU Write Read Read Byte Octuple 1 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2BO, SBFX2BO, ADDX4BO, SBFX4BO, ADDX8BO, SBFX8BO, ADDX16BO, SBFX16BO ]": "0000..0111", "[ ADDSBO, SBFSBO, ADDUSBO, SBFUSBO ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1011"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_BOCNWRR
    what: ALU Comparison Write Read Read Byte Octuple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNBO: "10" }
      - exucode5: "1100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_BOCNWRR.M
    what: ALU Comparison Write Read Read Byte Octuple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNBO: "10" }
      - exucode5: "1100"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_BOWRRS
    what: ALU Write Read Read Special Byte Octuple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { ABDUBO: "1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BOWRRS.M
    what: ALU Write Read Read Special Byte Octuple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { ABDUBO: "1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1100"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_BOCMWRR
    what: ALU Conditional Move Write Read Read Byte Octuple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEBO: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1101"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, simdcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_TINY
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_BOCMWRR.M
    what: ALU Move Write Read Read Byte Octuple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEBO: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1101"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_BOCMWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, simdcond, splat32 ]
    syntax: "%0%4 %2? %1 = %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCMWRRM
    behavior: *behaviorCMWRRM
  - ID: ALU_BOSWRI
    what: ALU Shift Rotate Write Read Immediate Byte Octuple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSBOS, SLLBOS, SRABOS, SRLBOS, SLSBOS, SLUSBOS ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1110"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BOSWRR
    what: ALU Shift Rotate Write Read Read Byte Octuple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGBO, AVGRBO, AVGUBO, AVGRUBO ]": "0100..0111", "[ SRSBOS, SLLBOS, SRABOS, SRLBOS, SLSBOS, SLUSBOS ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BOSWRR.M
    what: ALU Shift Rotate Write Read Read Byte Octuple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ AVGBO, AVGRBO, AVGUBO, AVGRUBO ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_BOSWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_FCWRRS
    what: ALU Floating-Point Comparison Write Read Read Scalar
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPW, FCOMPD ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_FCWRRS.W
    what: ALU Floating-Point Comparison Write Read Immediate Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPW, FCOMPD ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0000"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_FCWRRS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPFCWRR
    what: ALU Floating-Point Comparison Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNWP: "0" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPFCWRR.M
    what: ALU Floating-Point Comparison Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNWP: "0" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_HQFCWRR
    what: ALU Floating-Point Comparison Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNHQ: "1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_HQFCWRR.M
    what: ALU Floating-Point Comparison Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNHQ: "1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_DFWR
    what: ALU Double Floating-Point Write Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FNEGD, FABSD, FNEGW, FABSW, FNEGWP, FABSWP, FNEGHQ, FABSHQ ]": "0000..0111", FSRSRD: "1000", FSRSRW: "1010", FSRSRWP: "1100" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0010"
      - silent2: "_"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
## [ FRINTD, FROUNDD, FCEILD, FFLOORD, FTRUNCD ]
  - ID: ALU_FWR
    what: ALU Floating-Point Write Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FWIDENLWD, FWIDENMWD, FWIDENLHW, FWIDENMHW, FWIDENLHWP, FWIDENMHWP ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0011"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: |
      stage ID:
      new silent = %3;
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.IO |= finvalid();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: ALU_HQFWR
    what: ALU Floating-Point Write Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FSRECD: "0000", FSRECW: "0010", FSRECWP: "0100" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0100"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRSRD
    behavior: *behaviorWRSRD
  - ID: ALU_DFWRR
    what: ALU Double Floating-Point Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FSDIVD, FCDIVD, FSDIVW, FCDIVW, FSDIVWP, FCDIVWP ]": "0000..0101" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0101"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRSRD
    behavior: *behaviorWRSRD
  - ID: ALU_FWRWLL
    what: ALU Floating-Point Write Read Word Long Latency
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FRECW, FRSRW ]": "0010..0011" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_FULL
    execution: *executionWRSF
    behavior: *behaviorWRSF
  - ID: ALU_FWRW
    what: ALU Floating-Point Write Read Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FNARROWDW: "1000", FNARROWWH: "1010" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRE1
    behavior: *behaviorWRE1
  - ID: ALU_WPFWR
    what: ALU Floating-Point Write Word Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FNARROWDWP: "1100", FNARROWWHQ: "1110" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRE1
    behavior: *behaviorWRE1
  - ID: ALU_DFWRD
    what: ALU Double Floating-Point Write Read Division
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FMIND, FMAXD, FMINW, FMAXW, FMINWP, FMAXWP, FMINHQ, FMAXHQ ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_FCNWRRS
    what: ALU Floating-Point Comparison Negate Write Read Read Scalar
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPNW, FCOMPND ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_FCNWRRS.W
    what: ALU Floating-Point Comparison Negate Write Read Immediate Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPNW, FCOMPND ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1001"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_FCNWRRS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CNWRR
    what: ALU Comparison Negate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: { "[ COMPNW, COMPND ]": "1010..1011" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CNWRR.W
    what: ALU Comparison Negate Write Read Immediate Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: { "[ COMPNW, COMPND ]": "1010..1011" }
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_CNWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPRWRR
    what: ALU Reduce Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ANDRWPD, IORRWPD, EORRWPD ]": "0000..0010", "[ MINRWPD, MAXRWPD, ADDRWPD ]": "0100..0110", "[ MINURWPD, MAXURWPD, ADDURWPD ]": "1000..1010" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1100"
      - silent2: "_"
      - rounding2: "___"
      - exucode7: "00"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_HQRWRR
    what: ALU Word Pair Reduce Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ANDRHQD, IORRHQD, EORRHQD ]": "0000..0010", "[ MINRHQD, MAXRHQD, ADDRHQD ]": "0100..0110", "[ MINURHQD, MAXURHQD, ADDURHQD ]": "1000..1010" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1100"
      - silent2: "_"
      - rounding2: "___"
      - exucode7: "01"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_BORWRR
    what: ALU Word Pair Reduce Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ANDRBOD, IORRBOD, EORRBOD ]": "0000..0010", "[ MINRBOD, MAXRBOD, ADDRBOD ]": "0100..0110", "[ MINURBOD, MAXURBOD, ADDURBOD ]": "1000..1010" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1100"
      - silent2: "_"
      - rounding2: "___"
      - exucode7: "10"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_XMTD0
    what: ALU Move To Extension Double Word 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: "00"
      - qselectA: "00"
      - registerAx: "------"
      - exucode4: "11"
      - exucode5: { XMOVETD: "1110" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { xworddReg0M4: registerAx }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWL
    execution: *executionMOVETD
    behavior: *behaviorMOVETD
  - ID: ALU_XMTD1
    what: ALU Move To Extension Double Word 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: "00"
      - qselectA: "01"
      - registerAy: "------"
      - exucode4: "11"
      - exucode5: { XMOVETD: "1110" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { xworddReg1M4: registerAy }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWL
    execution: *executionMOVETD
    behavior: *behaviorMOVETD
  - ID: ALU_XMTD2
    what: ALU Move To Extension Double Word 2
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: "00"
      - qselectA: "10"
      - registerAz: "------"
      - exucode4: "11"
      - exucode5: { XMOVETD: "1110" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { xworddReg2M4: registerAz }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWH
    execution: *executionMOVETD
    behavior: *behaviorMOVETD
  - ID: ALU_XMTD3
    what: ALU Move To Extension Double Word 3
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: "00"
      - qselectA: "11"
      - registerAt: "------"
      - exucode4: "11"
      - exucode5: { XMOVETD: "1110" }
      - registerY: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { xworddReg3M4: registerAt }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY_CRWH
    execution: *executionMOVETD
    behavior: *behaviorMOVETD
  - ID: ALU_XMTQ0
    what: ALU Move To Extension Quadruple Word 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode9: "010"
      - hselectA: "0"
      - registerAE: "------"
      - exucode4: "11"
      - exucode5: { XMOVETQ: "1110" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordqRegE: registerAE }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY_CRWL
    execution: *executionMOVETQ
    behavior: *behaviorMOVETQ
  - ID: ALU_XMTQ1
    what: ALU Move To Extension Quadruple Word 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode9: "010"
      - hselectA: "1"
      - registerAO: "------"
      - exucode4: "11"
      - exucode5: { XMOVETQ: "1110" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordqRegO: registerAO }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY_CRWH
    execution: *executionMOVETQ
    behavior: *behaviorMOVETQ
  - ID: ALU_CSC
    what: ALU Extension Send Octuple Word to Channel
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode9: { XSENDO: "011" }
      - schannel: "-"
      - registerA: "______"
      - exucode4: "11"
      - exucode5: "1110"
      - registerC: "------"
      - registerZ: "______"
    encoding: simple
    operands: [ { xwordoReg: registerC }, { channel: schannel } ]
    syntax: "%0%2 %1"
    scheduling: ALU_TINY_CRRP
    execution: |
      stage ID:
      new exchange = IXC.SFB;
      new schannel = %2;
      stage RR:
      new argument = %1;
      stage E1:
      CS.XMF = 1;
      stage E4:
      @Instruction
    behavior: |
      (SEQ
        (WRITE.exchange (F2I.1 (LOAD.ID (AGGL.IXC (CONST.IXC_SFB) (CONST.1)))))
        (WRITE.schannel (ACCESS.ID.%2))
        (WRITE.argument (ACCESS.RR.%1))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction))
  - ID: ALU_CRC
    what: ALU Extension Receive Octuple Word from Channel
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: { XRECVO: "10" }
      - rchannel: "-"
      - schannel: "_"
      - registerA: "------"
      - exucode4: "11"
      - exucode5: "1110"
      - registerC: "______"
      - registerZ: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { channel: rchannel } ]
    syntax: "%0%2 %1"
    scheduling: ALU_TINY_CRWL_CRWH
    execution: |
      stage ID:
      new exchange = IXC.SFB;
      new rchannel = %2;
      stage E1:
      CS.XMF = 1;
      stage E2:
      @Instruction
      %1 = result;
    behavior: |
      (SEQ
        (WRITE.exchange (F2I.1 (LOAD.ID (AGGL.IXC (CONST.IXC_SFB) (CONST.1)))))
        (WRITE.rchannel (ACCESS.ID.%2))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result)))
  - ID: ALU_CSRC
    what: ALU Extension Send and Receive Octuple Word to/from Channels
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode8: { XSENDRECVO: "11" }
      - rchannel: "-"
      - schannel: "-"
      - registerA: "------"
      - exucode4: "11"
      - exucode5: "1110"
      - registerC: "------"
      - registerZ: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerC }, { channel: rchannel }, { channel: schannel } ]
    syntax: "%0%4%3 %2, %1"
    scheduling: ALU_TINY_CRRP_CRWL_CRWH
    execution: |
      stage ID:
      new exchange = IXC.SFB;
      new rchannel = %3;
      new schannel = %4;
      stage RR:
      new argument = %2;
      stage E1:
      CS.XMF = 1;
      stage E2:
      @Instruction
      %1 = result;
    behavior: |
      (SEQ
        (WRITE.exchange (F2I.1 (LOAD.ID (AGGL.IXC (CONST.IXC_SFB) (CONST.1)))))
        (WRITE.rchannel (ACCESS.ID.%3))
        (WRITE.schannel (ACCESS.ID.%4))
        (WRITE.argument (ACCESS.RR.%2))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result)))
  - ID: ALU_NOP
    what: ALU No Operation
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { NOP: "1111" }
      - registerW: "______"
      - exucode4: "11"
      - exucode5: "1111"
      - registerY: "______"
      - registerZ: "______"
    encoding: simple
    syntax: "%0"
    scheduling: ALU_NOP
  ## MAU: steering=10
  - ID: MAU_FMAW
    what: MAU Floating-Point Multiply Add Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAW, FFMSW ]": "0000..0001" }
      - registerW: "------"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFMA
    behavior: *behaviorFMA
  - ID: MAU_FMAWP
    what: MAU Floating-Point Multiply Add Word Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAWP, FFMSWP ]": "0010..0011" }
      - registerW: "------"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFMA
    behavior: *behaviorFMA
  - ID: MAU_FMAD
    what: MAU Floating-Point Multiply Add Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAD, FFMSD ]": "0100..0101" }
      - registerW: "------"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFMA
    behavior: *behaviorFMA
  - ID: MAU_FMAWQ
    what: MAU Floating-Point Multiply Add Word Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAWQ, FFMSWQ ]": "0110..0111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFMA
    behavior: *behaviorFMA
  - ID: MAU_FMADP
    what: MAU Floating-Point Multiply Add Double Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMADP, FFMSDP ]": "0110..0111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFMA
    behavior: *behaviorFMA
  - ID: MAU_FMULCW
    what: MAU Floating-Point Multiply Complex Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { FMULWC: "100" }
      - conjugate: "-"
      - registerW: "------"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFMULC
    behavior: *behaviorFMULC
  - ID: MAU_FMULWCP
    what: MAU Floating-Point Multiply Word Complex Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { FMULWCP: "101" }
      - conjugate: "-"
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFMULC
    behavior: *behaviorFMULC
  - ID: MAU_FMULCD
    what: MAU Floating-Point Multiply Complex Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { FMULDC: "101" }
      - conjugate: "-"
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFMULC
    behavior: *behaviorFMULC
  - ID: MAU_FMMW
    what: MAU Floating-Point Matrix Multiply Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { FMM212W: "1100" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding == 7 ? CS.RM : rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: MAU_FMMAW
    what: MAU Floating-Point Matrix Multiply Add Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMMA212W, FMMS212W ]": "1110..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding == 7 ? CS.RM : rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: MAU_FMMWP
    what: MAU Floating-Point Matrix Multiply Word Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { FMM222W: "1100" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - multransm: "-"
      - registerP: "-----"
      - multransl: "-"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, { transpose: [ multransm, multransl ] }, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: |
      stage ID:
      new silent = %6;
      new rounding = %5;
      new transpose = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding == 7 ? CS.RM : rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%6))
        (WRITE.rounding (ACCESS.ID.%5))
        (WRITE.transpose (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: MAU_FMMAWP
    what: MAU Floating-Point Matrix Multiply Add Word Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMMA222W, FMMS222W ]": "1110..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - multransm: "-"
      - registerP: "-----"
      - multransl: "-"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, { transpose: [ multransm, multransl ] }, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: |
      stage ID:
      new silent = %6;
      new rounding = %5;
      new transpose = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding == 7 ? CS.RM : rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%6))
        (WRITE.rounding (ACCESS.ID.%5))
        (WRITE.transpose (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: MAU_FDMAW
    what: MAU Floating-Point Dual Multiply Add Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMAW, FFDMSW ]": "0000..0001" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDMA
    behavior: *behaviorFDMA
  - ID: MAU_FDMAWP
    what: MAU Floating-Point Dual Multiply Add Word Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMAWP, FFDMSWP ]": "0010..0011" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDMA
    behavior: *behaviorFDMA
  - ID: MAU_FDMAD
    what: MAU Floating-Point Dual Multiply Add Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMAD, FFDMSD ]": "0100..0101" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDMA
    behavior: *behaviorFDMA
  - ID: MAU_FDMAWQ
    what: MAU Floating-Point Dual Multiply Add Word Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMAWQ, FFDMSWQ ]": "0110..0111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { quadReg: registerR }, { quadReg: registerQ }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDMA
    behavior: *behaviorFDMA
  - ID: MAU_FDMADP
    what: MAU Floating-Point Dual Multiply Add Double Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMADP, FFDMSDP ]": "0110..0111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { quadReg: registerR }, { quadReg: registerQ }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDMA
    behavior: *behaviorFDMA
  - ID: MAU_FMAWC
    what: MAU Floating-Point Multiply Add Word Complex
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { "[ FFMAWC, FFMSWC ]": "100..101" }
      - conjugate: "-"
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFFMAC
    behavior: *behaviorFFMAC
  - ID: MAU_FMAWCP
    what: MAU Floating-Point Multiply Add Word Complex Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { "[ FFMAWCP, FFMSWCP ]": "110..111" }
      - conjugate: "-"
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFFMAC
    behavior: *behaviorFFMAC
  - ID: MAU_FMACD
    what: MAU Floating-Point Multiply Add Complex Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode3: { "[ FFMADC, FFMSDC ]": "110..111" }
      - conjugate: "-"
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, conjugate, rounding, silent ]
    syntax: "%0%4%5%6 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFFMAC
    behavior: *behaviorFFMAC
  - ID: MAU_FDMDAW
    what: MAU Floating-Point Dual Multiply Dual Add Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMDAW, FFDMSAW, FFDMDSW, FFDMASW ]": "0000..0011" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDMDA
    behavior: *behaviorFDMDA
  - ID: MAU_FDMDAWP
    what: MAU Floating-Point Dual Multiply Dual Add Word Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMDAWP, FFDMSAWP, FFDMDSWP, FFDMASWP ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDMDA
    behavior: *behaviorFDMDA
  - ID: MAU_FDMDAD
    what: MAU Floating-Point Dual Multiply Dual Add Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMDAD, FFDMSAD, FFDMDSD, FFDMASD ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDMDA
    behavior: *behaviorFDMDA
  - ID: MAU_FDMDAWQ
    what: MAU Floating-Point Dual Multiply Dual Add Word Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMDAWQ, FFDMSAWQ, FFDMDSWQ, FFDMASWQ ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { quadReg: registerR }, { quadReg: registerQ }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDMDA
    behavior: *behaviorFDMDA
  - ID: MAU_FDMDADP
    what: MAU Floating-Point Dual Multiply Dual Add Double Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFDMDADP, FFDMSADP, FFDMDSD, FFDMASDP ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerQ: "----"
      - exubit7: "_"
      - exubit6: "_"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { quadReg: registerR }, { quadReg: registerQ }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDMDA
    behavior: *behaviorFDMDA
  - ID: MAU_FDD
    what: MAU Floating-Point Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FLOATD, FLOATUD, FIXEDD, FIXEDUD ]": "0100..0111", "[ FLOATW, FLOATUW, FIXEDW, FIXEDUW ]": "1000..1011", "[ FLOATWP, FLOATUWP, FIXEDWP, FIXEDUWP ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDE4
    behavior: *behaviorFDDE4
  - ID: MAU_DDDD0
    what: MAU Double Double Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010", "[ MSBFD, MSBFWP, MSBFHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DDDD0.M
    what: MAU Double Double Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010", "[ MSBFD, MSBFWP, MSBFHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_DDDD0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1M
    behavior: *behaviorDW2RRR1M
  - ID: MAU_QQDD
    what: MAU Quadruple Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWDP, MADDUWDP, MADDSUWDP, MMA212W ]": "1000..1011", "[ MSBFWDP, MSBFUWDP, MSBFSUWDP, MMS212W ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQDD.M
    what: MAU Quadruple Quadruple Double Double Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWDP, MADDUWDP, MADDSUWDP, MMA212W ]": "1000..1011", "[ MSBFWDP, MSBFUWDP, MSBFSUWDP, MMS212W ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_QQDD: 12..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1M
    behavior: *behaviorDW2RRR1M
  - ID: MAU_QDD0
    what: MAU Quadruple Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWDP, MULUWDP, MULSUWDP, MM212W ]": "0000..0011" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QDD0.M
    what: MAU Quadruple Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWDP, MULUWDP, MULSUWDP, MM212W ]": "0000..0011" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_QDD0: 12..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU.X
    execution: *executionDW2RRM
    behavior: *behaviorDW2RRM
  - ID: MAU_DDD0
    what: MAU Double Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULD, MULWP, MULHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DDD0.M
    what: MAU Double Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULD, MULWP, MULHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_DDD0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU.X
    execution: *executionDW2RRM
    behavior: *behaviorDW2RRM
  - ID: MAU_QQDD1
    what: MAU Quadruple Quadruple Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDDT, MADDUDT, MADDSUDT, MADDUZDT ]": "1000..1011", "[ MSBFDT, MSBFUDT, MSBFSUDT, MSBFUZDT ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QDD1
    what: MAU Quadruple Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULDT, MULUDT, MULSUDT, CMULDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQDD2
    what: MAU Quadruple Quadruple Double Double 2
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CMULXDT, CMULGLXDT, CMULGMXDT, CMULGHXDT ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQQ
    what: MAU Quadruple Quadruple Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ DOT2WDP, DOT2UWDP, DOT2SUWDP, DOT2WZP ]": "0000..0011", "[ MULWQ, MULMWQ, MULUMWQ, MULSUMWQ ]": "0100..0111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - exucode5: "0010"
      - registerO: "-----"
      - exubit6: "0"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQQQ
    what: MAU Quadruple Quadruple Quadruple Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWQ, MADDMWQ, MADDUMWQ, MADDSUMWQ ]": "0000..0011", "[ MSBFWQ, MSBFMWQ, MSBFUMWQ, MSBFSUMWQ ]": "0100..0111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exucode5: "0010"
      - registerO: "-----"
      - exubit6: "0"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_CRC
    what: MAU CRC
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CRCBELMW, CRCBELLW, CRCLELMW, CRCLELLW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_CRC.W
    what: MAU CRC Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CRCBELMW, CRCBELLW, CRCLELMW, CRCLELLW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_CRC: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DPP
    what: MAU Double Pair Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ DOT2WD, DOT2UWD, DOT2SUWD, DOT2W ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_SSSS
    what: MAU Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWD, MADDUWD, MADDSUWD, MADDW ]": "0000..0011", "[ MSBFWD, MSBFUWD, MSBFSUWD, MSBFW ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_SSSS.W
    what: MAU Single Single Single Single Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWD, MADDUWD, MADDSUWD, MADDW ]": "0000..0011", "[ MSBFWD, MSBFUWD, MSBFSUWD, MSBFW ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_SSSS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_SSS
    what: MAU Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWD, MULUWD, MULSUWD, MULW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_SSS.W
    what: MAU Single Single Single Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWD, MULUWD, MULSUWD, MULW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_SSS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.X
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQDD3
    what: MAU Quadruple Quadruple Double Double 3
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDHWQ, MADDUHWQ, MADDSUHWQ ]": "0000..0010", "[ MSBFHWQ, MSBFUHWQ, MSBFSUHWQ ]": "0100..0110" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QDD3
    what: MAU Quadruple Double Double 3
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULHWQ, MULUHWQ, MULSUHWQ ]": "1000..1010" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DIVREM
    what: MAU Integer Division and Remainder
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - scalarcond: "----"
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: { "[ DIVREMD, DIVREMUD, DIVREMW, DIVREMUW ]": "1000..1011" }
      - registerY: "------"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ scalarcond, { pairedReg: registerM }, { pairedReg: registerP }, { singleReg: registerY } ]
    syntax: "%0%1 %3? %2 = %4"
    scheduling: MAU
    execution: |
      stage ID:
      new argument1 = %1;
      stage RR:
      new argument4 = %2;
      new argument4_l = _ZX_64(argument4);
      new argument4_m = _ZX_64(argument4 >> 64);
      new argument3 = %3;
      stage E1:
      if (scalarcond(argument1, argument3)) {
        @Instruction
      stage SF:
        %2 = (result2_m << 64) | _ZX_64(result2_l);
      }
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.SF.%1
          (IOR
            (SHL (READ.result2_m) (CONST.64))
            (ZX.64 (READ.result2_l)))))
  - ID: MAU_COPYQ
    what: MAU Copy Quadruple Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { COPYQ: "1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: MAU_FDDDD
    what: MAU Floating-Point Double Double Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAD, FFMAWD, FFMAWP, FFMAHQ ]": "0000..0011", "[ FFMSD, FFMSWD, FFMSWP, FFMSHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDDE4
    behavior: *behaviorFDDDDE4
  - ID: MAU_FDDD
    what: MAU Floating-Point Double Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FMULD, FMULWD, FMULWP, FMULHQ ]": "1000..1011", "[ FDOT2W, FDOT2WD, FMULWC, FMULWC.C ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDDE4
    behavior: *behaviorFDDDE4
  - ID: MAU_FDDD1
    what: MAU Floating-Point Double Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDD, FADDWP, FADDHQ, FADDWC.C ]": "0000..0011", "[ FSBFD, FSBFWP, FSBFHQ, FSBFWC.C ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDDE4
    behavior: *behaviorFDDDE4
  - ID: MAU_FSSSS
    what: MAU Floating-Point Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAHW, FFMAW, FFMSHW, FFMSW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDDE4
    behavior: *behaviorFDDDDE4
  - ID: MAU_FSSS
    what: MAU Floating-Point Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDW, FSBFW, FMULW, FMULHW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQDD
    what: MAU Floating-Point Quadruple Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAWDP, FFMAHWQ ]": "0000..0001", "[ FFMSWDP, FFMSHWQ ]": "0010..0011", FMMA212W: "0100", FMMS212W: "0110" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFQQDD
    behavior: *behaviorFQQDD
  - ID: MAU_FQDD
    what: MAU Floating-Point Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FMULWDP, FMULHWQ ]": "0000..0001", "[ FMULWDC, FMULWDC.C ]": "0010..0011", FMM212W: "0100" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQQ2
    what: MAU Floating-Point Quadruple Quadruple Quadruple 2
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FMULHO, FADDHO, FSBFHO ]": "0101..0111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQQQ
    what: MAU Floating-Point Quadruple Quadruple Quadruple Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAWQ, FFMSWQ, FFMAHO, FFMSHO ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDDE4
    behavior: *behaviorFDDDDE4
  - ID: MAU_FQQQ0
    what: MAU Floating-Point Quadruple Quadruple Quadruple 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDDP, FADDDC.C, FSBFDP, FSBFDC.C ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQQ1
    what: MAU Floating-Point Quadruple Quadruple Quadruple 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDWQ, FADDWCP.C, FSBFWQ, FSBFWCP.C ]": "1000..1011", "[ FDOT2WDP, FDOT2WZP, FMULWQ, FMULDP ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
Generic:
Immediate:
  - ID: pcrel11
    what: CCB Offset
    relative: PC
    execution: "(_SX_11(%0)<<2)"
  - ID: pcrel17
    what: CB Offset
    relative: PC
    execution: "(_SX_17(%0)<<2)"
  - ID: pcrel27
    what: GOTO / CALL Offset
    relative: PC
    execution: "(_SX_27(%0)<<2)"
  - ID: pcrel38
    what: CCB Offset Extended
    relative: PC
    execution: "(_SX_38(%0)<<2)"
  - ID: brknumber
    what: Break Number
    execution: "_ZX_2(%0)"
  - ID: sysnumber
    what: System Number
    execution: "_ZX_12(%0)"
  - ID: unsigned6
    what: Zero Extended Immediate 6 bits
    shortName: u6
    execution: "_ZX_6(%0)"
  - ID: wrapped8
    what: Wrapped Immediate 8 bits
    shortName: w8
    execution: "_WX_8(%0)"
  - ID: signed10
    what: Sign Extended Immediate 10 bits
    shortName: s10
    execution: "_SX_10(%0)"
  - ID: signed16
    what: Sign Extended Immediate 16 bits
    shortName: s16
    execution: "_SX_16(%0)"
  - ID: signed27
    what: Sign Extended Immediate 27 bits
    shortName: s27
    execution: "_SX_27(%0)"
  - ID: wrapped32
    what: Wrapped Immediate 32 bits
    shortName: w32
    execution: "_WX_32(%0)"
  - ID: signed37
    what: Sign Extended Immediate 37 bits
    shortName: s37
    execution: "_SX_37(%0)"
  - ID: signed43
    what: Sign Extended Immediate 43 bits
    shortName: s43
    execution: "_SX_43(%0)"
  - ID: signed54
    what: Sign Extended Immediate 54 bits
    shortName: s54
    execution: "_SX_54(%0)"
  - ID: wrapped64
    what: Wrapped Immediate 64 bits
    shortName: w64
    execution: "_WX_64(%0)"
Instruction:
  - ID: AWAIT
    what: Wait for any event or interrupt.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU0} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      idle(0);
    behavior: |
      (EFFECT.RR.idle (CONST.0))
  - ID: SLEEP
    what: Wait for an eligible interrupt.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU1} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      idle(1);
    behavior: |
      (EFFECT.RR.idle (CONST.1))
  - ID: STOP
    what: Wait for power controller wake-up.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU2} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      if (stop_owner()) {
        idle(2);
      } else {
        _THROW(PRIVILEGE);
      }
    behavior: |
      (SEQ
        (IF
          (TEST.stop_owner)
          (EFFECT.RR.idle (CONST.2))
          (THROW.RR.PRIVILEGE)))
  - ID: BARRIER
    what: Instruction Pipeline Barrier
    formats: [ BCU_IPC ]
    properties: { '%0': MemoryFence }
    description: >
      Flush the core instruction pipeline and memory system.
    execution: |
      stage RR:
      barrier();
    behavior: |
      (EFFECT.RR.barrier)
  - ID: TLBREAD
    what: Read TLB Entry
    formats: [ BCU_TLB ]
    description: >
      Read the TLB entry into the TEL:TEH register pair using MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        readtlb();
      }
    behavior: |
      (SEQ
        (IF (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.readtlb)))
  - ID: TLBPROBE
    what: Probe TLB
    formats: [ BCU_TLB ]
    description: >
      Probe the TLB for virtual address match in the TEL:TEH register pair and write to MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        probetlb();
      }
    behavior: |
      (SEQ
        (IF
          (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.probetlb)))
  - ID: TLBWRITE
    what: TLB Entry Write
    formats: [ BCU_TLB ]
    properties: { '%0': Privilege }
    schedulings: [ ALL ]
    description: >
      Write the TLB entry from the TEL:TEH register pair using MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        writetlb();
      }
    behavior: |
      (SEQ
        (IF
          (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.writetlb)))
  - ID: TLBDINVAL
    what: Invalidate Data Micro-TLB.
    formats: [ BCU_TLB ]
    description: >
      Invalidate Data Micro-TLB.
    execution: |
      stage RR:
      invaldtlb();
    behavior: |
      (EFFECT.RR.invaldtlb)
  - ID: TLBIINVAL
    what: Invalidate Instruction Micro-TLB.
    formats: [ BCU_TLB ]
    description: >
      Invalidate Instruction Micro-TLB.
    execution: |
      stage RR:
      invalitlb();
    behavior: |
      (EFFECT.RR.invalitlb)
  - ID: ERROP
    what: Error Opcode
    formats: [ BCU_NOB ]
    description: >
      Invalid opcode, should always trap.
    execution: |
      stage RR:
      _THROW(OPCODE);
    behavior: |
      (THROW.RR.OPCODE)
  - ID: BREAK
    what: Debugger Breakpoint
    formats: [ BCU_BREAK ]
    description: >
      Breakpoint for the debugger.
    execution: |
      stage RR:
      break(argument1);
    behavior: |
      (EFFECT.RR.break (READ.argument1))
  - ID: XMOVEFD
    what: Move From Extension Double Word
    class: EXT
    formats: [ BCU_XMOVEFD ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the contents of the %2.
    execution: |
      new result1 = _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (ZX.64 (READ.argument2)))
  - ID: XMOVEFQ
    what: Move From Extension Quadruple Word
    class: EXT
    formats: [ BCU_XMOVEFQ ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the contents of the %2.
    execution: |
      new result1 = _ZX_128(argument2);
    behavior: |
      (WRITE.result1
        (ZX.128 (READ.argument2)))
  - ID: XMOVEFO
    what: Move From Extension Octuple Word
    class: EXT
    formats: [ BCU_XMOVEFO ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the contents of the %2.
    execution: |
      new result1 = _ZX_256(argument2);
    behavior: |
      (WRITE.result1
        (ZX.256 (READ.argument2)))
  - ID: XCOPYO
    what: Copy Extension Octuple Word
    class: EXT
    formats: [ BCU_XCOPYO ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the value of the %2 operand.
    execution: |
      new result1 = argument2;
    behavior: |
      (WRITE.result1
        (READ.argument2))
  - ID: XFSCALEWO
    what: Floating Point Scale Word Vector
    class: EXT
    formats: [ BCU_XFSCALEWO ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a vector of 8 binary 32 floating-point numbers,
      which are scaled by the power of 2 given in %3 interpreted as an integer.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = fpow2scale_32_32_x8(XRM, pow2scale, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.256.fpow2scale_32_32_x8
          (READ.XRM)
          (READ.pow2scale)
          (READ.argument2)))
  - ID: RET
    what: Return from Call
    formats: [ BCU_RTS ]
    description: >
      The next bundle \textbf{PC} is obtained by reading the contents of the \textbf{RA} register.
      \textbf{SRHPC} register may be updated according to current privilege level and owners configuration.
    execution: |
      stage ID:
      NPC = RA;
    behavior: |
      (SEQ
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (LOAD.ID (AGGL.SFR (CONST.RA) (CONST.1))))
        (EFFECT.RR.branch_info (CONST.1)
          (F2I.64 (LOAD.ID (AGGL.SFR (CONST.RA) (CONST.1)))))
        (EFFECT.RR.srhpc_update)
      )
  - ID: RFE
    what: Return from Exception
    formats: [ BCU_RTS ]
    properties: { '%0': Privilege }
    schedulings: [ ALL ]
    description: >
      The \textbf{PS} is restored from the \textbf{SPS}.
      The \textbf{SPS} is restored from the \textbf{SSPS}.
      The next bundle \textbf{PC} is obtained by reading the contents of the \textbf{SPC} register.
      The \textbf{SPC} is restored from the \textbf{SSPC}.
      \textbf{SRHPC} register may be updated according to current privilege level and owners configuration.
    execution: |
      stage ID:
      if (rfe_owner()) {
        rfe();
      }
    behavior: |
      (SEQ
        (IF
          (TEST.rfe_owner)
          (SEQ
            (EFFECT.RR.rfe)
            (EFFECT.RR.branch_info (CONST.1)
              (F2I.64 (LOAD.ID (AGGL.SFR (CONST.SPC) (CONST.1)))))
            (EFFECT.RR.srhpc_update)
          )
          (SKIP)))
  - ID: IGOTO
    what: Indirect Branch from Register
    formats: [ BCU_IBC ]
    description: >
      The next bundle \textbf{PC} is computed by reading the %1.
      \textbf{SRHPC} register may be updated according to current privilege level and owners configuration.
    execution: |
      stage RR:
      NPC = argument1;
    behavior: |
      (SEQ
        (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.argument1)))
        (EFFECT.RR.branch_info (CONST.1) (READ.argument1))
        (EFFECT.RR.srhpc_update)
        )
  - ID: ICALL
    what: Indirect Call from Register
    formats: [ BCU_IBC ]
    description: >
      The sequential next bundle \textbf{PC} is copied into the \textbf{RA} register.
      The next bundle \textbf{PC} is computed by reading the %1.
    execution: |
      stage ID:
      new next = NPC;
      stage RR:
      NPC = argument1;
      RA = next;
    behavior: |
      (SEQ
        (WRITE.next
          (F2I.64 (LOAD.ID (AGGL.NPC (CONST.0) (CONST.1)))))
        (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.argument1)))
        (STORE.RR (AGGL.SFR (CONST.RA) (CONST.1))
          (I2F.64 (READ.next)))
        (EFFECT.RR.branch_info (CONST.1) (READ.argument1)))
  - ID: SCALL
    what: System Call
    formats: [ BCU_SCR, BCU_SCI ]
    description: >
      System call with number %2. Interrupts are disabled.
    execution: |
      stage ID:
      syscall(argument1);
    behavior: |
      (SEQ
        (EFFECT.ID.syscall (READ.argument1))
        (EFFECT.ID.branch_info (CONST.1) (READ.argument1)))
  - ID: LOOPDO
    what: Hardware Loop setup and Do execute
    formats: [ BCU_HLS ]
    description: >
      If \textbf{PS.HLE} is cleared, this instruction throws an OPCODE trap.
      The \textbf{LS} register is set to the sequential next bundle \textbf{PC}. The \textbf{LE} register is set to
      the current bundle \textbf{PC} plus the %2 after sign extension and scaling by 4. The \textbf{LC} register is set with the %1.
      If the \textbf{PS.HLE} bit is set in the \textbf{PS} register, hardware loop execution proceeds by comparing
      the sequential next bundle \textbf{PC} to the value of the \textbf{LE} register:
      \begin{itemize}
      \item If different, the next bundle \textbf{PC} is computed as usual.
      \item If the sequential next bundle \textbf{PC} equals the value of the \textbf{LE} register: \begin{itemize}
        \item If the value of the \textbf{LC} register ${}-1$ is non-zero, the value of the next bundle \textbf{PC}
        is read from the \textbf{LS} register, unless a branch is taken in the current bundle (in which case the next bundle \textbf{PC} is the branch target bundle \textbf{PC}).
        \item If the value of the \textbf{LC} register ${}-1$ is zero, the value of the next bundle \textbf{PC} is
        the value of the \textbf{LE} register, unless a branch is taken in the current bundle (in which case the next bundle \textbf{PC} is the branch target bundle \textbf{PC}).
        \item The \textbf{LC} register is decremented if its value is not already zero.
        \end{itemize}
      \end{itemize}
      According to these rules, the LOOPDO instruction loops forever whenever the value of the %1 is zero, as the
      the value of the \textbf{LC} register ${}-1$ is always non-zero, while the \textbf{LC} register is never decremented.
      This instruction is provided for counted loops which iterate at least once, and while loops by setting the counter to zero.
    execution: |
      stage ID:
      if (!PS.HLE) {
        _THROW(OPCODE);
      } else {
        LS = NPC;
        LE = PC + _SX_32(argument2);
        LC = _ZX_64(argument1);
      }
    behavior: |
      (SEQ
        (IF (NOTL (I2B (F2I.1 (LOAD.ID (AGGL.PS (CONST.PS_HLE) (CONST.1))))))
          (THROW.ID.OPCODE)
          (SKIP))
        (STORE.E2 (AGGL.SFR (CONST.LS) (CONST.1))
          (LOAD.E2 (AGGL.NPC (CONST.0) (CONST.1))))
        (STORE.E2 (AGGL.SFR (CONST.LE) (CONST.1))
          (I2F.64
            (ADD
              (F2I.64 (LOAD.E2 (AGGL.PC (CONST.0) (CONST.1))))
              (SX.32 (READ.argument2)))))
        (EFFECT.ID.invalpfb)
        (STORE.ID (AGGL.SFR (CONST.LC) (CONST.1))
          (I2F.64 (ZX.64 (READ.argument1))))))
  - ID: WFXL
    what: Effects on Least Significant Word of System Register
    formats: [ BCU_WFX, BCU_WFXA, BCU_WFXHW ]
    description: >
      The least significant word of the %1 is operated, with the most significant word of the %2
      as a set mask and the least significant word of the %2 as a clear mask.
    execution: |
      if (wfxl_check_access(@1, @2)) {
        new setmask = argument2.32[1];
        new clrmask = argument2.32[0];
        result1 = (argument1 & ~clrmask) | setmask;
      }
    behavior: |
      (SEQ
        (IF (TEST.wfxl_check_access (METHOD.%1) (METHOD.%2))
          (WRITE.result1
            (APPLY.wfxl (METHOD.%1) (ZX.64 (READ.argument2))))
          (SKIP)))
  - ID: WFXM
    what: Word Effects on Most Significant Word of System Register
    formats: [ BCU_WFX, BCU_WFXA, BCU_WFXHW ]
    description: >
      The most significant word of the %1 is operated, with the most significant word of the %2
      as a set mask and the least significant word of the %2 as a clear mask.
    execution: |
      if (wfxm_check_access(@1, @2)) {
        new setmask = argument2.32[1] << 32;
        new clrmask = argument2.32[0] << 32;
        result1 = (argument1 & ~clrmask) | setmask;
      }
    behavior: |
      (SEQ
        (IF (TEST.wfxm_check_access (METHOD.%1) (METHOD.%2))
          (WRITE.result1
            (APPLY.wfxm (METHOD.%1) (ZX.64 (READ.argument2))))
          (SKIP)))
  - ID: GET
    what: Get System Register
    formats: [ BCU_GSR, BCU_GSRHW ]
    description: >
      The %1 is copied from the %2 register.
    execution: |
      stage RR:
      if (get_check_access(@2, @1)) {
        new result1 = get(@2, _ZX_64(argument2));
      }
    behavior: |
      (IF (TEST.get_check_access (METHOD.%2) (METHOD.%1))
        (WRITE.result1
          (APPLY.get (METHOD.%2) (ZX.64 (READ.argument2))))
        (SKIP))
  - ID: IGET
    what: Indirect Get System Register
    formats: [ BCU_IGSR ]
    description: >
      The %1 is copied from the system register whose index is in the %1.
    execution: |
      stage RR:
      if (get_check_access(index, @1)) {
        new result1 = get(index, SFR[index]);
      }
    behavior: |
      (IF (TEST.get_check_access (READ.index) (METHOD.%1))
        (WRITE.result1
          (APPLY.get
            (READ.index) (F2I.64 (LOAD.RR (AGGL.SFR (READ.index) (CONST.1))))))
        (SKIP))
  - ID: SET
    what: Set System Register
    formats: [ BCU_SET, BCU_SETA, BCU_SETRA, BCU_SETHW ]
    description: >
      The %1 register is set with the %2.
    execution: |
      stage RR:
      if (set_check_access(@1, argument2, @2)) {
        new result1 = _ZX_64(argument2);
        stage E3:
        %1 = result1;
      }
    behavior: |
      (IF (TEST.set_check_access (METHOD.%1) (ZX.64 (READ.argument2)) (METHOD.%2))
        (SEQ
          (WRITE.result1 (ZX.64 (READ.argument2)))
          (COMMIT.E3.%1 (READ.result1)))
        (SKIP))
  - ID: RSWAP
    what: General and System Register Swap
    formats: [ BCU_RSWAP, BCU_RSWAPA, BCU_RSWAPHW ]
    description: >
      The contents of the %1 are swapped set with the contents of the %2.
    execution: |
      stage E1:
      new result2 = _ZX_64(argument1);
      new result1 = _ZX_64(argument2);
    behavior: |
      (IF (ANDL
            (TEST.get_check_access (METHOD.%2) (METHOD.%1))
            (TEST.set_check_access (METHOD.%2) (ZX.64 (READ.argument1)) (METHOD.%1)))
        (SEQ
          (WRITE.result2 (ZX.64 (READ.argument1)))
          (WRITE.result1 (ZX.64 (READ.argument2)))
          (COMMIT.E1.%1 (READ.result1))
          (COMMIT.E1.%2 (READ.result2)))
        (SKIP))
  - ID: WAITIT
    what: Wait for Interrupt
    formats: [ BCU_PGI ]
    schedulings: [ BCU_TINY_TINY_MAU_XNOP ]
    description: >
      Execution waits for selected interrupts in the \textbf{ILR} register (masking non-owned interrupts, i.e. interrupts that belong to a more privileged PL. The %1 is interpreted as an OR-mask in the
      least significant word and a AND-mask in the most significant word. The wait ends if all the bits in \textbf{ILR}
      match the non-zero AND-mask, or if any bit in \textbf{ILR} matches the non-zero OR-mask.
      When the wait is over, the value of \textbf{ILR} (masked in the same way) is written to the %1.
      When both the AND-mask and OR-mask are zero, no wait happens.
    execution: |
      stage RR:
      new ormask = argument1 & 0xFFFFFFFF;
      new andmask = argument1.32[1];
      new result1 = waitit(ormask, andmask);
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.ormask
          (AND (READ.argument1) (CONST.0xFFFFFFFF)))
        (WRITE.andmask
          (READ.32[1].argument1))
        (WRITE.result1
          (APPLY.waitit (READ.ormask) (READ.andmask)))
        (COMMIT.RR.%1 (READ.result1)))
  - ID: SYNCGROUP
    what: Synchronize Group of Cores
    formats: [ BCU_PGI ]
    description: >
      The %1 is interpreted as four 16-bit fields: \textbf{waitclrF}, \textbf{waitclrB}, \textbf{notifyF}, \textbf{notifyB}.
      Upon executing the instruction, the core waits until all the events designated by bits in \textbf{waitclrF} and
      \textbf{waitclrB} in the 32 least-significant bits of \textbf{IPE} are set. When all the designated events are set, the core
      clears them, then notifies the event lines corresponding to the bit sets in fields \textbf{notifyF} and and \textbf{notifyB}.
      This notification of events is not registered in the core, it is a signal sent to set bits into the \textbf{IPE.FE} and
      \textbf{IPE.BE} fields of the destination cores. The successor core always receives the \textbf{notifyF} events in its
      \textbf{IPE.FE} field; likewise, the predecessor core always receives the \textbf{notifyB} events in its \textbf{IPE.BE} field.
      Furthermore, other PEs may receive these events, depending on the setting of the \textbf{IPE.FM} and \textbf{IPE.BM} fields
      in these neighbor PE cores.
    execution: |
      stage RR:
      if (!syncgroup_owner()) {
        _THROW(PRIVILEGE);
      } else {
        new waitclrF = argument1 & 0xFFFF;
        new waitclrB = (argument1 >> 16) & 0xFFFF;
        new notifyF = (argument1 >> 32) & 0xFFFF;
        new notifyB = (argument1 >> 48) & 0xFFFF;
        syncgroup(waitclrF, waitclrB, notifyF, notifyB);
      }
    behavior: |
      (IF
        (NOTL (TEST.syncgroup_owner))
        (THROW.RR.PRIVILEGE)
        (SEQ
          (WRITE.waitclrF
            (AND (READ.argument1) (CONST.0xFFFF)))
          (WRITE.waitclrB
            (AND (SHR (READ.argument1) (CONST.16)) (CONST.0xFFFF)))
          (WRITE.notifyF
            (AND (SHR (READ.argument1) (CONST.32)) (CONST.0xFFFF)))
          (WRITE.notifyB
            (AND (SHR (READ.argument1) (CONST.48)) (CONST.0xFFFF)))
          (EFFECT.RR.syncgroup
            (READ.waitclrF)
            (READ.waitclrB)
            (READ.notifyF)
            (READ.notifyB))))
  - ID: GOTO
    what: Branch Unconditional PC-Relative
    formats: [ BCU_UB ]
    description: >
      The next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC} the %1
      after sign extension and scaling by 4.
      \textbf{SRHPC} register may be updated according to current privilege level and owners configuration.
    execution: |
      stage ID:
      NPC = PC + _SX_32(argument1);
    behavior: |
      (SEQ
        (WRITE.address
          (ADD
            (F2I.64 (LOAD.ID (AGGL.PC (CONST.0) (CONST.1))))
            (SX.32 (READ.argument1)))))
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.address)))
        (EFFECT.ID.branch_info (CONST.1) (READ.address))
        (EFFECT.RR.srhpc_update)
      )
  - ID: CALL
    formats: [ BCU_UB ]
    what: Call Subroutine PC-Relative
    description: >
      The sequential next bundle \textbf{PC} is copied into the \textbf{RA} register.
      The next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC} the %1
      after sign extension and scaling by 4.
    execution: |
      stage ID:
      new next = NPC;
      NPC = PC + _SX_32(argument1);
      stage RR:
      RA = next;
    behavior: |
      (SEQ
        (WRITE.next
          (F2I.64 (LOAD.ID (AGGL.NPC (CONST.0) (CONST.1)))))
        (WRITE.address
          (ADD
            (F2I.64 (LOAD.ID (AGGL.PC (CONST.0) (CONST.1))))
            (SX.32 (READ.argument1))))
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.address)))
        (STORE.RR (AGGL.SFR (CONST.RA) (CONST.1))
          (I2F.64 (READ.next)))
        (EFFECT.ID.branch_info (CONST.1) (READ.address)))
  - ID: CB
    what: Conditional Branch PC-Relative
    formats: [ BCU_CB ]
    description: >
      If %2 satisfies condition %1, the next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC}
      the %3 after sign extension and scaling by 4.
      \textbf{SRHPC} register may be updated according to current privilege level and owners configuration.
    execution: |
      stage RR:
      if (scalarcond(argument1, argument2)) {
        NPC = PC + argument3;
      }
    behavior: |
      (IF
        (TEST.scalarcond (READ.argument1) (READ.argument2))
        (SEQ
          (WRITE.address
            (ADD
              (F2I.64 (LOAD.RR (AGGL.PC (CONST.0) (CONST.1))))
              (SX.64 (READ.argument3))))
          (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
            (I2F.64 (READ.address)))
          (EFFECT.RR.branch_info (CONST.1) (READ.address))
          (EFFECT.RR.srhpc_update)
        )
        (EFFECT.RR.branch_info (CONST.0) (CONST.0)))
  - ID: LBZ
    what: Load Byte Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %1 is loaded from the memory byte at the effective address after zero extension.
    execution: |
      new result1 = _ZX_8(MEM.load(address, 0x1, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.8
          (APPLY.8.MEM_load
            (READ.address)
            (CONST.0x1)
            (READ.variant)
            (METHOD.%1))))
  - ID: LBS
    what: Load Byte Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %1 is loaded from the memory byte at the effective address after sign extension.
    execution: |
      new result1 = _SX_8(MEM.load(address, 0x1, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.8
          (APPLY.8.MEM_load
            (READ.address)
            (CONST.0x1)
            (READ.variant)
            (METHOD.%1))))
  - ID: LHZ
    what: Load Half Word Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %1 is loaded from the memory half word at the effective address after zero extension.
    execution: |
      new result1 = _ZX_16(MEM.load(address, 0x3, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.16
          (APPLY.16.MEM_load
            (READ.address)
            (CONST.0x3)
            (READ.variant)
            (METHOD.%1))))
  - ID: LHS
    what: Load Half Word Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %1 is loaded from the memory half word at the effective address after sign extension.
    execution: |
      new result1 = _SX_16(MEM.load(address, 0x3, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.16
          (APPLY.16.MEM_load
            (READ.address)
            (CONST.0x3)
            (READ.variant)
            (METHOD.%1))))
  - ID: LWZ
    what: Load Word Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %1 is loaded from the memory word at the effective address after zero extension.
    execution: |
      new result1 = _ZX_32(MEM.load(address, 0xF, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.32
          (APPLY.32.MEM_load
            (READ.address)
            (CONST.0xF)
            (READ.variant)
            (METHOD.%1))))
  - ID: LWS
    what: Load Word Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %1 is loaded from the memory word at the effective address after sign extension.
    execution: |
      new result1 = _SX_32(MEM.load(address, 0xF, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.32
          (APPLY.32.MEM_load
            (READ.address)
            (CONST.0xF)
            (READ.variant)
            (METHOD.%1))))
  - ID: LD
    what: Load Double Word
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.D, LSU_LSBI ]
    properties: { '%0': MemorySize=8 }
    description: >
      The %1 is loaded from the memory double word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFF, variant, @1);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_load
            (READ.address)
            (CONST.0xFF)
            (READ.variant)
            (METHOD.%1)))
  - ID: LQ
    what: Load Quadruple Word
    formats: [ LSU_LQBO, LSU_LQBO.X, LSU_LQBO.Y, LSU_LQPB, LSU_LQPB.O, LSU_LQPB.D, LSU_LQBI ]
    properties: { '%0': MemorySize=16 }
    description: >
      The %1 is loaded from the memory quadruple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFF, variant, @1 << 1);
    behavior: |
      (WRITE.result1
        (APPLY.128.MEM_load
            (READ.address)
            (CONST.0xFFFF)
            (READ.variant)
            (SHL (METHOD.%1) (CONST.1))))
  - ID: LO
    what: Load Octuple Word
    formats: [ LSU_LOBO, LSU_LOBO.X, LSU_LOBO.Y, LSU_LOPB, LSU_LOPB.O, LSU_LOPB.D, LSU_LOMB, LSU_LOMB.O, LSU_LOMB.D, LSU_LOBI ]
    properties: { '%0': MemorySize=32 }
    description: >
      The %1 is loaded from the memory octuple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFFFFFF & bytemask, variant, @1 << 2);
    behavior: |
      (WRITE.result1
        (APPLY.256.MEM_load
          (READ.address)
          (AND (CONST.0xFFFFFFFF) (READ.bytemask))
          (READ.variant)
          (SHL (METHOD.%1) (CONST.2))))
  - ID: XLO
    what: Extension Load Octuple Word
    formats: [ LSU_XLOBO, LSU_XLOBO.X, LSU_XLOBO.Y, LSU_XLOC4BO, LSU_XLOC4BO.X, LSU_XLOC4BO.Y, LSU_XLOMB, LSU_XLOMB.O, LSU_XLOMB.D, LSU_XLOC4MB, LSU_XLOC4MB.O, LSU_XLOC4MB.D, LSU_XLBI, LSU_XLOC4BI ]
    properties: { '%0': Extension;MemorySize=32 }
    description: >
      The %1 is loaded from the memory octuple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFFFFFF & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.256.MEM_load
          (READ.address)
          (AND (CONST.0xFFFFFFFF) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLB
    what: Extension Preload Byte
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=1 }
    description: >
      The %1 is preloaded from the memory byte at the effective address.
    execution: |
      new result1 = MEM.load(address, 0x1 & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.8.MEM_load
          (READ.address)
          (AND (CONST.0x1) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLH
    what: Extension Preload Half
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=2 }
    description: >
      The %1 is preloaded from the memory half word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0x3 & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.16.MEM_load
          (READ.address)
          (AND (CONST.0x3) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLW
    what: Extension Preload Word
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=4 }
    description: >
      The %1 is preloaded from the memory word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xF & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.32.MEM_load
          (READ.address)
          (AND (CONST.0xF) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLD
    what: Extension Preload Double Word
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=8 }
    description: >
      The %1 is preloaded from the memory double word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFF & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_load
          (READ.address)
          (AND (CONST.0xFF) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLQ
    what: Extension Preload Quadruple Word
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=16 }
    description: >
      The %1 is preloaded from the memory quadruple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFF & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.128.MEM_load
          (READ.address)
          (AND (CONST.0xFFFF) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: XPLO
    what: Extension Preload Octuple Word
    formats: [ LSU_XPL2RBB, LSU_XPL2RBB.O, LSU_XPL2RBB.D, LSU_XPL4RBB, LSU_XPL4RBB.O, LSU_XPL4RBB.D, LSU_XPL8RBB, LSU_XPL8RBB.O, LSU_XPL8RBB.D, LSU_XPL16RBB, LSU_XPL16RBB.O, LSU_XPL16RBB.D, LSU_XPL32RBB, LSU_XPL32RBB.O, LSU_XPL32RBB.D, LSU_XPL64RBB, LSU_XPL64RBB.O, LSU_XPL64RBB.D ]
    properties: { '%0': Extension;MemorySize=32 }
    description: >
      The %1 is preloaded from the memory octuple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFFFFFF & bytemask, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.256.MEM_load
          (READ.address)
          (AND (CONST.0xFFFFFFFF) (READ.bytemask))
          (READ.variant)
          (READ.dri)))
  - ID: SB
    what: Store Byte
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.D ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %3 is stored into the memory byte at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0x1, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0x1)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SH
    what: Store Half Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.D ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %3 is stored into the memory half word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0x3, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0x3)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SW
    what: Store Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.D ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %3 is stored into the memory word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xF, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xF)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SD
    what: Store Double Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.D ]
    properties: { '%0': MemorySize=8 }
    description: >
      The %3 is stored into the memory double word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFF, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFF)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SQ
    what: Store Quadruple Word
    formats: [ LSU_SQBO, LSU_SQBO.X, LSU_SQBO.Y, LSU_SQBI, LSU_SQPB, LSU_SQPB.O, LSU_SQPB.D ]
    properties: { '%0': MemorySize=16 }
    description: >
      The %3 is stored into the memory quadruple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFF, 0, argument3, @3 << 1);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFFFF)
        (CONST.0)
        (READ.argument3)
        (SHL (METHOD.%3) (CONST.1)))
  - ID: SO
    what: Store Octuple Word
    formats: [ LSU_SOBO, LSU_SOBO.X, LSU_SOBO.Y, LSU_SOPB, LSU_SOPB.O, LSU_SOPB.D, LSU_SOMB, LSU_SOMB.O, LSU_SOMB.D, LSU_SOBI ]
    properties: { '%0': MemorySize=32 }
    description: >
      The %3 is stored into the memory octuple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFFFFFF & bytemask, 0, argument3, @3 << 2);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (AND (CONST.0xFFFFFFFF) (READ.bytemask))
        (CONST.0)
        (READ.argument3)
        (SHL (METHOD.%3) (CONST.2)))
  - ID: XSO
    what: Extension Store Octuple Word
    formats: [ LSU_XSOBO, LSU_XSOBO.X, LSU_XSOBO.Y, LSU_XSOMB, LSU_XSOMB.O, LSU_XSOMB.D, LSU_XSOBI ]
    properties: { '%0': Extension;MemorySize=32 }
    description: >
      The %3 is stored into the memory octuple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFFFFFF & bytemask, 0, argument3, dri);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (AND (CONST.0xFFFFFFFF) (READ.bytemask))
        (CONST.0)
        (READ.argument3)
        (READ.dri))
  - ID: ACSWAPW
    what: Atomic Compare and Swap Word
    formats: [ LSU_ACSWAPSB, LSU_ACSWAPSB.O, LSU_ACSWAPSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      This instruction implements Compare-And-Swap (CAS) on memory word (32 bits).
      The %3 is interpreted as the concatenation of \texttt{update} (low 64 bits) and \texttt{expected} (high 64 bits).
      The memory word at the effective address is read into \texttt{current}.
      If \texttt{current} equals \texttt{expected}, the swap is successful and \texttt{update}
      is stored into the memory word at the effective address. Otherwise, the swap has failed and the memory is not updated.
      The instruction return value is stored into the %1. It is true/false in case \texttt{boolcas} is true, or
      the \texttt{current} value in case \texttt{boolcas} is false.
      The effective address must be word aligned (multiple of 4).
    execution: |
      new result1 = MEM.atomic_cas(address, 0xF, boolcas | (coherency << 32), arguments.32[0], arguments.32[2], @1);
    behavior: |
      (WRITE.result1
        (APPLY.32.MEM_atomic_cas
          (READ.address)
          (CONST.0xF)
          (IOR
            (READ.boolcas)
            (SHL (READ.coherency) (CONST.32)))
          (READ.32[0].arguments)
          (READ.32[2].arguments)
          (METHOD.%1)))
  - ID: ACSWAPD
    what: Atomic Compare and Swap Double Word
    formats: [ LSU_ACSWAPSB, LSU_ACSWAPSB.O, LSU_ACSWAPSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      This instruction implements Compare-And-Swap (CAS) on memory double word (64 bits).
      The %3 is interpreted as the concatenation of \texttt{update} (low 64 bits) and \texttt{expected} (high 64 bits).
      The memory double word at the effective address is read into \texttt{current}.
      If \texttt{current} equals \texttt{expected}, the swap is successful and \texttt{update}
      is stored into the memory double word at the effective address. Otherwise, the swap has failed and the memory is not updated.
      The instruction return value is stored into the %1. It is true/false in case \texttt{boolcas} is true, or
      the \texttt{current} value in case \texttt{boolcas} is false.
      The effective address must be double word aligned (multiple of 8).
    execution: |
      new result1 = MEM.atomic_cas(address, 0xFF, boolcas | (coherency << 32), arguments.64[0], arguments.64[1], @1);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_atomic_cas
          (READ.address)
          (CONST.0xFF)
          (IOR
            (READ.boolcas)
            (SHL (READ.coherency) (CONST.32)))
          (READ.64[0].arguments)
          (READ.64[1].arguments)
          (METHOD.%1)))
  - ID: ACSWAPQ
    what: Atomic Compare and Swap Quadruple Word
    formats: [ LSU_ACSWAPQB, LSU_ACSWAPQB.O, LSU_ACSWAPQB.D ]
    properties: { '%0': MemoryEffect;MemorySize=16;MemoryAligned }
    description: >
      This instruction implements Compare-And-Swap (CAS) on memory quadruple word (128 bits).
      The %3 is interpreted as the concatenation of \texttt{update} (low 128 bits) and \texttt{expected} (high 128 bits).
      The memory double word at the effective address is read into \texttt{current}.
      If \texttt{current} equals \texttt{expected}, the swap is successful and \texttt{update}
      is stored into the memory double word at the effective address. Otherwise, the swap has failed and the memory is not updated.
      The instruction return value is stored into the %1. It is true/false in case \texttt{boolcas} is true, or
      the \texttt{current} value in case \texttt{boolcas} is false.
      The effective address must be quadruple word aligned (multiple of 16).
    execution: |
      new result1 = MEM.atomic_cas(address, 0xFFFF, boolcas | (coherency << 32), arguments.128[0], arguments.128[1], @1 << 1);
    behavior: |
      (WRITE.result1
        (APPLY.128.MEM_atomic_cas
          (READ.address)
          (CONST.0xFFFF)
          (IOR
            (READ.boolcas)
            (SHL (READ.coherency) (CONST.32)))
          (READ.128[0].arguments)
          (READ.128[1].arguments)
          (SHL (METHOD.%1) (CONST.1))))
  - ID: ALW
    what: Atomic Load Word
    formats: [ LSU_ALSB, LSU_ALSB.O, LSU_ALSB.D ]
    properties: { '%0': MemoryRead;MemorySize=4;MemoryAligned }
    description: >
      The %1 is atomically loaded with zero extension from the memory word starting at the effective address.
      This instruction is provided to directly operate on the last level of the memory hierarchy, which is
      typically a processor DDR or a cluster TCM, irrespective of the MMU DCP (Data Cache Policy) settings.
      The effective address must be word aligned (multiple of 4).
    execution: |
      new result1 = _ZX_32(MEM.atomic_load(address, 0xF, coherency << 32, @1));
    behavior: |
      (WRITE.result1
        (ZX.32
          (APPLY.32.MEM_atomic_load
            (READ.address)
            (CONST.0xF)
            (SHL (READ.coherency) (CONST.32))
            (METHOD.%1))))
  - ID: ALD
    what: Atomic Load Double Word
    formats: [ LSU_ALSB, LSU_ALSB.O, LSU_ALSB.D ]
    properties: { '%0': MemoryRead;MemorySize=8;MemoryAligned }
    description: >
      The %1 is atomically loaded from the memory double word starting at the effective address.
      This instruction is provided to directly operate on the last level of the memory hierarchy, which is
      typically a processor DDR or a cluster TCM, irrespective of the MMU DCP (Data Cache Policy) settings.
      The effective address must be double word aligned (multiple of 8).
    execution: |
      new result1 = MEM.atomic_load(address, 0xFF, coherency << 32, @1);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_atomic_load
          (READ.address)
          (CONST.0xFF)
          (SHL (READ.coherency) (CONST.32))
          (METHOD.%1)))
  - ID: ALCLRW
    what: Atomic Load and Clear Word
    formats: [ LSU_ALSB, LSU_ALSB.O, LSU_ALSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      The %1 is loaded from the memory word starting at the effective address.
      The value 0 is stored into the memory word starting at the effective address.
      This atomic instruction implements Test-and-Clear in memory. A zero
      word in memory means that the lock at the effective address is taken. Unlocking is
      achieved by storing a non-zero word at the effective address.
    execution: |
      new result1 = _ZX_32(MEM.atomic_swap(address, 0xF, (coherency << 32), 0, @1));
    behavior: |
      (WRITE.result1
        (ZX.32
          (APPLY.32.MEM_atomic_swap
            (READ.address)
            (CONST.0xF)
            (SHL (READ.coherency) (CONST.32))
            (CONST.0)
            (METHOD.%1))))
  - ID: ALCLRD
    what: Atomic Load and Clear Double Word
    formats: [ LSU_ALSB, LSU_ALSB.O, LSU_ALSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      The %1 is loaded from the memory double word starting at the effective address.
      The value 0 is stored into the memory double word starting at the effective address.
      This atomic instruction implements Test-and-Clear in memory. A zero
      double word in memory means that the lock at the effective address is taken. Unlocking is
      achieved by storing a non-zero double word at the effective address.
    execution: |
      new result1 = MEM.atomic_swap(address, 0xFF, (coherency << 32), 0, @1);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_atomic_swap
          (READ.address)
            (CONST.0xFF)
            (SHL (READ.coherency) (CONST.32))
            (CONST.0)
            (METHOD.%1)))
  - ID: ASW
    what: Atomic Store Word
    formats: [ LSU_ASSB, LSU_ASSB.O, LSU_ASSB.D ]
    properties: { '%0': MemorySize=4;MemoryAligned }
    description: >
      The %2 is atomically stored to the memory word starting at the effective address.
      This instruction is provided to directly operate on the last level of the memory hierarchy, which is
      typically a processor DDR or a cluster TCM, irrespective of the MMU DCP (Data Cache Policy) settings.
      The effective address must be word aligned (multiple of 4).
    execution: |
      stage E3:
      MEM.atomic_store(address, 0xF, (coherency << 32), argument2, @2);
    behavior: |
      (EFFECT.E3.MEM_atomic_store
        (READ.address)
        (CONST.0xF)
        (SHL (READ.coherency) (CONST.32))
        (READ.argument2)
        (METHOD.%2))
  - ID: ASD
    what: Atomic Store Double Word
    formats: [ LSU_ASSB, LSU_ASSB.O, LSU_ASSB.D ]
    properties: { '%0': MemorySize=8;MemoryAligned }
    description: >
      The %2 is atomically stored to the memory double word starting at the effective address.
      This instruction is provided to directly operate on the last level of the memory hierarchy, which is
      typically a processor DDR or a cluster TCM, irrespective of the MMU DCP (Data Cache Policy) settings.
      The effective address must be double word aligned (multiple of 8).
    execution: |
      stage E3:
      MEM.atomic_store(address, 0xFF, (coherency << 32), argument2, @2);
    behavior: |
      (EFFECT.E3.MEM_atomic_store
        (READ.address)
        (CONST.0xFF)
        (SHL (READ.coherency) (CONST.32))
        (READ.argument2)
        (METHOD.%2))
  - ID: ALADDW
    what: Atomic Load and Add Word
    formats: [ LSU_ALADDSB, LSU_ALADDSB.O, LSU_ALADDSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      This instruction implements atomic load-add-store on word.
      The word at effective address is added with the %2, and its previous value is returned into the %2.
      The effective address must be word aligned (multiple of 4).
    execution: |
      new result2 = _ZX_32(MEM.atomic_add(address, 0xF, (coherency << 32), argument2.32[0], @2));
    behavior: |
      (WRITE.result2
        (ZX.32
          (APPLY.32.MEM_atomic_add
            (READ.address)
            (CONST.0xF)
            (SHL (READ.coherency) (CONST.32))
            (READ.32[0].argument2)
            (METHOD.%2))))
  - ID: ALADDD
    what: Atomic Load and Add Double Word
    formats: [ LSU_ALADDSB, LSU_ALADDSB.O, LSU_ALADDSB.D ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      This instruction implements atomic load-add-store on double word.
      The double word at effective address is added with the %2, and its previous value is returned into the %2.
      The effective address must be double word aligned (multiple of 8).
    execution: |
      new result2 = MEM.atomic_add(address, 0xFF, (coherency << 32), argument2.64[0], @2);
    behavior: |
      (WRITE.result2
        (APPLY.64.MEM_atomic_add
          (READ.address)
          (CONST.0xFF)
          (SHL (READ.coherency) (CONST.32))
          (READ.64[0].argument2)
          (METHOD.%2)))
  - ID: DTOUCHL
    what: Data Cache Touch Line
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI ]
    properties: { '%0': MemoryTouch;MemorySize=64 }
    description: >
      The effective address is sent to the data cache, with request to prefetch the corresponding cache line.
    execution: |
      stage E3:
      MEM.dtouchl(address);
    behavior: |
      (EFFECT.E3.MEM_dtouchl (READ.address))
  - ID: DINVALL
    what: Data Cache Invalidate Line
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI ]
    description: >
      The effective address is sent to the data cache, with request to invalidate the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      MEM.dinvall(address);
    behavior: |
      (EFFECT.E3.MEM_dinvall (READ.address))
  - ID: DINVALSW
    what: Data Cache Invalidate Line by Set and Way
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXSW ]
    description: >
      The set and way are sent to the data cache, with request to invalidate the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      if (!dinvallsw_owner()) {
        _THROW(PRIVILEGE);
      } else {
        MEM.dinvallsw(set, way, cachelev);
      }
    behavior: |
      (IF
        (NOTL (TEST.dinvallsw_owner))
        (THROW.E3.PRIVILEGE)
        (EFFECT.E3.MEM_dinvallsw (READ.set) (READ.way) (READ.cachelev)))
  - ID: DPURGEL
    what: Data Cache Purge Line
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI ]
    description: >
      The effective address is sent to the data cache, with request to purge the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      MEM.dpurgel(address);
    behavior: |
      (EFFECT.E3.MEM_dpurgel (READ.address))
  - ID: DPURGESW
    what: Data Cache Purge Line by Set and Way
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXSW ]
    description: >
      The set and way are sent to the data cache, with request to purge the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      MEM.dpurgelsw(set, way, cachelev);
    behavior: |
      (EFFECT.E3.MEM_dpurgelsw (READ.set) (READ.way) (READ.cachelev))
  - ID: DFLUSHL
    what: Data Cache Flush Line
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI ]
    description: >
      The effective address is sent to the data cache, with request to evict the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      MEM.dflushl(address);
    behavior: |
      (EFFECT.E3.MEM_dflushl (READ.address))
  - ID: DFLUSHSW
    what: Data Cache Flush Line by Set and Way
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXSW ]
    description: >
      The set and way are sent to the data cache, with request to evict the corresponding cache line.
      Has no effects if the line is not cached.
    execution: |
      stage E3:
      MEM.dflushlsw(set, way, cachelev);
    behavior: |
      (EFFECT.E3.MEM_dflushlsw (READ.set) (READ.way) (READ.cachelev))
  - ID: I1INVALS
    what: Instruction Cache 1 Invalidate Set
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI ]
    description: >
      The effective address is sent to the instruction cache, with request to invalidate the corresponding L1 cache set.
      (All the cache lines with the same index.)
    execution: |
      stage E3:
      MEM.i1invals(address);
    behavior: |
      (EFFECT.E3.MEM_i1invals (READ.address))
  - ID: D1INVAL
    what: Data Cache 1 Invalidate
    formats: [ LSU_MCC ]
    description: >
      Request to invalidate the data cache. Cache contents is invalidated even if it is modified.
    execution: |
      stage E3:
      MEM.d1inval();
    behavior: |
      (EFFECT.E3.MEM_d1inval)
  - ID: I1INVAL
    what: Instruction Cache 1 Invalidate
    formats: [ LSU_MCC ]
    description: >
      Request to invalidate the instruction cache.
    execution: |
      stage E3:
      MEM.i1inval();
    behavior: |
      (EFFECT.E3.MEM_i1inval)
  - ID: FENCE
    what: Memory Fence
    formats: [ LSU_FENCE ]
    properties: { '%0': MemoryFence }
    description: >
      Ensures that all issued memory accesses are committed to memory. The %1 specifies for what types of access.
      FENCE.R instructions cannot pass earlier load instructions. FENCE.W instructions cannot pass earlier
      store, atomic and cache instructions. FENCE instructions produces the effects of FENCE.R, FENCE.W and in
      addition wait for the completion of outstanding prefetch instructions.
    execution: |
      stage E3:
      MEM.fence(accesses);
    behavior: |
      (EFFECT.E3.MEM_fence (READ.accesses))
  - ID: NOP
    what: No Operation
    formats: [ ALU_NOP ]
    description: >
      No effects except extending the current bundle by one syllable.
    execution: |
      ;
    behavior: |
      (SKIP)
  - ID: STSUD
    what: Subtract, Test and Shift Unsigned Double Words
    formats: [ ALU_DWRRS, ALU_DWRRS.M ]
    description: >
      The %2 is subtracted from the %3 If positive, the result is shifted left one bit and OR-ed with 0x1.
      Else, the %3 is shifted left one bit. The result is stored into the %1.
      This instruction is provided to support double word unsigned integer division.
    execution: |
      new result1 = _ZX_64(argument3) >= _ZX_64(argument2) ?
                    _ZX_64(argument3) - _ZX_64(argument2) << 1 | 1 :
                    _ZX_64(argument3) << 1;
    behavior: |
      (WRITE.result1
        (SELECT
          (GE
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))
          (IOR
            (SHL
              (SUB
                (ZX.64 (READ.argument3))
                (ZX.64 (READ.argument2)))
              (CONST.1))
            (CONST.1))
          (SHL
            (ZX.64 (READ.argument3))
            (CONST.1))))
  - ID: ADDD
    what: Add Double Word to Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The %3 and the %2 are added. The result is stored into the %1.
    execution: |
      new result1 = argument3 + argument2;
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (READ.argument2)))
  - ID: SBFD
    what: Subtract Double Word From Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%2': Right, '%3': Left }
    description: >
      The %2 is subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - argument2;
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (READ.argument2)))
  - ID: ABDD
    what: Absolute Difference of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    schedulings: [ ALU_TINY, ALU_TINY.X, ALU_TINY, ALU_TINY.X, ALU_TINY.Y ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result is stored into the %1.
    execution: |
      new result1 = _ABS(_SX_64(argument3) - _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: ABDUD
    what: Absolute Difference Unsigned of Double Words
    formats: [ ALU_DWRRS, ALU_DWRRS.M ]
    description: >
      The %2 is subtracted from the %3, assuming unsigned integers.
      The absolute value of the result is stored into the %1.
    execution: |
      new result1 = _ABS(_ZX_64(argument3) - _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: ABDSD
    what: Absolute Difference Saturated of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result is saturated and stored into the %1.
    execution: |
      new result1 = _SAT_64(_ABS(_SX_64(argument3) - _SX_64(argument2)));
    behavior: |
      (WRITE.result1
        (SAT.64
          (ABS
            (SUB
              (SX.64 (READ.argument3))
              (SX.64 (READ.argument2))))))
  - ID: MIND
    what: Minimum of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The minimum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MIN(_SX_64(argument3), _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MINUD
    what: Minimum of Unsigned Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The unsigned minimum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MIN(_ZX_64(argument3), _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: MAXD
    what: Maximum of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The maximum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MAX(_SX_64(argument3), _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MAXUD
    what: Maximum of Unsigned Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The unsigned maximum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MAX(_ZX_64(argument3), _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: ANDD
    what: Bitwise And Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (READ.argument3)))
  - ID: NANDD
    what: Bitwise Not And Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 & argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (AND
            (READ.argument2)
            (READ.argument3))))
  - ID: IORD
    what: Bitwise Inclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NIORD
    what: Bitwise Not Inclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 | argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (IOR
            (READ.argument2)
            (READ.argument3))))
  - ID: EORD
    what: Bitwise Exclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 ^ argument3;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NEORD
    what: Bitwise Not Exclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 ^ argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (XOR
            (READ.argument2)
            (READ.argument3))))
  - ID: ANDND
    what: Bitwise And with Not Operand Between Double Words
    properties: { '%0': Bitwise }
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      Bitwise and of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: IORND
    what: Bitwise Inclusive Or with Not Operand Between Double Words
    properties: { '%0': Bitwise }
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      Bitwise inclusive or of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: SBMM8D
    what: Swapped Bit Matrix Multiplication 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    schedulings: [ ALU_TINY, ALU_TINY.X, ALU_TINY, ALU_TINY.X, ALU_TINY.Y ]
    description: >
      The %3 interpreted as a 8$\times$8 bit matrix is multiplied by the %2 interpreted as a 8$\times$8 bit matrix.
      The result is stored into the %1.
    execution: &executionSBMM8 |
      new result1 = _BMM_8(_ZX_64(argument3), _ZX_64(argument2));
    behavior: &behaviorSBMM8 |
      (WRITE.result1
        (APPLY.64._BMM_8
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: SBMMT8D
    what: Swapped Bit Matrix Multiplication Transposed 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    schedulings: [ ALU_TINY, ALU_TINY.X, ALU_TINY, ALU_TINY.X, ALU_TINY.Y ]
    description: >
      The %3 interpreted as a 8$\times$8 bit matrix is multiplied by the %2 interpreted as a 8$\times$8 bit matrix.
      The result is transposed, and stored into the %1.
    execution: &executionSBMMT8 |
      new result1 = _BMT_8(_BMM_8(_ZX_64(argument3), _ZX_64(argument2)));
    behavior: &behaviorSBMMT8 |
      (WRITE.result1
        (APPLY.64._BMT_8
          (APPLY.64._BMM_8
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: ADDSD
    what: Add Saturated Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are added with 64-bit saturation.
    execution: |
      new result1 = _SAT_64(_SX_64(argument3) + _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SAT.64
          (ADD
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: SBFSD
    what: Subtract Saturated Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is subtracted from the %3 with 64-bit saturation.
    execution: |
      new result1 = _SAT_64(_SX_64(argument3) - _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SAT.64
          (SUB
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: ADDUSD
    what: Add Unsigned Saturated Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are added with 64-bit unsigned saturation.
    execution: |
      new result1 = _SATU_64(_ZX_64(argument3) + _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (SATU.64
          (ADD
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: SBFUSD
    what: Subtract Unsigned Saturated Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is subtracted from the %3 with 64-bit unsigned saturation.
    execution: |
      new result1 = _SATU_64(_ZX_64(argument3) - _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (SATU.64
          (SUB
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: ADDX2D
    what: Add Double Word to Double Word Times 2
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: ADDX4D
    what: Add Double Word to Double Word Times 4
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: ADDX8D
    what: Add Double Word to Double Word Times 8
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: ADDX16D
    what: Add Double Word to Double Word Times 16
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: ADDX32D
    what: Add Double Word to Double Word Times 32
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by five bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 5);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.5))))
  - ID: ADDX64D
    what: Add Double Word to Double Word Times 64
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by six bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 6);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.6))))
  - ID: SBFX2D
    what: Subtract Double Word Times 2 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: SBFX4D
    what: Subtract Double Word Times 4 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: SBFX8D
    what: Subtract Double Word Times 8 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: SBFX16D
    what: Subtract Double Word Times 16 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: SBFX32D
    what: Subtract Double Word Times 32 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by five bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 5);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.5))))
  - ID: SBFX64D
    what: Subtract Double Word Times 64 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by six bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 6);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.6))))
  - ID: ADDWD
    what: Add Word to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: SBFWD
    what: Subtract Word from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: ADDUWD
    what: Add Unsigned Word to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + argument2.32[0];
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (READ.32[0].argument2)))
  - ID: SBFUWD
    what: Subtract Unsigned Word from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - argument2.32[0];
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (READ.32[0].argument2)))
  - ID: LANDD
    what: Logical And of Double Words
    formats: [ ALU_DSWRR ]
    description: >
      The %3 and the %2 are converted to booleans, which are AND-ed. The result is stored into the %1.
    execution: |
      new result1 = (_ZX_64(argument3) != 0) & (_ZX_64(argument2) != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (ANDL
            (I2B
              (ZX.64 (READ.argument3)))
            (I2B
              (ZX.64 (READ.argument2))))))
  - ID: LNANDD
    what: Logical Not And of Double Words
    formats: [ ALU_DSWRR ]
    description: >
      The %3 and the %2 are converted to booleans, which are NOT AND-ed. The result is stored into the %1.
    execution: |
      new result1 = !((_ZX_64(argument3) != 0) & (_ZX_64(argument2) != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (ANDL
              (I2B
                (ZX.64 (READ.argument3)))
              (I2B
                (ZX.64 (READ.argument2)))))))
  - ID: LIORD
    what: Logical Or of Double Words
    formats: [ ALU_DSWRR ]
    description: >
      The %3 and the %2 are converted to booleans, which are OR-ed. The result is stored into the %1.
    execution: |
      new result1 = (_ZX_64(argument3) != 0) | (_ZX_64(argument2) != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (IORL
            (I2B
              (ZX.64 (READ.argument3)))
            (I2B
              (ZX.64 (READ.argument2))))))
  - ID: LNIORD
    what: Logical Not Or of Double Words
    formats: [ ALU_DSWRR ]
    description: >
      The %3 and the %2 are converted to booleans, which are not OR-ed. The result is stored into the %1.
    execution: |
      new result1 = !((_ZX_64(argument3) != 0) | (_ZX_64(argument2) != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (IORL
              (I2B
                (ZX.64 (READ.argument3)))
              (I2B
                (ZX.64 (READ.argument2)))))))
  - ID: STSUW
    what: Subtract, Test and Shift Unsigned Word
    formats: [ ALU_WRRSW, ALU_WRRSW.W ]
    description: >
      The %2 is subtracted from the %3. If positive, the result is shifted left one bit and OR-ed with 0x1.
      Else, the %3 is shifted left one bit. The result with the 32 upper bits cleared is stored into the %1.
      This instruction is provided to support unsigned integer division.
    execution: |
      new result1 = argument3.32[0] >= argument2.32[0] ?
                    argument3.32[0] - argument2.32[0] << 1 | 1 :
                    argument3.32[0] << 1;
    behavior: |
      (WRITE.result1
        (SELECT
          (GE
            (READ.32[0].argument3)
            (READ.32[0].argument2))
          (IOR
            (SHL
              (SUB
                (READ.32[0].argument3)
                (READ.32[0].argument2))
              (CONST.1))
            (CONST.1))
          (SHL
            (READ.32[0].argument3)
            (CONST.1))))
  - ID: STSUWP
    what: Subtract, Test and Shift Unsigned Word Pair
    formats: [ ALU_WPWRRS, ALU_WPWRRS.M ]
    description: >
      The %2 interpreted as a word pair is subtracted from the %3 interpreted as a word pair .
      For each result, if the difference is positive it is shifted left one bit and OR-ed with 0x1.
      Else, the result is the corresponding word of the %3 is shifted left one bit.
      The two resulting word are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(argument3.32[i]) >= _ZX_32(argument2.32[i]) ?
                        _ZX_32(argument3.32[i]) - _ZX_32(argument2.32[i]) << 1 | 1 :
                        _ZX_32(argument3.32[i]) << 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SELECT
            (GE
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2)))
            (IOR
              (SHL
                (SUB
                  (ZX.32 (READ.32[(INDEX.I)].argument3))
                  (ZX.32 (READ.32[(INDEX.I)].argument2)))
                (CONST.1))
              (CONST.1))
            (SHL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (CONST.1)))))
  - ID: STSUHQ
    what: Subtract, Test and Shift Unsigned Half Word Quadruple
    formats: [ ALU_HQWRRS, ALU_HQWRRS.M ]
    description: >
      The %2 interpreted as a half word quadruple is subtracted from the %3 interpreted as a half word quadruple .
      For each result, if the difference is positive it is shifted left one bit and OR-ed with 0x1.
      Else, the result is the corresponding half word of the %3 is shifted left one bit.
      The four resulting half word are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _ZX_16(argument3.16[i]) >= _ZX_16(argument2.16[i]) ?
                        _ZX_16(argument3.16[i]) - _ZX_16(argument2.16[i]) << 1 | 1 :
                        _ZX_16(argument3.16[i]) << 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SELECT
            (GE
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2)))
            (IOR
              (SHL
                (SUB
                  (ZX.16 (READ.16[(INDEX.I)].argument3))
                  (ZX.16 (READ.16[(INDEX.I)].argument2)))
                (CONST.1))
              (CONST.1))
            (SHL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (CONST.1)))))
  - ID: ADDW
    what: Add Word to Word
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The %3 and the %2 are added. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + argument2;
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (READ.argument2)))
  - ID: SBFW
    what: Subtract Word from Word
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The %2 is subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - argument2;
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (READ.argument2)))
  - ID: ABDW
    what: Absolute Difference of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    schedulings: [ ALU_TINY, ALU_TINY.X, ALU_TINY ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ABS(_SX_32(argument3) - _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: ABDUW
    what: Absolute Difference Unsigned of Words
    formats: [ ALU_WRRSW, ALU_WRRSW.W ]
    description: >
      The %2 is subtracted from the %3, assuming unsigned integers.
      The absolute value of the result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ABS(_ZX_32(argument3) - _ZX_32(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: ABDSW
    what: Absolute Difference Saturated of Words
    formats: [ ALU_WWRR0, ALU_WWRR0.W ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result is saturated and stored into the %1 32 upper bits cleared.
    execution: |
      new result1 = _SAT_32(_ABS(_SX_32(argument3) - _SX_32(argument2)));
    behavior: |
      (WRITE.result1
        (SAT.32
          (ABS
            (SUB
              (SX.32 (READ.argument3))
              (SX.32 (READ.argument2))))))
  - ID: MINW
    what: Minimum of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The minimum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MIN(_SX_32(argument3), _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MINUW
    what: Minimum of Unsigned Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The unsigned minimum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MIN(argument3.32[0], argument2.32[0]);
    behavior: |
      (WRITE.result1
        (MIN
          (READ.32[0].argument3)
          (READ.32[0].argument2)))
  - ID: MAXW
    what: Maximum of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The maximum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MAX(_SX_32(argument3), _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MAXUW
    what: Maximum of Unsigned Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The unsigned maximum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MAX(argument3.32[0], argument2.32[0]);
    behavior: |
      (WRITE.result1
        (MAX
          (READ.32[0].argument3)
          (READ.32[0].argument2)))
  - ID: ANDW
    what: Bitwise And Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (READ.argument3)))
  - ID: NANDW
    what: Bitwise Not And Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise and of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 & argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (AND
            (READ.argument2)
            (READ.argument3))))
  - ID: IORW
    what: Bitwise Inclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NIORW
    what: Bitwise Not Inclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise inclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 | argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (IOR
            (READ.argument2)
            (READ.argument3))))
  - ID: EORW
    what: Bitwise Exclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise exclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 ^ argument3;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NEORW
    what: Bitwise Not Exclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise exclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 ^ argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (XOR
            (READ.argument2)
            (READ.argument3))))
  - ID: ANDNW
    what: Bitwise And with Not Operand Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of not the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: IORNW
    what: Bitwise Inclusive Or with Not Operand Between Double Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of not the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: ADDSW
    what: Add Saturated Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added with 32-bit saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SAT_32(_SX_32(argument3) + _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (SAT.32
          (ADD
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: SBFSW
    what: Subtract Saturated Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is subtracted from the %3 with 32-bit saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SAT_32(_SX_32(argument3) - _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (SAT.32
          (SUB
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: ADDUSW
    what: Add Unsigned Saturated Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added with 32-bit unsigned saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SATU_32(_ZX_32(argument3) + _ZX_32(argument2));
    behavior: |
      (WRITE.result1
        (SATU.32
          (ADD
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: SBFUSW
    what: Subtract Unsigned Saturated Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is subtracted from the %3 with 32-bit unsigned saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SATU_32(_ZX_32(argument3) - _ZX_32(argument2));
    behavior: |
      (WRITE.result1
        (SATU.32
          (SUB
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: ADDX2W
    what: Add Word to Word Times 2
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by one bit and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: ADDX4W
    what: Add Word to Word Times 4
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by two bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: ADDX8W
    what: Add Word to Word Times 8
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by three bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: ADDX16W
    what: Add Word to Word Times 16
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by four bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: ADDX32W
    what: Add Word to Word Times 32
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by five bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 5);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.5))))
  - ID: ADDX64W
    what: Add Word to Word Times 64
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by six bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 6);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.6))))
  - ID: SBFX2W
    what: Subtract Word Times 2 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by one bit and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: SBFX4W
    what: Subtract Word Times 4 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by two bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: SBFX8W
    what: Subtract Word Times 8 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by three bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: SBFX16W
    what: Subtract Word Times 16 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by four bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: SBFX32W
    what: Subtract Word Times 32 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by five bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 5);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.5))))
  - ID: SBFX64W
    what: Subtract Word Times 64 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by six bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 6);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.6))))
  - ID: AVGW
    what: Average of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are added. The result is shifted right arithmetic one bit and stored into the %1.
    execution: |
      new result1 = (_SX_32(argument3) + _SX_32(argument2)) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))
          (CONST.1)))
  - ID: AVGUW
    what: Average of Unsigned Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are added. The result is shifted right logical one bit and stored into the %1.
    execution: |
      new result1 = (argument3.32[0] + argument2.32[0]) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (READ.32[0].argument3)
            (READ.32[0].argument2))
          (CONST.1)))
  - ID: AVGRW
    what: Average Rounded of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are added. The result is incremented, shifted right arithmetic one bit and stored into the %1.
    execution: |
      new result1 = (_SX_32(argument2) + _SX_32(argument3) + 1) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (ADD
              (SX.32 (READ.argument3))
              (SX.32 (READ.argument2)))
            (CONST.1))
          (CONST.1)))
  - ID: AVGRUW
    what: Average Rounded of Unsigned Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are added. The result is incremented, shifted right logical one bit and stored into the %1.
    execution: |
      new result1 = (argument2.32[0] + argument3.32[0] + 1) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (ADD
              (READ.32[0].argument3)
              (READ.32[0].argument2))
             (CONST.1))
          (CONST.1)))
  - ID: LANDW
    what: Logical And of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are AND-ed. The result is stored into the %1.
    execution: |
      new result1 = (argument3.32[0] != 0) & (argument2.32[0] != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (ANDL
            (I2B
              (READ.32[0].argument3))
            (I2B
              (READ.32[0].argument2)))))
  - ID: LNANDW
    what: Logical Not And of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are NOT AND-ed. The result is stored into the %1.
    execution: |
      new result1 = !((argument3.32[0] != 0) & (argument2.32[0] != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (ANDL
              (I2B
                (READ.32[0].argument3))
              (I2B
                (READ.32[0].argument2))))))
  - ID: LIORW
    what: Logical Or of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are OR-ed. The result is stored into the %1.
    execution: |
      new result1 = (argument3.32[0] != 0) | (argument2.32[0] != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (IORL
            (I2B
              (READ.32[0].argument3))
            (I2B
              (READ.32[0].argument2)))))
  - ID: LNIORW
    what: Logical Not Or of Words
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are not OR-ed. The result is stored into the %1.
    execution: |
      new result1 = !((argument3.32[0] != 0) | (argument2.32[0] != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (IORL
              (I2B
                (READ.32[0].argument3))
              (I2B
                (READ.32[0].argument2))))))
  - ID: ADDWP
    what: Add Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument3.32[i] + argument2.32[i];
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument3)
            (READ.32[(INDEX.I)].argument2))))
  - ID: SBFWP
    what: Subtract Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument3.32[i] - argument2.32[i];
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument3)
            (READ.32[(INDEX.I)].argument2))))
  - ID: ABDWP
    what: Absolute Difference Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are subtracted from the %3 words. The absolute value of the
      two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ABS(_SX_32(argument3.32[i]) - _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ABS
            (SUB
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: ABDUWP
    what: Absolute Difference Unsigned Words Packed
    formats: [ ALU_WPWRRS, ALU_WPWRRS.M ]
    description: >
      The %2 and the %3 are considered as two unsigned words packed into 64 bits.
      The %2 words are subtracted from the %3 words. The absolute value of the
      two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ABS(_ZX_32(argument3.32[i]) - _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ABS
            (SUB
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: ABDSWP
    what: Absolute Difference Saturated of Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are subtracted from the %3 words. The absolute value of the
      two resulting words are saturated, packed into 64 bits and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SAT_32(_ABS(_SX_32(argument3.32[i]) - _SX_32(argument2.32[i])));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SAT.32
            (ABS
              (SUB
                (SX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))))))
  - ID: MINWP
    what: Minimum of Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The minimum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MIN(_SX_32(argument3.32[i]), _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MIN
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MINUWP
    what: Minimum of Unsigned Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The unsigned minimum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MIN(_ZX_32(argument3.32[i]), _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MIN
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MAXWP
    what: Maximum of Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The maximum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MAX(_SX_32(argument3.32[i]), _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MAX
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MAXUWP
    what: Maximum of Unsigned Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The unsigned maximum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MAX(_ZX_32(argument3.32[i]), _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MAX
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: ANDRWPD
    what: Bitwise AND Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The bitwise AND of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = argument2.32[0] & argument2.32[1];
    behavior:
      (WRITE.result1
        (AND (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: IORRWPD
    what: Bitwise OR Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The bitwise OR of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = argument2.32[0] | argument2.32[1];
    behavior:
      (WRITE.result1
        (IOR (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: EORRWPD
    what: Bitwise Exclusive OR Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The bitwise XOR of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = argument2.32[0] ^ argument2.32[1];
    behavior:
      (WRITE.result1
        (XOR (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: MINRWPD
    what: Minimum Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The minimum of these two sign-extended words is computed and stored into the %1.
    execution: |
      new result1 = _MIN(_SX_32(argument2.32[0]), _SX_32(argument2.32[1]));
    behavior:
      (WRITE.result1
        (MIN (SX.32 (READ.32[0].argument2)) (SX.32 (READ.32[1].argument2))))
  - ID: MAXRWPD
    what: Maximum Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The maximum of these two sign-extended words is computed and stored into the %1.
    execution: |
      new result1 = _MAX(_SX_32(argument2.32[0]), _SX_32(argument2.32[1]));
    behavior:
      (WRITE.result1
        (MAX (SX.32 (READ.32[0].argument2)) (SX.32 (READ.32[1].argument2))))
  - ID: ADDRWPD
    what: Add Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The sum of these two sign-extended words is computed and stored into the %1.
    execution: |
      new result1 = _SX_32(argument2.32[0]) + _SX_32(argument2.32[1]);
    behavior:
      (WRITE.result1
        (ADD (SX.32 (READ.32[0].argument2)) (SX.32 (READ.32[1].argument2))))
  - ID: MINURWPD
    what: Minimum Unsigned Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The minimum of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = _MIN(argument2.32[0], argument2.32[1]);
    behavior:
      (WRITE.result1
        (MIN (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: MAXURWPD
    what: Maximum Unsigned Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The maximum of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = _MAX(argument2.32[0], argument2.32[1]);
    behavior:
      (WRITE.result1
        (MAX (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: ADDURWPD
    what: Add Unsigned Reduce Word Pair to Double Word
    formats: [ ALU_WPRWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The sum of these two zero-extended words is computed and stored into the %1.
    execution: |
      new result1 = argument2.32[0] + argument2.32[1];
    behavior:
      (WRITE.result1
        (ADD (READ.32[0].argument2) (READ.32[1].argument2)))
  - ID: ANDRHQD
    what: Bitwise AND Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The bitwise AND of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = argument2.16[0] & argument2.16[1];
      new result1_m = argument2.16[2] & argument2.16[3];
      new result1 = result1_l & result1_m;
    behavior:
      (SEQ
        (WRITE.result1_l
          (AND (READ.16[0].argument2) (READ.16[1].argument2)))
        (WRITE.result1_m
          (AND (READ.16[2].argument2) (READ.16[3].argument2)))
        (WRITE.result1
          (AND (READ.result1_l) (READ.result1_m))))
  - ID: IORRHQD
    what: Bitwise OR Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The bitwise OR of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = argument2.16[0] | argument2.16[1];
      new result1_m = argument2.16[2] | argument2.16[3];
      new result1 = result1_l | result1_m;
    behavior:
      (SEQ
        (WRITE.result1_l
          (IOR (READ.16[0].argument2) (READ.16[1].argument2)))
        (WRITE.result1_m
          (IOR (READ.16[2].argument2) (READ.16[3].argument2)))
        (WRITE.result1
          (IOR (READ.result1_l) (READ.result1_m))))
  - ID: EORRHQD
    what: Bitwise Exclusive OR Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The bitwise XOR of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = argument2.16[0] ^ argument2.16[1];
      new result1_m = argument2.16[2] ^ argument2.16[3];
      new result1 = result1_l ^ result1_m;
    behavior:
      (SEQ
        (WRITE.result1_l
          (XOR (READ.16[0].argument2) (READ.16[1].argument2)))
        (WRITE.result1_m
          (XOR (READ.16[2].argument2) (READ.16[3].argument2)))
        (WRITE.result1
          (XOR (READ.result1_l) (READ.result1_m))))
  - ID: MINRHQD
    what: Minimum Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The minimum of these four sign-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _MIN(_SX_16(argument2.16[0]), _SX_16(argument2.16[1]));
      new result1_m = _MIN(_SX_16(argument2.16[2]), _SX_16(argument2.16[3]));
      new result1 = _MIN(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_l
          (MIN (SX.16 (READ.16[0].argument2)) (SX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (MIN (SX.16 (READ.16[2].argument2)) (SX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (MIN (READ.result1_l) (READ.result1_m))))
  - ID: MAXRHQD
    what: Maximum Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The maximum of these four sign-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _MAX(_SX_16(argument2.16[0]), _SX_16(argument2.16[1]));
      new result1_m = _MAX(_SX_16(argument2.16[2]), _SX_16(argument2.16[3]));
      new result1 = _MAX(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_l
          (MAX (SX.16 (READ.16[0].argument2)) (SX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (MAX (SX.16 (READ.16[2].argument2)) (SX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (MAX (READ.result1_l) (READ.result1_m))))
  - ID: ADDRHQD
    what: Add Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The sum of these four sign-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _SX_16(argument2.16[0]) + _SX_16(argument2.16[1]);
      new result1_m = _SX_16(argument2.16[2]) + _SX_16(argument2.16[3]);
      new result1 = result1_l + result1_m;
    behavior:
      (SEQ
        (WRITE.result1_l
          (ADD (SX.16 (READ.16[0].argument2)) (SX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (ADD (SX.16 (READ.16[2].argument2)) (SX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (ADD (READ.result1_l) (READ.result1_m))))
  - ID: MINURHQD
    what: Minimum Unsigned Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The minimum of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _MIN(_ZX_16(argument2.16[0]), _ZX_16(argument2.16[1]));
      new result1_m = _MIN(_ZX_16(argument2.16[2]), _ZX_16(argument2.16[3]));
      new result1 = _MIN(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_l
          (MIN (ZX.16 (READ.16[0].argument2)) (ZX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (MIN (ZX.16 (READ.16[2].argument2)) (ZX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (MIN (READ.result1_l) (READ.result1_m))))
  - ID: MAXURHQD
    what: Maximum Unsigned Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The maximum of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _MAX(_ZX_16(argument2.16[0]), _ZX_16(argument2.16[1]));
      new result1_m = _MAX(_ZX_16(argument2.16[2]), _ZX_16(argument2.16[3]));
      new result1 = _MAX(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_l
          (MAX (ZX.16 (READ.16[0].argument2)) (ZX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (MAX (ZX.16 (READ.16[2].argument2)) (ZX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (MAX (READ.result1_l) (READ.result1_m))))
  - ID: ADDURHQD
    what: Add Unsigned Reduce Half Word Quadruple to Double Word
    formats: [ ALU_HQRWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The sum of these four zero-extended half words is computed and stored into the %1.
    execution: |
      new result1_l = _ZX_16(argument2.16[0]) + _ZX_16(argument2.16[1]);
      new result1_m = _ZX_16(argument2.16[2]) + _ZX_16(argument2.16[3]);
      new result1 = result1_l + result1_m;
    behavior:
      (SEQ
        (WRITE.result1_l
          (ADD (ZX.16 (READ.16[0].argument2)) (ZX.16 (READ.16[1].argument2))))
        (WRITE.result1_m
          (ADD (ZX.16 (READ.16[2].argument2)) (ZX.16 (READ.16[3].argument2))))
        (WRITE.result1
          (ADD (READ.result1_l) (READ.result1_m))))
  - ID: ANDRBOD
    what: Bitwise AND Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The bitwise AND of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = argument2.8[0] & argument2.8[1];
      new result1_y = argument2.8[2] & argument2.8[3];
      new result1_z = argument2.8[4] & argument2.8[5];
      new result1_t = argument2.8[6] & argument2.8[7];
      new result1_l = result1_x & result1_y;
      new result1_m = result1_z & result1_t;
      new result1 = result1_l & result1_m;
    behavior:
      (SEQ
        (WRITE.result1_x
          (AND (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (AND (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (AND (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (AND (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (AND (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (AND (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (AND (READ.result1_l) (READ.result1_m))))
  - ID: IORRBOD
    what: Bitwise OR Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The bitwise OR of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = argument2.8[0] | argument2.8[1];
      new result1_y = argument2.8[2] | argument2.8[3];
      new result1_z = argument2.8[4] | argument2.8[5];
      new result1_t = argument2.8[6] | argument2.8[7];
      new result1_l = result1_x | result1_y;
      new result1_m = result1_z | result1_t;
      new result1 = result1_l | result1_m;
    behavior:
      (SEQ
        (WRITE.result1_x
          (IOR (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (IOR (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (IOR (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (IOR (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (IOR (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (IOR (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (IOR (READ.result1_l) (READ.result1_m))))
  - ID: EORRBOD
    what: Bitwise Exclusive OR Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The bitwise XOR of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = argument2.8[0] ^ argument2.8[1];
      new result1_y = argument2.8[2] ^ argument2.8[3];
      new result1_z = argument2.8[4] ^ argument2.8[5];
      new result1_t = argument2.8[6] ^ argument2.8[7];
      new result1_l = result1_x ^ result1_y;
      new result1_m = result1_z ^ result1_t;
      new result1 = result1_l ^ result1_m;
    behavior:
      (SEQ
        (WRITE.result1_x
          (XOR (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (XOR (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (XOR (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (XOR (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (XOR (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (XOR (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (XOR (READ.result1_l) (READ.result1_m))))
  - ID: MINRBOD
    what: Minimum Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The minimum of these eight sign-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = _MIN(_SX_8(argument2.8[0]), _SX_8(argument2.8[1]));
      new result1_y = _MIN(_SX_8(argument2.8[2]), _SX_8(argument2.8[3]));
      new result1_z = _MIN(_SX_8(argument2.8[4]), _SX_8(argument2.8[5]));
      new result1_t = _MIN(_SX_8(argument2.8[6]), _SX_8(argument2.8[7]));
      new result1_l = _MIN(result1_x, result1_y);
      new result1_m = _MIN(result1_z, result1_t);
      new result1 = _MIN(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_x
          (MIN (SX.8 (READ.8[0].argument2)) (SX.8 (READ.8[1].argument2))))
        (WRITE.result1_y
          (MIN (SX.8 (READ.8[2].argument2)) (SX.8 (READ.8[3].argument2))))
        (WRITE.result1_z
          (MIN (SX.8 (READ.8[4].argument2)) (SX.8 (READ.8[5].argument2))))
        (WRITE.result1_t
          (MIN (SX.8 (READ.8[6].argument2)) (SX.8 (READ.8[7].argument2))))
        (WRITE.result1_l
          (MIN (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (MIN (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (MIN (READ.result1_l) (READ.result1_m))))
  - ID: MAXRBOD
    what: Maximum Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The maximum of these eight sign-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = _MAX(_SX_8(argument2.8[0]), _SX_8(argument2.8[1]));
      new result1_y = _MAX(_SX_8(argument2.8[2]), _SX_8(argument2.8[3]));
      new result1_z = _MAX(_SX_8(argument2.8[4]), _SX_8(argument2.8[5]));
      new result1_t = _MAX(_SX_8(argument2.8[6]), _SX_8(argument2.8[7]));
      new result1_l = _MAX(result1_x, result1_y);
      new result1_m = _MAX(result1_z, result1_t);
      new result1 = _MAX(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_x
          (MAX (SX.8 (READ.8[0].argument2)) (SX.8 (READ.8[1].argument2))))
        (WRITE.result1_y
          (MAX (SX.8 (READ.8[2].argument2)) (SX.8 (READ.8[3].argument2))))
        (WRITE.result1_z
          (MAX (SX.8 (READ.8[4].argument2)) (SX.8 (READ.8[5].argument2))))
        (WRITE.result1_t
          (MAX (SX.8 (READ.8[6].argument2)) (SX.8 (READ.8[7].argument2))))
        (WRITE.result1_l
          (MAX (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (MAX (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (MAX (READ.result1_l) (READ.result1_m))))
  - ID: ADDRBOD
    what: Add Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The sum of these eight sign-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = _SX_8(argument2.8[0]) + _SX_8(argument2.8[1]);
      new result1_y = _SX_8(argument2.8[2]) + _SX_8(argument2.8[3]);
      new result1_z = _SX_8(argument2.8[4]) + _SX_8(argument2.8[5]);
      new result1_t = _SX_8(argument2.8[6]) + _SX_8(argument2.8[7]);
      new result1_l = result1_x + result1_y;
      new result1_m = result1_z + result1_t;
      new result1 = result1_l + result1_m;
    behavior:
      (SEQ
        (WRITE.result1_x
          (ADD (SX.8 (READ.8[0].argument2)) (SX.8 (READ.8[1].argument2))))
        (WRITE.result1_y
          (ADD (SX.8 (READ.8[2].argument2)) (SX.8 (READ.8[3].argument2))))
        (WRITE.result1_z
          (ADD (SX.8 (READ.8[4].argument2)) (SX.8 (READ.8[5].argument2))))
        (WRITE.result1_t
          (ADD (SX.8 (READ.8[6].argument2)) (SX.8 (READ.8[7].argument2))))
        (WRITE.result1_l
          (ADD (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (ADD (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (ADD (READ.result1_l) (READ.result1_m))))
  - ID: MINURBOD
    what: Minimum Unsigned Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The minimum of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = _MIN(argument2.8[0], argument2.8[1]);
      new result1_y = _MIN(argument2.8[2], argument2.8[3]);
      new result1_z = _MIN(argument2.8[4], argument2.8[5]);
      new result1_t = _MIN(argument2.8[6], argument2.8[7]);
      new result1_l = _MIN(result1_x, result1_y);
      new result1_m = _MIN(result1_z, result1_t);
      new result1 = _MIN(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_x
          (MIN (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (MIN (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (MIN (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (MIN (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (MIN (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (MIN (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (MIN (READ.result1_l) (READ.result1_m))))
  - ID: MAXURBOD
    what: Maximum Unsigned Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The maximum of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = _MAX(argument2.8[0], argument2.8[1]);
      new result1_y = _MAX(argument2.8[2], argument2.8[3]);
      new result1_z = _MAX(argument2.8[4], argument2.8[5]);
      new result1_t = _MAX(argument2.8[6], argument2.8[7]);
      new result1_l = _MAX(result1_x, result1_y);
      new result1_m = _MAX(result1_z, result1_t);
      new result1 = _MAX(result1_l, result1_m);
    behavior:
      (SEQ
        (WRITE.result1_x
          (MAX (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (MAX (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (MAX (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (MAX (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (MAX (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (MAX (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (MAX (READ.result1_l) (READ.result1_m))))
  - ID: ADDURBOD
    what: Add Unsigned Reduce Byte Octuple to Double Word
    formats: [ ALU_BORWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The sum of these eight zero-extended bytes is computed and stored into the %1.
    execution: |
      new result1_x = argument2.8[0] + argument2.8[1];
      new result1_y = argument2.8[2] + argument2.8[3];
      new result1_z = argument2.8[4] + argument2.8[5];
      new result1_t = argument2.8[6] + argument2.8[7];
      new result1_l = result1_x + result1_y;
      new result1_m = result1_z + result1_t;
      new result1 = result1_l + result1_m;
    behavior:
      (SEQ
        (WRITE.result1_x
          (ADD (READ.8[0].argument2) (READ.8[1].argument2)))
        (WRITE.result1_y
          (ADD (READ.8[2].argument2) (READ.8[3].argument2)))
        (WRITE.result1_z
          (ADD (READ.8[4].argument2) (READ.8[5].argument2)))
        (WRITE.result1_t
          (ADD (READ.8[6].argument2) (READ.8[7].argument2)))
        (WRITE.result1_l
          (ADD (READ.result1_x) (READ.result1_y)))
        (WRITE.result1_m
          (ADD (READ.result1_z) (READ.result1_t)))
        (WRITE.result1
          (ADD (READ.result1_l) (READ.result1_m))))
  - ID: ADDSWP
    what: Add Saturated Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added with saturation to 32 bits.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument3.32[i]) + _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SAT.32
            (ADD
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: SBFSWP
    what: Subtract Saturated Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are subtracted with saturation to 32 bits from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument3.32[i]) - _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SAT.32
            (SUB
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: ADDUSWP
    what: Add Unsigned Saturated Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two unsigned words packed into 64 bits.
      The %3 words and the %2 words are added with unsigned saturation to 32 bits.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SATU_32(_ZX_32(argument3.32[i]) + _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SATU.32
            (ADD
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: SBFUSWP
    what: Subtract Unsigned Saturated Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two unsigned words packed into 64 bits.
      The %2 words are subtracted with unsigned saturation to 32 bits from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SATU_32(_ZX_32(argument3.32[i]) - _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SATU.32
            (SUB
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: ADDX2WP
    what: Add Integer to Integer Times 2 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by one bit and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: ADDX4WP
    what: Add Integer to Integer Times 4 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by two bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: ADDX8WP
    what: Add Integer to Integer Times 8 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by three bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: ADDX16WP
    what: Add Integer to Integer Times 16 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by four bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: SBFX2WP
    what: Subtract Integer to Integer Times 2 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by one bit and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: SBFX4WP
    what: Subtract Integer to Integer Times 4 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by two bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: SBFX8WP
    what: Subtract Integer to Integer Times 8 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by three bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: SBFX16WP
    what: Subtract Integer to Integer Times 16 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by four bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: AVGWP
    what: Average of Words Packed
    formats: [ ALU_WPSWRR, ALU_WPSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is shifted right arithmetic one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_SX_32(argument3.32[i]) + _SX_32(argument2.32[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGUWP
    what: Average Unsigned of Words Packed
    formats: [ ALU_WPSWRR, ALU_WPSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is shifted right logical one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_ZX_32(argument3.32[i]) + _ZX_32(argument2.32[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGRWP
    what: Average Rounded of Words Packed
    formats: [ ALU_WPSWRR, ALU_WPSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is incremented and shifted right arithmetic one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_SX_32(argument3.32[i]) + _SX_32(argument2.32[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (SX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: AVGRUWP
    what: Average Rounded Unsigned of Words Packed
    formats: [ ALU_WPSWRR, ALU_WPSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is incremented and shifted right logical one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_ZX_32(argument3.32[i]) + _ZX_32(argument2.32[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (ZX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: ADDHQ
    what: Add Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument3.16[i] + argument2.16[i];
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (READ.16[(INDEX.I)].argument3)
            (READ.16[(INDEX.I)].argument2))))
  - ID: SBFHQ
    what: Subtract Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument3.16[i] - argument2.16[i];
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (READ.16[(INDEX.I)].argument3)
            (READ.16[(INDEX.I)].argument2))))
  - ID: ABDHQ
    what: Absolute Difference Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words. The absolute value of
      the four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _ABS(_SX_16(argument3.16[i]) - _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ABS
            (SUB
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: ABDUHQ
    what: Absolute Difference Unsigned Half Words Quadruple
    formats: [ ALU_HQWRRS, ALU_HQWRRS.M ]
    description: >
      The %2 and the %3 are considered as four unsigned half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words. The absolute value of
      the four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _ABS(_ZX_16(argument3.16[i]) - _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ABS
            (SUB
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: ABDSHQ
    what: Absolute Difference Saturated of Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words. The absolute value of
      the four resulting half words are saturated, packed into 64 bits and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SAT_16(_ABS(_SX_16(argument3.16[i]) - _SX_16(argument2.16[i])));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SAT.16
            (ABS
              (SUB
                (SX.16 (READ.16[(INDEX.I)].argument3))
                (SX.16 (READ.16[(INDEX.I)].argument2)))))))
  - ID: MINHQ
    what: Minimum of Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The minimum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MIN(_SX_16(argument3.16[i]), _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MIN
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MINUHQ
    what: Minimum of Unsigned Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The unsigned minimum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MIN(_ZX_16(argument3.16[i]), _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MIN
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MAXHQ
    what: Maximum of Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The maximum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MAX(_SX_16(argument3.16[i]), _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MAX
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MAXUHQ
    what: Maximum of Unsigned Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The unsigned maximum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MAX(_ZX_16(argument3.16[i]), _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MAX
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: ADDSHQ
    what: Add Saturated Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added with saturation to 16 bits.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument3.16[i]) + _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SAT.16
            (ADD
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: SBFSHQ
    what: Subtract Saturated Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted with saturation to 16 bits from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument3.16[i]) - _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SAT.16
            (SUB
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: ADDUSHQ
    what: Add Unsigned Saturated Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four unsigned half words packed into 64 bits.
      The %3 half words and the %2 half words are added with unsigned saturation to 16 bits.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SATU_16(_ZX_16(argument3.16[i]) + _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SATU.16
            (ADD
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: SBFUSHQ
    what: Subtract Unsigned Saturated Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four unsigned half words packed into 64 bits.
      The %2 half words are subtracted with unsigned saturation to 16 bits from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SATU_16(_ZX_16(argument3.16[i]) - _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SATU.16
            (SUB
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: ADDX2HQ
    what: Add Integer to Integer Times 2 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by one bit and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: ADDX4HQ
    what: Add Integer to Integer Times 4 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by two bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: ADDX8HQ
    what: Add Integer to Integer Times 8 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by three bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: ADDX16HQ
    what: Add Integer to Integer Times 16 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by four bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: SBFX2HQ
    what: Subtract Integer to Integer Times 2 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by one bit and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: SBFX4HQ
    what: Subtract Integer to Integer Times 4 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by two bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: SBFX8HQ
    what: Subtract Integer to Integer Times 8 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by three bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: SBFX16HQ
    what: Subtract Integer to Integer Times 16 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by four bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: AVGHQ
    what: Average of Half Words Quadruple
    formats: [ ALU_HQSWRR, ALU_HQSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is shifted right arithmetic one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_SX_16(argument3.16[i]) + _SX_16(argument2.16[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGUHQ
    what: Average Unsigned of Half Words Quadruple
    formats: [ ALU_HQSWRR, ALU_HQSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is shifted right logical one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_ZX_16(argument3.16[i]) + _ZX_16(argument2.16[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGRHQ
    what: Average Rounded of Half Words Quadruple
    formats: [ ALU_HQSWRR, ALU_HQSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is incremented and shifted right arithmetic one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_SX_16(argument3.16[i]) + _SX_16(argument2.16[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (SX.16 (READ.16[(INDEX.I)].argument3))
                (SX.16 (READ.16[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: AVGRUHQ
    what: Average Rounded Unsigned of Half Words Quadruple
    formats: [ ALU_HQSWRR, ALU_HQSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is incremented and shifted right logical one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_ZX_16(argument3.16[i]) + _ZX_16(argument2.16[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (ZX.16 (READ.16[(INDEX.I)].argument3))
                (ZX.16 (READ.16[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: ADDBO
    what: Add Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = argument3.8[i] + argument2.8[i];
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ADD
            (READ.8[(INDEX.I)].argument3)
            (READ.8[(INDEX.I)].argument2))))
  - ID: SBFBO
    what: Subtract Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are subtracted from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = argument3.8[i] - argument2.8[i];
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SUB
            (READ.8[(INDEX.I)].argument3)
            (READ.8[(INDEX.I)].argument2))))
  - ID: ABDBO
    what: Absolute Difference Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %2 and the %3 are considered as eight bytes packed into 64 bits.
      The %2 bytes are subtracted from the %3 bytes. The absolute value of the resulting bytes
      are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _ABS(_SX_8(argument3.8[i]) - _SX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ABS
            (SUB
              (SX.8 (READ.8[(INDEX.I)].argument3))
              (SX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: ABDUBO
    what: Absolute Difference Byte Octuple
    formats: [ ALU_BOWRRS, ALU_BOWRRS.M ]
    description: >
      The %2 and the %3 are considered as eight unsigned bytes packed into 64 bits.
      The %2 bytes are subtracted from the %3 bytes. The absolute value of the resulting bytes
      are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _ABS(_ZX_8(argument3.8[i]) - _ZX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ABS
            (SUB
              (ZX.8 (READ.8[(INDEX.I)].argument3))
              (ZX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: ABDSBO
    what: Absolute Difference Saturated of Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %2 and the %3 are considered as eight bytes packed into 64 bits.
      The %2 bytes are subtracted from the %3 bytes. The absolute value of the resulting bytes
      are saturated, packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SAT_8(_ABS(_SX_8(argument3.8[i]) - _SX_8(argument2.8[i])));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SAT.8
            (ABS
              (SUB
                (SX.8 (READ.8[(INDEX.I)].argument3))
                (SX.8 (READ.8[(INDEX.I)].argument2)))))))
  - ID: MINBO
    what: Minimum of Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The minimum of the %3 bytes and the %2 bytes are computed.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _MIN(_SX_8(argument3.8[i]), _SX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (MIN
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SX.8 (READ.8[(INDEX.I)].argument2)))))
  - ID: MINUBO
    what: Minimum of Unsigned Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The unsigned minimum of the %3 bytes and the %2 bytes are computed.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _MIN(_ZX_8(argument3.8[i]), _ZX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (MIN
            (ZX.8 (READ.8[(INDEX.I)].argument3))
            (ZX.8 (READ.8[(INDEX.I)].argument2)))))
  - ID: MAXBO
    what: Maximum of Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The maximum of the %3 bytes and the %2 bytes are computed.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _MAX(_SX_8(argument3.8[i]), _SX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (MAX
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SX.8 (READ.8[(INDEX.I)].argument2)))))
  - ID: MAXUBO
    what: Maximum of Unsigned Byte Octuple
    formats: [ ALU_BOWRR0, ALU_BOWRR0.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The unsigned maximum of the %3 bytes and the %2 bytes are computed.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _MAX(_ZX_8(argument3.8[i]), _ZX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (MAX
            (ZX.8 (READ.8[(INDEX.I)].argument3))
            (ZX.8 (READ.8[(INDEX.I)].argument2)))))
  - ID: ADDX2BO
    what: Add Integer to Integer Times 2 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by one bit and added to the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) + (_SX_8(argument2.8[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ADD
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: ADDX4BO
    what: Add Integer to Integer Times 4 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by two bits and added to the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) + (_SX_8(argument2.8[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ADD
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: ADDX8BO
    what: Add Integer to Integer Times 8 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by three bits and added to the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) + (_SX_8(argument2.8[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ADD
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: ADDX16BO
    what: Add Integer to Integer Times 16 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by four bits and added to the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) + (_SX_8(argument2.8[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (ADD
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: SBFX2BO
    what: Subtract Integer to Integer Times 2 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by one bit and subtracted from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) - (_SX_8(argument2.8[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SUB
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: SBFX4BO
    what: Subtract Integer to Integer Times 4 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by two bits and subtracted from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) - (_SX_8(argument2.8[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SUB
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: SBFX8BO
    what: Subtract Integer to Integer Times 8 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by three bits and subtracted from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) - (_SX_8(argument2.8[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SUB
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: SBFX16BO
    what: Subtract Integer to Integer Times 16 Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by four bits and subtracted from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SX_8(argument3.8[i]) - (_SX_8(argument2.8[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SUB
            (SX.8 (READ.8[(INDEX.I)].argument3))
            (SHL
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: ADDSBO
    what: Add Saturated Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added with saturation to 8 bits.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SAT_8(_SX_8(argument3.8[i]) + _SX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SAT.8
            (ADD
              (SX.8 (READ.8[(INDEX.I)].argument3))
              (SX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: SBFSBO
    what: Subtract Saturated Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %2 bytes are subtracted with saturation to 8 bits from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SAT_8(_SX_8(argument3.8[i]) - _SX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SAT.8
            (SUB
              (SX.8 (READ.8[(INDEX.I)].argument3))
              (SX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: ADDUSBO
    what: Add Unsigned Saturated Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight unsigned bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added with unsigned saturation to 8 bits.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SATU_8(_ZX_8(argument3.8[i]) + _ZX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SATU.8
            (ADD
              (ZX.8 (READ.8[(INDEX.I)].argument3))
              (ZX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: SBFUSBO
    what: Subtract Unsigned Saturated Byte Octuple
    formats: [ ALU_BOWRR1, ALU_BOWRR1.M ]
    description: >
      The %3 and the %2 are considered as eight unsigned bytes packed into 64 bits.
      The %2 bytes are subtracted with unsigned saturation to 8 bits from the %3 bytes.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = _SATU_8(_ZX_8(argument3.8[i]) - _ZX_8(argument2.8[i]));
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SATU.8
            (SUB
              (ZX.8 (READ.8[(INDEX.I)].argument3))
              (ZX.8 (READ.8[(INDEX.I)].argument2))))))
  - ID: COMPNBO
    what: Compare Negate Byte Octuple
    formats: [ ALU_BOCNWRR, ALU_BOCNWRR.M ]
    description: >
      The %2 and the %3 are considered as eight bytes packed into 64 bits.
      The %2 bytes are compared to the %3 bytes using condition %4.
      The resulting booleans are negated, packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = -comparison_8(argument4, argument2.8[i], argument3.8[i]);
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (NEG
            (B2I
              (TEST.comparison_8
                (READ.argument4)
                (READ.8[(INDEX.I)].argument2)
                (READ.8[(INDEX.I)].argument3))))))
  - ID: CMOVEBO
    what: Conditional Move Byte Octuple
    formats: [ ALU_BOCMWRR, ALU_BOCMWRR.M ]
    description: >
      The %1, %2 and the %3 are considered as eight bytes packed into 64 bits.
      The %2 bytes are tested using the condition %4. If true, the corresponding
      byte of the %3 is stored into the corresponding byte of the %1.
    execution: |
      stage E1:
      if (simdcond_8(argument4, argument2.8[0]))
        %1.8[0] = argument3;
      if (simdcond_8(argument4, argument2.8[1]))
        %1.8[1] = argument3;
      if (simdcond_8(argument4, argument2.8[2]))
        %1.8[2] = argument3;
      if (simdcond_8(argument4, argument2.8[3]))
        %1.8[3] = argument3;
      if (simdcond_8(argument4, argument2.8[4]))
        %1.8[4] = argument3;
      if (simdcond_8(argument4, argument2.8[5]))
        %1.8[5] = argument3;
      if (simdcond_8(argument4, argument2.8[6]))
        %1.8[6] = argument3;
      if (simdcond_8(argument4, argument2.8[7]))
        %1.8[7] = argument3;
    behavior: |
      (SEQ
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[0].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[0]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[1].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[1]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[2].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[2]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[3].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[3]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[4].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[4]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[5].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[5]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[6].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[6]))
          (SKIP))
        (IF
          (TEST.simdcond_8
            (READ.argument4)
            (READ.8[7].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.8[7]))
          (SKIP)))
  - ID: SRSBOS
    what: Shift Right Symmetric Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      If non-negative, each %2 byte is shifted right by the %3 modulo 8.
      Else, each %2 byte is biased by (2**(%3 modulo 8)) - 1 and shifted right by the %3 modulo 8.
      Each result is stored into the corresponding %1 byte.
      This instruction implements a signed division of the bytes of the %2 by the power of two given by %3 modulo 8.
    execution: |
      new shift = _ZX_3(argument3);
      new bias = (1 << shift) - 1;
      for (i range 8) {
        result1.8[i] = (_SX_8(argument2.8[i]) +
                       (_SX_8(argument2.8[i]) < 0 ? bias : 0)) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (WRITE.bias
          (SUB
            (SHL
              (CONST.1)
              (READ.shift))
            (CONST.1)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SHR
              (ADD
                (SX.8 (READ.8[(INDEX.I)].argument2))
                (SELECT
                  (LT
                    (SX.8 (READ.8[(INDEX.I)].argument2))
                    (CONST.0))
                  (READ.bias)
                  (CONST.0)))
              (READ.shift)))))
  - ID: SLLBOS
    what: Shift Left Logical Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by the %3 modulo 8. The vacant positions are filled in with zeros.
      The resulting bytes are packed and stored into the %1.
    execution: |
      new shift = _ZX_3(argument3);
      for (i range 8) {
        result1.8[i] = argument2.8[i] << shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SHL
              (READ.8[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRABOS
    what: Shift Right Arithmetic Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted right by the %3 modulo 8. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand.
      The resulting bytes are packed and stored into the %1.
    execution: |
      new shift = _ZX_3(argument3);
      for (i range 8) {
        result1.8[i] = _SX_8(argument2.8[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SHR
              (SX.8 (READ.8[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SRLBOS
    what: Shift Right Logical Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted right by the %3 modulo 8. The vacant positions are filled in with zeros.
      The resulting bytes are packed and stored into the %1.
    execution: |
      new shift = _ZX_3(argument3);
      for (i range 8) {
        result1.8[i] = _ZX_8(argument2.8[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SHR
              (ZX.8 (READ.8[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SLSBOS
    what: Shift Left Saturated Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    description: >
      The %2 is considered as eight bytes packed into 64 bits.
      The %2 bytes are shifted left by the %3 modulo 8.
      The resulting bytes are saturated to 8 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_3(argument3);
      for (i range 8) {
        result1.8[i] = _SAT_8(_SX_8(argument2.8[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SAT.8
              (SHL
                (SX.8 (READ.8[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: SLUSBOS
    what: Shift Left Unsigned Saturated Byte Octuple by Scalar
    formats: [ ALU_BOSWRI, ALU_BOSWRR ]
    description: >
      The %2 is considered as eight unsigned bytes packed into 64 bits.
      The %2 bytes are shifted left by the %3 modulo 8.
      The resulting bytes are unsigned saturated to 8 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_3(argument3);
      for (i range 8) {
        result1.8[i] = _SATU_8(_SX_8(argument2.8[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.3 (READ.argument3)))
        (FOR.I (RANGE.8)
          (WRITE.8[(INDEX.I)].result1
            (SATU.8
              (SHL
                (ZX.8 (READ.8[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: AVGBO
    what: Average of Byte Octuple
    formats: [ ALU_BOSWRR, ALU_BOSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added. Each sum is shifted right arithmetic one bit.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = (_SX_8(argument3.8[i]) + _SX_8(argument2.8[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SHR
            (ADD
              (SX.8 (READ.8[(INDEX.I)].argument3))
              (SX.8 (READ.8[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGUBO
    what: Average Unsigned of Byte Octuple
    formats: [ ALU_BOSWRR, ALU_BOSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as eight unsigned bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added. Each sum is shifted right logical one bit.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = (_ZX_8(argument3.8[i]) + _ZX_8(argument2.8[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SHR
            (ADD
              (ZX.8 (READ.8[(INDEX.I)].argument3))
              (ZX.8 (READ.8[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGRBO
    what: Average Rounded of Byte Octuple
    formats: [ ALU_BOSWRR, ALU_BOSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as eight bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added. Each sum is incremented and shifted right arithmetic one bit.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = (_SX_8(argument3.8[i]) + _SX_8(argument2.8[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (SX.8 (READ.8[(INDEX.I)].argument3))
                (SX.8 (READ.8[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: AVGRUBO
    what: Average Rounded Unsigned of Byte Octuple
    formats: [ ALU_BOSWRR, ALU_BOSWRR.M ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %3 and the %2 are considered as eight unsigned bytes packed into 64 bits.
      The %3 bytes and the %2 bytes are added. Each sum is incremented and shifted right logical one bit.
      The resulting bytes are packed and stored into the %1.
    execution: |
      for (i range 8) {
        result1.8[i] = (_ZX_8(argument3.8[i]) + _ZX_8(argument2.8[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.8)
        (WRITE.8[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (ZX.8 (READ.8[(INDEX.I)].argument3))
                (ZX.8 (READ.8[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: ADDX2WD
    what: Add Word Times 2 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.1))))
  - ID: ADDX4WD
    what: Add Word Times 4 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.2))))
  - ID: ADDX8WD
    what: Add Word Times 8 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.3))))
  - ID: ADDX16WD
    what: Add Word Times 16 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.4))))
  - ID: ADDX32WD
    what: Add Word Times 32 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by five bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 5);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.5))))
  - ID: ADDX64WD
    what: Add Word Times 64 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by six bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 6);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.6))))
  - ID: SBFX2WD
    what: Subtract Word Times 2 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.1))))
  - ID: SBFX4WD
    what: Subtract Word Times 4 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.2))))
  - ID: SBFX8WD
    what: Subtract Word Times 8 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.3))))
  - ID: SBFX16WD
    what: Subtract Word Times 16 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.4))))
  - ID: SBFX32WD
    what: Subtract Word Times 32 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by five bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 5);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.5))))
  - ID: SBFX64WD
    what: Subtract Word Times 64 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by six bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 6);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.6))))
  - ID: ADDX2UWD
    what: Add Unsigned Word Times 2 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.1))))
  - ID: ADDX4UWD
    what: Add Unsigned Word Times 4 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.2))))
  - ID: ADDX8UWD
    what: Add Unsigned Word Times 8 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.3))))
  - ID: ADDX16UWD
    what: Add Unsigned Word Times 16 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.4))))
  - ID: ADDX32UWD
    what: Add Unsigned Word Times 32 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by five bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 5);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.5))))
  - ID: ADDX64UWD
    what: Add Unsigned Word Times 64 to Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by six bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 6);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.6))))
  - ID: SBFX2UWD
    what: Subtract Unsigned Word Times 2 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.1))))
  - ID: SBFX4UWD
    what: Subtract Unsigned Word Times 4 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.2))))
  - ID: SBFX8UWD
    what: Subtract Unsigned Word Times 8 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.3))))
  - ID: SBFX16UWD
    what: Subtract Unsigned Word Times 16 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.4))))
  - ID: SBFX32UWD
    what: Subtract Unsigned Word Times 32 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by five bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 5);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.5))))
  - ID: SBFX64UWD
    what: Subtract Unsigned Word Times 64 from Double Word
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by six bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 6);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.6))))
  - ID: ADDCD
    what: Add Double Word to Double Word with Carry
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    schedulings: [ ALU_FULL, ALU_FULL.X ]
    description: >
      The %2 is added to the %3 and the \textbf{IC} bit of the \textbf{CS} register. The result is stored into the %1
      and the \textbf{IC} bit is updated.
    execution: |
      stage RR:
      new counter = CS.CC;
      new result1 = _ZX_64(argument2) + _ZX_64(argument3) + CS.IC;
      stage E1:
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64 (READ.argument2))
              (ZX.64 (READ.argument3)))
            (F2I.1 (LOAD.RR (AGGL.CS (CONST.CS_IC) (CONST.1))))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.RR (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: SBFCD
    what: Subtract Double Word from Double Word with Carry
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    schedulings: [ ALU_FULL, ALU_FULL.X ]
    description: >
      The complement of the %2 is added to the %3 and the \textbf{IC} bit of the \textbf{CS} register.
      The result is stored into the %1 and the \textbf{IC} bit is updated.
    execution: |
      stage RR:
      new result1 = _ZX_64(~argument2) + _ZX_64(argument3) + CS.IC;
      new carry = (result1 >> 64) & 1;
      stage E1:
      CS.IC = carry;
      stage E2:
      new counter = CS.CC;
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64
                (NOT (READ.argument2)))
              (ZX.64 (READ.argument3)))
            (F2I.1 (LOAD.RR (AGGL.CS (CONST.CS_IC) (CONST.1))))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.E2 (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: ADDCD.I
    what: Add Double Word to Double Word with Carry Initial
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    schedulings: [ ALU_FULL, ALU_FULL.X ]
    description: >
      The %2 is added to the %3. The result is stored into the %1 and the \textbf{IC} bit
      of the \textbf{CS} register is updated.
    execution: |
      stage RR:
      new counter = CS.CC;
      stage E1:
      new result1 = _ZX_64(argument2) + _ZX_64(argument3);
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ZX.64 (READ.argument2))
            (ZX.64 (READ.argument3))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.RR (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: SBFCD.I
    what: Subtract Double Word from Double Word with Carry Initial
    formats: [ ALU_WDWRR3, ALU_WDWRR3.W ]
    schedulings: [ ALU_FULL, ALU_FULL.X ]
    description: >
      The complement of the %2 plus one is added to the %3.
      The result is stored into the %1 and the \textbf{IC} bit of the \textbf{CS} register is updated.
    execution: |
      stage E1:
      new result1 = _ZX_64(~argument2) + _ZX_64(argument3) + 1;
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      new counter = CS.CC;
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64
                (NOT (READ.argument2)))
              (ZX.64 (READ.argument3)))
            (CONST.1)))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.E2 (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: FNEGD
    what: Floating-Point Negate Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The negated value the %2, assuming binary 64 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000000000000000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000000000000000)))
  - ID: FABSD
    what: Floating-Point Absolute Value Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The absolute value the %2, assuming binary 64 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFFFFFFFFFFFFFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFFFFFFFFFFFFFF)))
  - ID: FSRECD
    what: Floating-Point Seed for Reciprocal Double Word
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming binary 64
      floating-point numbers, is stored into the %1. This instruction
      may raise division by zero, inexact, invalid or overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_fast_rec(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_fast_rec
          (READ.argument2)
        )
      )
  - ID: FSRSRD
    what: Floating-Point Seed for Reciprocal Square Root Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      binary 64 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f64_fast_rsqrt(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_fast_rsqrt
          (READ.argument2)
        )
      )
  - ID: FWIDENLWD
    what: Floating Point Widen Least Significant Word to Double
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 interpreted as a binary 32 floating-point number in the least significant word is
      converted to a binary 64 floating-point number and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f32_to_f64(argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f64
          (READ.32[0].argument2)
        )
      )
  - ID: FWIDENMWD
    what: Floating Point Widen Most Significant Word to Double
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 interpreted as a binary 32 floating-point number in the most significant word is
      converted to a binary 64 floating-point number and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f32_to_f64(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f64
          (READ.32[1].argument2)
        )
      )
  - ID: FNARROWDW
    what: Floating Point Narrow Double Word to Word
    class: FPU
    formats: [ ALU_FWRW ]
    schedulings: [ ALU_FULL ]
    description: >
      The %2 interpreted as a binary 64 floating-point number is
      converted to a binary 32 floating-point number according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_to_f32(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_to_f32
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FNEGW
    what: Floating-Point Negate Word
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The negated value the %2, assuming binary 32 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = _ZX_32(argument2 ^ 0x80000000);
    behavior: |
      (WRITE.result1
        (ZX.32
          (XOR
            (READ.argument2)
            (CONST.0x80000000)
          )
        )
      )
  - ID: FABSW
    what: Floating-Point Absolute Value Word
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The absolute value the %2, assuming binary 32 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = _ZX_32(argument2 & 0x7FFFFFFF);
    behavior: |
      (WRITE.result1
        (ZX.32
          (AND
            (READ.argument2)
            (CONST.0x7FFFFFFF)
          )
        )
      )
  - ID: FRECW
    what: Floating-Point Reciprocal of Word
    class: FPU
    formats: [ ALU_FWRWLL ]
    description: >
      The reciprocal of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_div(RM, 0x3F800000, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_div
          (READ.RM)
          (CONST.0x3F800000)
          (READ.argument2)
        )
      )
  - ID: FRSRW
    what: Floating-Point Reciprocal of Square Root Word
    class: FPU
    formats: [ ALU_FWRWLL ]
    description: >
      The reciprocal of square root of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_rsqrt(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_rsqrt
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FSRECW
    what: Floating-Point Seed for Reciprocal Word
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_fast_rec(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rec
          (READ.argument2)
        )
      )
  - ID: FSRSRW
    what: Floating-Point Seed for Reciprocal Square Root
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      binary 32 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f32_fast_rsqrt(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rsqrt
          (READ.argument2)
        )
      )
  - ID: FWIDENLHW
    what: Floating Point Widen Least Significant Half Word to Word
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The least significant half of the %2 interpreted as a binary 16 floating-point number is
      converted to a binary 32 floating-point number and stored into the least significant word of the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32(argument2.16[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32
          (READ.16[0].argument2)
        )
      )
  - ID: FWIDENMHW
    what: Floating Point Widen Most Significant Half Word to Word
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The most significant half of the %2 interpreted as a binary 16 floating-point number is
      converted to a binary 32 floating-point number and stored into the least significant word of the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32(_ZX_16(argument2 >> 16));
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32
          (ZX.16
            (SHR
              (READ.argument2)
              (CONST.16)
            )
          )
        )
      )
  - ID: FNARROWWH
    what: Floating Point Narrow Word to Half Word
    class: FPU
    formats: [ ALU_FWRW ]
    description: >
      The %2 interpreted as a binary 32 floating-point number is
      converted to a binary 16 floating-point number according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_to_f16(RM, argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f16
          (READ.RM)
          (READ.32[0].argument2)
        )
      )
  - ID: FNEGWP
    what: Floating-Point Negate Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The negated values of the %2, assuming a pair of binary 32 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000000080000000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000000080000000)))
  - ID: FABSWP
    what: Floating-Point Absolute Value Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The absolute values of the %2, assuming a pair of binary 32 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFFFFFF7FFFFFFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFFFFFF7FFFFFFF)))
  - ID: FSRECWP
    what: Floating-Point Seed for Reciprocal on Word Pair
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming a pair of binary 32
      floating-point numbers, is stored into the %1. This instruction
      may raise division by zero, inexact, invalid or overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_fast_rec_x2(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rec_x2
          (READ.argument2)
        )
      )
  - ID: FSRSRWP
    what: Floating-Point Seed for Reciprocal Square Root on Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      a pair of binary 32 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f32_fast_rsqrt_x2(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rsqrt_x2
          (READ.argument2)
        )
      )
  - ID: FWIDENLHWP
    what: Floating Point Widen Least Significant Half Words to Word Pair
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The least significant word of the %2 interpreted as a half word pair. Each
      half word is interpreted as a binary 16 floating-point number and
      converted to a binary 32 floating-point number. These words are paired and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32_x2(argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32_x2
          (READ.32[0].argument2)
        )
      )
  - ID: FWIDENMHWP
    what: Floating Point Widen Most Significant Half Words to Word Pair
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The most significant word of the %2 interpreted as a half word pair. Each
      half word is interpreted as a binary 16 floating-point number and
      converted to a binary 32 floating-point number. These words are paired and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32_x2(_ZX_32(argument2 >> 32));
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32_x2
          (ZX.32
            (SHR (READ.argument2) (CONST.32))
          )
        )
      )
  - ID: FNARROWDWP
    what: Floating Point Narrow Double to Word Pair
    class: FPU
    formats: [ ALU_WPFWR ]
    schedulings: [ ALU_FULL ]
    description: >
      The %2 is interpreted as a pair of binary 64 floating-point numbers,
      which are converted to binary 32 floating-point numbers according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_to_f32_x2(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_to_f32_x2
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FNEGHQ
    what: Floating-Point Negate Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The negated values of the %2, assuming a quadruple of binary 16 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000800080008000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000800080008000)))
  - ID: FABSHQ
    what: Floating-Point Absolute Value Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWR ]
    schedulings: [ ALU_TINY ]
    description: >
      The absolute values of the %2, assuming a quadruple of binary 16 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFF7FFF7FFF7FFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFF7FFF7FFF7FFF)))
  - ID: FNARROWWHQ
    what: Floating Point Narrow Word to Half Word Quadruple
    class: FPU
    formats: [ ALU_WPFWR ]
    description: >
      The %2 is interpreted as a quadruple of binary 32 floating-point numbers,
      which are converted to binary 16 floating-point numbers according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_to_f16_x4(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f16_x4
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: INSF
    what: Insert Bit Field into Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      A bit-mask is computed with ones set between the start bit position and the stop bit position inclusive.
      The %2 is shifted left by the start bit position and inserted into the %1 according to the bit-mask.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: |
      stage RR:
      new argument1 = %1;
      new result1 = ((argument2 << startbit) & mask) | (argument1 & ~mask);
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.result1
          (IOR
            (AND
              (SHL
                (READ.argument2)
                (READ.startbit))
              (READ.mask))
            (AND
              (READ.argument1)
              (NOT (READ.mask))))))
  - ID: EXTFZ
    what: Extract Bit Field and Zero Extend to Double Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      The bit-field of the %2 extending from the start bit position to the stop bit position is extracted,
      zero-extended after the stop bit position, shifted right by the start bit position and stored into the %1.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: &executionEXTFZ |
      new masked = argument2 & mask;
      new result1 = masked >> startbit;
    behavior: &behaviorEXTFZ |
      (SEQ
        (WRITE.masked
          (AND
            (READ.argument2)
            (READ.mask)))
        (WRITE.result1
          (SHR
            (READ.masked)
            (READ.startbit))))
  - ID: EXTFS
    what: Extract Bit Field and Sign Extend to Double Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      The bit-field of the %2 extending from the start bit position to the stop bit position is extracted,
      sign-extended from the stop bit position, shifted right by the start bit position and stored into the %1.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: &executionEXTFS |
      new masked1 = _ZX_64(argument2 & mask);
      new masked2 = _SX_64(argument2 | ~mask);
      new negative = argument2 & (mask & ~(mask >> 1));
      new masked = negative == 0 ? masked1 : masked2;
      new result1 = masked >> startbit;
    behavior: &behaviorEXTFS |
      (SEQ
        (WRITE.masked1
          (ZX.64
            (AND
              (READ.argument2)
              (READ.mask))))
        (WRITE.masked2
          (SX.64
            (IOR
              (READ.argument2)
              (NOT (READ.mask)))))
        (WRITE.negative
          (AND
            (READ.argument2)
            (AND
              (READ.mask)
              (NOT
                (SHR
                  (READ.mask)
                  (CONST.1))))))
        (WRITE.masked
          (SELECT
            (EQ
              (READ.negative)
              (CONST.0))
            (READ.masked1)
            (READ.masked2)))
        (WRITE.result1
          (SHR
            (READ.masked)
            (READ.startbit))))
  - ID: CLRF
    what: Clear Field
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      A bit mask is constructed with ones ranging from the start bit position to the stop bit position inclusive.
      If the start bit position is greater than the stop bit position, ones range from the start bit position
      to bit 63, then from bit 0 to stop bit position. The bitwise and of the %2 and the bit mask complement is stored into the %1.
    execution: |
      new result1 = ~mask & argument2;
    behavior: |
      (WRITE.result1
        (AND
          (NOT
            (READ.mask))
          (READ.argument2)))
  - ID: SRSD
    what: Shift Right Symmetric Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    description: >
      If non-negative, the %2 is shifted right by the %3 modulo 64.
      Else, the %2 biased by (2**(%3 modulo 64)) - 1 and shifted right by the %3 modulo 64.
      The result is stored into the %1.
      This instruction implements a signed division of the %2 double word by a power of two.
    execution: |
      new shift = _ZX_6(argument3);
      new bias = _SX_64(argument2) < 0 ? (1 << shift) - 1 : 0;
      new result1 = (_SX_64(argument2) + bias) >> shift;
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.6 (READ.argument3)))
        (WRITE.bias
          (SELECT
            (LT
              (SX.64 (READ.argument2))
              (CONST.0))
            (SUB
              (SHL
                (CONST.1)
                (READ.shift))
              (CONST.1))
            (CONST.0)))
        (WRITE.result1
          (SHR
            (ADD
              (SX.64 (READ.argument2))
              (READ.bias))
            (READ.shift))))
  - ID: SLLD
    what: Shift Left Logical Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted left by the %3 modulo 64. The vacant positions are filled in with zeros.
      The result is stored into the %1.
    execution: &executionSLLD |
      new result1 = _ZX_64(argument2) << _ZX_6(argument3);
    behavior: &behaviorSLLD |
      (WRITE.result1
        (SHL
          (ZX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SRAD
    what: Shift Right Arithmetic Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted right by the %3 modulo 64. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand. The result is stored into the %1.
    execution: &executionSRAD |
      new result1 = _SX_64(argument2) >> _ZX_6(argument3);
    behavior: &behaviorSRAD |
      (WRITE.result1
        (SHR
          (SX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SRLD
    what: Shift Right Logical Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted right by the %3 modulo 64. The vacant positions are filled in with zeros.
      The result is stored into the %1.
    execution: &executionSRLD |
      new result1 = _ZX_64(argument2) >> _ZX_6(argument3);
    behavior: &behaviorSRLD |
      (WRITE.result1
        (SHR
          (ZX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SLSD
    what: Shift Left Saturated Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    description: >
      The %2 is shifted left by the %3 modulo 64. The result is saturated to 64 bits and stored into the %1.
    execution: |
      new shift = _ZX_6(argument3);
      new result1 = _SAT_64(_SX_64(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.6 (READ.argument3)))
        (WRITE.result1
          (SAT.64
            (SHL
              (SX.64 (READ.argument2))
              (READ.shift)))))
  - ID: SLUSD
    what: Shift Left Unsigned Saturated Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    description: >
      The %2 is shifted left by the %3 modulo 64. The result is unsigned saturated to 64 bits and stored into the %1.
    execution: |
      new shift = _ZX_6(argument3);
      new result1 = _SATU_64(_ZX_64(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.6 (READ.argument3)))
        (WRITE.result1
          (SATU.64
            (SHL
              (ZX.64 (READ.argument2))
              (READ.shift)))))
  - ID: SRSW
    what: Shift Right Symmetric Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      If non-negative, the %2 is shifted right by the %3 modulo 32.
      Else, the %2 biased by (2**(%3 modulo 32)) - 1 and shifted right by the %3 modulo 32.
      The result with the 32 upper bits cleared is stored into the %1.
      This instruction implements a signed division of the %2 least significant word by a power of two.
    execution: |
      new shift = _ZX_5(argument3);
      new bias = _SX_32(argument2) < 0 ? (1 << shift) - 1 : 0;
      new result1 = ((_SX_32(argument2) + bias) >> shift) & 0xFFFFFFFF;
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.bias
          (SELECT
            (LT
              (SX.32 (READ.argument2))
              (CONST.0))
            (SUB
              (SHL
                (CONST.1)
                (READ.shift))
              (CONST.1))
            (CONST.0)))
        (WRITE.result1
          (SHR
            (ADD
              (SX.32 (READ.argument2))
              (READ.bias))
            (READ.shift))))
  - ID: SLLW
    what: Shift Left Logical Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted left by the %3 modulo 32. The vacant positions are filled in with zeros.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2.32[0] << _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHL
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SRAW
    what: Shift Right Arithmetic Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted right by the %3 modulo 32. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SX_32(argument2) >> _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHR
          (SX.32 (READ.argument2))
          (ZX.5 (READ.argument3))))
  - ID: SRLW
    what: Shift Right Logical Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted right by the %3 modulo 32. The vacant positions are filled in with zeros.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2.32[0] >> _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHR
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SLSW
    what: Shift Left Saturated Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is shifted left by the %3 modulo 32 then is saturated to 32 bits.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      new result1 = _SAT_32(_SX_32(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.result1
          (SAT.32
            (SHL
              (SX.32 (READ.argument2))
              (READ.shift)))))
  - ID: SLUSW
    what: Shift Left Unsigned Saturated Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is shifted left by the %3 modulo 32 then is unsigned saturated to 32 bits.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      new result1 = _SATU_32(_ZX_32(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.result1
          (SATU.32
            (SHL
              (ZX.32 (READ.argument2))
              (READ.shift)))))
  - ID: ROLW
    what: Rotate Left Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is rotated left by the %3 modulo 32. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ROL_32(argument2.32[0], _ZX_5(argument3));
    behavior: |
      (WRITE.result1
        (ROL.32
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: RORW
    what: Rotate Right Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is rotated right by the %3 modulo 32. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ROR_32(argument2.32[0], _ZX_5(argument3));
    behavior: |
      (WRITE.result1
        (ROR.32
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SRSWPS
    what: Shift Right Symmetric Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      If non-negative, each %2 word is shifted right by the %3 modulo 32.
      Else, each %2 word is biased by (2**(%3 modulo 32)) - 1 and shifted right by the %3 modulo 32.
      Each result is stored into the corresponding %1 word.
      This instruction implements a signed division of the %2 words by the power of two given by the %3 modulo 32.
    execution: |
      new shift = _ZX_5(argument3);
      new bias = (1 << shift) - 1;
      for (i range 2) {
        result1.32[i] = (_SX_32(argument2.32[i]) +
                        (_SX_32(argument2.32[i]) < 0 ? bias : 0)) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.bias
          (SUB
            (SHL
              (CONST.1)
              (READ.shift))
            (CONST.1)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (ADD
                (SX.32 (READ.32[(INDEX.I)].argument2))
                (SELECT
                  (LT
                    (SX.32 (READ.32[(INDEX.I)].argument2))
                    (CONST.0))
                  (READ.bias)
                  (CONST.0)))
              (READ.shift)))))
  - ID: SLLWPS
    what: Shift Left Logical Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted left by the %3 modulo 32. The vacant positions are filled in with zeros.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = argument2.32[i] << shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHL
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRAWPS
    what: Shift Right Arithmetic Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted right by the %3 modulo 32. The leftmost bit are replicated to fill
      in the vacant positions, thereby extending the signs of the shifted operands.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _SX_32(argument2.32[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SRLWPS
    what: Shift Right Logical Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted right by the %3 modulo 32. The vacant positions are filled in with zeros.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ZX_32(argument2.32[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (ZX.32 (READ.32[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SLSWPS
    what: Shift Left Saturated Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted left by the %3 modulo 32.
      The resulting words are saturated to 32 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument2.32[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SAT.32
              (SHL
                (SX.32 (READ.32[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: SLUSWPS
    what: Shift Left Unsigned Saturated Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two unsigned words packed into 64 bits.
      The %2 words are shifted left by the %3 modulo 32.
      The resulting words are unsigned saturated to 32 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _SATU_32(_SX_32(argument2.32[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SATU.32
              (SHL
                (ZX.32 (READ.32[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: ROLWPS
    what: Rotate Left Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are rotated left by the %3 modulo 32.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ROL_32(argument2.32[i], shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (ROL.32
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: RORWPS
    what: Rotate Right Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are rotated right by the %3 modulo 32.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ROR_32(argument2.32[i], shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (ROR.32
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRSHQS
    what: Shift Right Symmetric Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      If non-negative, each %2 half word is shifted right by the %3 modulo 16.
      Else, each %2 half word is biased by (2**(%3 modulo 16)) - 1 and shifted right by the %3 modulo 16.
      Each result is stored into the corresponding %1 half word.
      This instruction implements a signed division of the half words of the %2 by the power of two given by %3 modulo 16.
    execution: |
      new shift = _ZX_4(argument3);
      new bias = (1 << shift) - 1;
      for (i range 4) {
        result1.16[i] = (_SX_16(argument2.16[i]) +
                        (_SX_16(argument2.16[i]) < 0 ? bias : 0)) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (WRITE.bias
          (SUB
            (SHL
              (CONST.1)
              (READ.shift))
            (CONST.1)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (ADD
                (SX.16 (READ.16[(INDEX.I)].argument2))
                (SELECT
                  (LT
                    (SX.16 (READ.16[(INDEX.I)].argument2))
                    (CONST.0))
                  (READ.bias)
                  (CONST.0)))
              (READ.shift)))))
  - ID: SLLHQS
    what: Shift Left Logical Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted left by the %3 modulo 16. The vacant positions are filled in with zeros.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = argument2.16[i] << shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHL
              (READ.16[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRAHQS
    what: Shift Right Arithmetic Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted right by the %3 modulo 16. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _SX_16(argument2.16[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SRLHQS
    what: Shift Right Logical Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted right by the %3 modulo 16. The vacant positions are filled in with zeros.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _ZX_16(argument2.16[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (ZX.16 (READ.16[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SLSHQS
    what: Shift Left Saturated Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted left by the %3 modulo 16.
      The resulting half words are saturated to 16 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument2.16[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SAT.16
              (SHL
                (SX.16 (READ.16[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: SLUSHQS
    what: Shift Left Unsigned Saturated Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four unsigned half words packed into 64 bits.
      The %2 half words are shifted left by the %3 modulo 16.
      The resulting half words are unsigned saturated to 16 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _SATU_16(_SX_16(argument2.16[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SATU.16
              (SHL
                (ZX.16 (READ.16[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: COMPD
    what: Compare Double Words
    formats: [ ALU_CWRI, ALU_CWRI.X, ALU_CWRI.Y, ALU_CWRR ]
    description: >
      The %2 is compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_64(argument4, argument2, argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (READ.argument2)
            (READ.argument3))))
  - ID: COMPW
    what: Compare Words
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %2 is compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_32(argument4, argument2, argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_32
            (READ.argument4)
            (READ.argument2)
            (READ.argument3))))
  - ID: COMPND
    what: Compare Negate Double Words
    formats: [ ALU_CNWRR, ALU_CNWRR.W ]
    description: >
      The %2 is compared to the %3 using condition %4. The negated boolean result is stored into the %1.
    execution: |
      new result1 = -comparison_64(argument4, argument2, argument3);
    behavior: |
      (WRITE.result1
        (NEG
          (B2I
            (TEST.comparison_64
              (READ.argument4)
              (READ.argument2)
              (READ.argument3)))))
  - ID: COMPNW
    what: Compare Negate Words
    formats: [ ALU_CNWRR, ALU_CNWRR.W ]
    description: >
      The %2 is compared to the %3 using condition %4. The negated boolean result is stored into the %1.
    execution: |
      new result1 = _ZX_32(-comparison_32(argument4, argument2, argument3));
    behavior: |
      (WRITE.result1
        (ZX.32
          (NEG
            (B2I
              (TEST.comparison_32
                (READ.argument4)
                (READ.argument2)
                (READ.argument3))))))
  - ID: COMPWD
    what: Compare Word to Double Word
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    description: >
      The %2 is sign-extended from 32 bits and compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_64(argument4, _SX_32(argument2), argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (SX.32 (READ.argument2))
            (READ.argument3))))
  - ID: COMPUWD
    what: Compare Unsigned Word to Double Word
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    description: >
      The %2 is zero-extended from 32 bits and compared to the %3 using condition %4. The boolean result is stored into the %2.
    execution: |
      new result1 = comparison_64(argument4, argument2.32[0], argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (READ.32[0].argument2)
            (READ.argument3))))
  - ID: COMPNWP
    what: Compare Negate Word Pair
    formats: [ ALU_WPCNWRR, ALU_WPCNWRR.M ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are compared to the %3 words using condition %4.
      The resulting booleans are negated, packed and stored into the %1.
    execution: |
      result1.32[0] = -comparison_32(argument4, argument2.32[0], argument3.32[0]);
      result1.32[1] = -comparison_32(argument4, argument2.32[1], argument3.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (NEG
            (B2I
              (TEST.comparison_32
                (READ.argument4)
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.32[1].result1
          (NEG
            (B2I
              (TEST.comparison_32
                (READ.argument4)
                (READ.32[1].argument2)
                (READ.32[1].argument3))))))
  - ID: COMPNHQ
    what: Compare Negate Half Words Quadruple
    formats: [ ALU_HQCWRR, ALU_HQCWRR.M ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are compared to the %3 half words using condition %4.
      The resulting booleans are negated, packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = -comparison_16(argument4, argument2.16[i], argument3.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (NEG
            (B2I
              (TEST.comparison_16
                (READ.argument4)
                (READ.16[(INDEX.I)].argument2)
                (READ.16[(INDEX.I)].argument3))))))
  - ID: CMOVED
    what: Conditional Move Double Word
    formats: [ ALU_DCMWRI, ALU_DCMWRI.X, ALU_DCMWRI.Y, ALU_DCMWRR ]
    description: >
      The %2 is tested using the condition %4. If true, the %3 is stored into the %1.
      This instruction is used to replace conditional branches during if-conversion.
    execution: |
      stage E1:
      if (scalarcond(argument4, argument2)) {
        %1 = argument3;
      }
    behavior: |
      (IF
        (TEST.scalarcond (READ.argument4) (READ.argument2))
        (COMMIT.E1.%1 (READ.argument3))
        (SKIP))
  - ID: CMOVEWP
    what: Conditional Move Words Packed
    formats: [ ALU_WPCMWRR, ALU_WPCMWRR.M ]
    description: >
      The %1, %2 and the %3 are considered as words packed into 64 bits.
      The %2 words are tested using the condition %4. If true, the corresponding
      word of the %3 is stored into the corresponding word of the %1.
    execution: |
      stage E1:
      if (simdcond_32(argument4, argument2.32[0]))
        %1.32[0] = argument3;
      if (simdcond_32(argument4, argument2.32[1]))
        %1.32[1] = argument3;
    behavior: |
      (SEQ
        (IF
          (TEST.simdcond_32
            (READ.argument4)
            (READ.32[0].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.32[0]))
          (SKIP))
        (IF
          (TEST.simdcond_32
            (READ.argument4)
            (READ.32[1].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.32[1]))
          (SKIP)))
  - ID: MAKE
    what: Make Word from Immediate
    formats: [ ALU_MAKE, ALU_MAKE.X, ALU_MAKE.Y ]
    description: >
      The %2 is stored into the %1.
    execution: |
      new result1 = _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (SX.64
          (READ.argument2)))
  - ID: PCREL
    what: PC-Relative
    formats: [ ALU_PCREL, ALU_PCREL.X, ALU_PCREL.Y ]
    schedulings: [ ALU_FULL, ALU_FULL.X, ALU_FULL.Y ]
    description: >
      The %2 is is added to the bundle \textbf{PC} and the result is stored into the %1.
    execution: |
      new result1 = PC + _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (F2I.64 (LOAD.RR (AGGL.PC (CONST.0) (CONST.1))))
          (SX.64
            (READ.argument2))))
  - ID: CLZW
    what: Count Leading Zero of Word
    formats: [ ALU_BWRW ]
    description: >
      The leading zero count value of the %2 is stored into the %1. When applied to zero, the result is 32.
    execution: |
      new result1 = _ZX_32(_CLZ_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CLZ.32 (READ.argument2))))
  - ID: CLSW
    what: Count Leading Sign of Word
    formats: [ ALU_BWRW ]
    description: >
      The leading sign count value of the %2 is stored into the %1. When applied to zero or -1, the result is 31.
    execution: |
      new result1 = _ZX_32(_CLS_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CLS.32 (READ.argument2))))
  - ID: CBSW
    what: Count Bit Set of Word
    formats: [ ALU_BWRW ]
    description: >
      Bit set population count value of the %2 is stored into the %1.
    execution: |
      new result1 = _ZX_32(_CBS_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CBS.32 (READ.argument2))))
  - ID: CTZW
    what: Count Trailing Zero of Word
    formats: [ ALU_BWRW ]
    description: >
      The trailing zero count value of the %2 is stored into the %1. When applied to zero, the result is 32.
    execution: |
      new result1 = _ZX_32(_CTZ_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CTZ.32 (READ.argument2))))
  - ID: CLZD
    what: Count Leading Zero of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The leading zero count value of the %2 is stored into the %1. When applied to zero, the result is 64.
    execution: |
      new result1 = _ZX_64(_CLZ_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CLZ.64 (READ.argument2))))
  - ID: CLSD
    what: Count Leading Sign of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The leading sign count value of the %2 is stored into the %1. When applied to zero or -1, the result is 63.
    execution: |
      new result1 = _ZX_64(_CLS_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CLS.64 (READ.argument2))))
  - ID: CBSD
    what: Count Bit Set of Double Word
    formats: [ ALU_BWRD ]
    description: >
      Bit set population count value of the %2 is stored into the %1.
    execution: |
      new result1 = _ZX_64(_CBS_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CBS.64 (READ.argument2))))
  - ID: CTZD
    what: Count Trailing Zero of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The trailing zero count value of the %2 is stored into the %1. When applied to zero, the result is 64.
    execution: |
      new result1 = _ZX_64(_CTZ_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CTZ.64 (READ.argument2))))
  - ID: CLZWP
    what: Count Leading Zeroes of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The leading zero count values of the %2 interpreted as a word pair are stored into the %1.
      When applied to zero at the word level, the result is 32.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CLZ_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CLZ.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CLSWP
    what: Count Leading Signs of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The leading sign count values of the %2 interpreted as word pair are stored into the %1.
      When applied to zero or -1 at the word level, the result is 31.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CLS_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CLS.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CBSWP
    what: Count Bit Sets of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      Bit set population count values of the %2 interpreted as word pair are stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CBS_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CBS.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CTZWP
    what: Count Trailing Zeroes of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The trailing zero count values of the %2 interpreted as word pair are stored into the %1.
      When applied to zero at the word level, the result is 32.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CTZ_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CTZ.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: ZXLHWP
    what: Zero Extend Least Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two half words packed into the least significant 32 bits.
      Each half word is zero-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _ZX_16(argument2.16[0]);
      result1.32[1] = _ZX_16(argument2.16[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (ZX.16
            (READ.16[0].argument2)))
        (WRITE.32[1].result1
          (ZX.16
            (READ.16[1].argument2))))
  - ID: ZXMHWP
    what: Zero Extend Most Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two half words packed into the most significant 32 bits.
      Each half word is zero-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _ZX_16(argument2.16[2]);
      result1.32[1] = _ZX_16(argument2.16[3]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (ZX.16
            (READ.16[2].argument2)))
        (WRITE.32[1].result1
          (ZX.16
            (READ.16[3].argument2))))
  - ID: ZXLBHQ
    what: Zero Extend Least Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four bytes packed into the least significant 32 bits.
      Each byte is zero-extended to 16-bit and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _ZX_8(argument2.8[0]);
      result1.16[1] = _ZX_8(argument2.8[1]);
      result1.16[2] = _ZX_8(argument2.8[3]);
      result1.16[3] = _ZX_8(argument2.8[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (ZX.8
            (READ.8[0].argument2)))
        (WRITE.16[1].result1
          (ZX.8
            (READ.8[1].argument2)))
        (WRITE.16[2].result1
          (ZX.8
            (READ.8[2].argument2)))
        (WRITE.16[3].result1
          (ZX.8
            (READ.8[3].argument2))))
  - ID: ZXMBHQ
    what: Zero Extend Most Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four bytes packed into the most significant 32 bits.
      Each byte is zero-extended to 16 bits and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _ZX_8(argument2.8[4]);
      result1.16[1] = _ZX_8(argument2.8[5]);
      result1.16[2] = _ZX_8(argument2.8[6]);
      result1.16[3] = _ZX_8(argument2.8[7]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (ZX.8
            (READ.8[4].argument2)))
        (WRITE.16[1].result1
          (ZX.8
            (READ.8[5].argument2)))
        (WRITE.16[2].result1
          (ZX.8
            (READ.8[6].argument2)))
        (WRITE.16[3].result1
          (ZX.8
            (READ.8[7].argument2))))
  - ID: SXLHWP
    what: Sign Extend Least Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two half words packed into the least significant 32 bits.
      Each half word is sign-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _SX_16(argument2.16[0]);
      result1.32[1] = _SX_16(argument2.16[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (SX.16
            (READ.16[0].argument2)))
        (WRITE.32[1].result1
          (SX.16
            (READ.16[1].argument2))))
  - ID: SXMHWP
    what: Sign Extend Most Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as two half words packed into the most significant 32 bits.
      Each half word is sign-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _SX_16(argument2.16[2]);
      result1.32[1] = _SX_16(argument2.16[3]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (SX.16
            (READ.16[2].argument2)))
        (WRITE.32[1].result1
          (SX.16
            (READ.16[3].argument2))))
  - ID: SXLBHQ
    what: Sign Extend Least Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four bytes packed into the least significant 32 bits.
      Each byte is sign-extended to 16-bit and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _SX_8(argument2.8[0]);
      result1.16[1] = _SX_8(argument2.8[1]);
      result1.16[2] = _SX_8(argument2.8[3]);
      result1.16[3] = _SX_8(argument2.8[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (SX.8
            (READ.8[0].argument2)))
        (WRITE.16[1].result1
          (SX.8
            (READ.8[1].argument2)))
        (WRITE.16[2].result1
          (SX.8
            (READ.8[2].argument2)))
        (WRITE.16[3].result1
          (SX.8
            (READ.8[3].argument2))))
  - ID: SXMBHQ
    what: Sign Extend Most Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    schedulings: [ ALU_TINY ]
    description: >
      The %2 is considered as four bytes packed into the most significant 32 bits.
      Each byte is sign-extended to 16 bits and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _SX_8(argument2.8[4]);
      result1.16[1] = _SX_8(argument2.8[5]);
      result1.16[2] = _SX_8(argument2.8[6]);
      result1.16[3] = _SX_8(argument2.8[7]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (SX.8
            (READ.8[4].argument2)))
        (WRITE.16[1].result1
          (SX.8
            (READ.8[5].argument2)))
        (WRITE.16[2].result1
          (SX.8
            (READ.8[6].argument2)))
        (WRITE.16[3].result1
          (SX.8
            (READ.8[7].argument2))))
  - ID: CMOVEHQ
    what: Conditional Move Half Words Quadruple
    formats: [ ALU_CMWRRHQ, ALU_CMWRRHQ.M ]
    description: >
      The %1, %2 and the %3 are considered as half words packed into 64 bits.
      The %2 half words are tested using the condition %4. If true, the corresponding
      half word of the %3 is stored into the corresponding half word of the %1.
    execution: |
      stage E1:
      if (simdcond_16(argument4, argument2.16[0]))
        %1.16[0] = argument3;
      if (simdcond_16(argument4, argument2.16[1]))
        %1.16[1] = argument3;
      if (simdcond_16(argument4, argument2.16[2]))
        %1.16[2] = argument3;
      if (simdcond_16(argument4, argument2.16[3]))
        %1.16[3] = argument3;
    behavior: |
      (SEQ
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[0].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[0]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[1].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[1]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[2].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[2]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[3].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[3]))
          (SKIP)))
  - ID: FCOMPW
    what: Floating-Point Compare Single
    class: FPU
    formats: [ ALU_FCWRRS, ALU_FCWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 32
      floating-point numbers. The boolean result is stored into the %1.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = floatcomp_32(argument4, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (B2I
            (TEST.floatcomp_32
              (READ.argument4)
              (READ.argument2)
              (READ.argument3)))))
  - ID: FCOMPD
    what: Floating-Point Compare Double
    class: FPU
    formats: [ ALU_FCWRRS, ALU_FCWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 64
      floating-point numbers. The boolean result is stored into the %1.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = floatcomp_64(argument4, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (B2I
            (TEST.floatcomp_64
              (READ.argument4)
              (READ.argument2)
              (READ.argument3)))))
  - ID: FCOMPNW
    what: Floating-Point Compare Negate Single
    class: FPU
    formats: [ ALU_FCNWRRS, ALU_FCNWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 32
      floating-point numbers. The negated boolean result is stored into the %1,
      with the upper word being zeroed.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = _ZX_32(-floatcomp_32(argument4, argument2, argument3));
    behavior: |
      (WRITE.result1
        (ZX.32
          (NEG
            (B2I
              (TEST.floatcomp_32
                (READ.argument4)
                (READ.argument2)
                (READ.argument3)
              )
            )
          )
        )
      )
  - ID: FCOMPND
    what: Floating-Point Compare Negate Double
    class: FPU
    formats: [ ALU_FCNWRRS, ALU_FCNWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 64
      floating-point numbers. The negated boolean result is stored into the %1.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = -floatcomp_64(argument4, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (NEG
            (B2I
              (TEST.floatcomp_64
                (READ.argument4)
                (READ.argument2)
                (READ.argument3))))))
  - ID: FCOMPNWP
    what: Floating-Point Compare Negate Word Pair
    class: FPU
    formats: [ ALU_WPFCWRR, ALU_WPFCWRR.M ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are compared to the %3 words using condition %4, assuming binary 32
      floating-point numbers. The resulting booleans are negated, packed and stored into the %1.
      This instruction does not raise an invalid exception when handling a signaling NaN.
    execution: |
      result1.32[0] = -floatcomp_32(argument4, argument2.32[0], argument3.32[0]);
      result1.32[1] = -floatcomp_32(argument4, argument2.32[1], argument3.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (NEG
            (B2I
              (TEST.floatcomp_32
                (READ.argument4)
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.32[1].result1
          (NEG
            (B2I
              (TEST.floatcomp_32
                (READ.argument4)
                (READ.32[1].argument2)
                (READ.32[1].argument3))))))
  - ID: FCOMPNHQ
    what: Floating-Point Compare Negate Half Word Quadruple
    class: FPU
    formats: [ ALU_HQFCWRR, ALU_HQFCWRR.M ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are compared to the %3 half words using condition %4, assuming binary 16
      floating-point numbers. The resulting booleans are negated, packed and stored into the %1.
      This instruction does not raise an invalid exception when handling a signaling NaN.
    execution: |
      result1.16[0] = -floatcomp_16(argument4, argument2.16[0], argument3.16[0]);
      result1.16[1] = -floatcomp_16(argument4, argument2.16[1], argument3.16[1]);
      result1.16[2] = -floatcomp_16(argument4, argument2.16[2], argument3.16[2]);
      result1.16[3] = -floatcomp_16(argument4, argument2.16[3], argument3.16[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[0].argument2)
                (READ.16[0].argument3)))))
        (WRITE.16[1].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[1].argument2)
                (READ.16[1].argument3)))))
        (WRITE.16[2].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[2].argument2)
                (READ.16[2].argument3)))))
        (WRITE.16[3].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[3].argument2)
                (READ.16[3].argument3))))))
  - ID: FSDIVD
    what: Floating-Point Seed for Division Double Word
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      An approximate value of the division of the least significant half by the most significant half of the %2,
      interpreted as binary 64 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fsdiv_64(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fsdiv_64
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVD
    what: Floating-Point Cases for Division Double Word
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The value of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as binary 64 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fcdiv_64(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fcdiv_64
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FSDIVW
    what: Floating-Point Seed for Word Division
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      An approximate value of the division of the least significant half by the most significant half of the %2,
      interpreted as binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[2];
      new result1 = fsdiv_32(argument_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (READ.32[0].argument2))
        (WRITE.argument2_1
          (READ.32[2].argument2))
        (WRITE.result1
          (APPLY.fsdiv_32
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVW
    what: Floating-Point Cases for Word Division
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The value of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[2];
      new result1 = fcdiv_32(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (READ.32[0].argument2))
        (WRITE.argument2_1
          (READ.32[2].argument2))
        (WRITE.result1
          (APPLY.fcdiv_32
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FSDIVWP
    what: Floating-Point Seed for Division Word Pair
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The pair of values of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as pairs of binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fsdiv_32_x2(argument_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fsdiv_32_x2
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVWP
    what: Floating-Point Cases for Division Word Pair
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The pair of values of the special cases for the division of the least significant half by the most significant half of the %2,
      interpreted as pairs of binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fcdiv_32_x2(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fcdiv_32_x2
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FMIND
    what: Floating-Point Minimum Double Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 64
      floating-point numbers. The minimum is stored into the %1.
    execution: |
      new result1 = f64_minNum(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_minNum
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMAXD
    what: Floating-Point Maximum Double Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 64
      floating-point numbers. The maximum is stored into the %1.
    execution: |
      new result1 = f64_maxNum(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_maxNum
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMINW
    what: Floating-Point Minimum Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 32 floating-point
      numbers. The minimum is stored into the %1.
    execution: |
      new result1 = f32_minNum(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_minNum
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMAXW
    what: Floating-Point Maximum Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 32 floating-point
      numbers. The maximum is stored into the %1.
    execution: |
      new result1 = f32_maxNum(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_maxNum
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMINWP
    what: Floating-Point Minimum Word Pair
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming pairs of binary 32 floating-point
      numbers. The pair of minimum values is stored into the %1.
    execution: |
      new result1 = f32_minNum_x2(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_minNum_x2
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMAXWP
    what: Floating-Point Maximum Word Pair
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming pairs of binary 32 floating-point
      numbers. The pair of maximum values is stored into the %1.
    execution: |
      new result1 = f32_maxNum_x32(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_maxNum_x2
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMINHQ
    what: Floating-Point Minimum Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming quadruple of binary 16 floating-point
      numbers. The quadruple of minimum values is stored into the %1.
    execution: |
      new result1 = f16_minNum_x4(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_minNum_x4
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMAXHQ
    what: Floating-Point Maximum Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming quadruple of binary 16 floating-point
      numbers. The quadruple of maximum values is stored into the %1.
    execution: |
      new result1 = f16_maxNum_x4(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_maxNum_x4
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FLOATD
    what: Floating Point Conversion from Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit signed integer is converted to a
      64-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATWP
    what: Floating Point Conversion from Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit signed integer pair is converted to a
      32-bit floating-point number pair according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FLOATHQ
## what: Floating Point Conversion from Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit signed integer quadruple is converted to a
## 16-bit floating-point number quadruple according to the rounding mode %4 and
## then divided by (1<<%3). This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = float_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.float_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FLOATW
    what: Floating Point Conversion from Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit signed integer is converted to a
      32-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATUD
    what: Floating Point Conversion from Unsigned Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit unsigned integer is converted to a
      64-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATUWP
    what: Floating Point Conversion from Unsigned Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit unsigned integer pair is converted to a
      32-bit floating-point number pair according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FLOATUHQ
## what: Floating Point Conversion from Unsigned Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit unsigned integer quadruple is converted to a
## 16-bit floating-point number quadruple according to the rounding mode %4 and
## then divided by (1<<%3). This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = floatu_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.floatu_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FLOATUW
    what: Floating Point Conversion from Unsigned Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit unsigned integer is converted to a
      32-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDD
    what: Floating Point Conversion to Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit floating-point number is multiplied
      by (1<<%3) then converted to a 64-bit signed integer according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixed_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDWP
    what: Floating Point Conversion to Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number pair is multiplied
      by (1<<%3) then converted to a 32-bit signed integer pair according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixed_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FIXEDHQ
## what: Floating Point Conversion to Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit floating-point number quadruple is multiplied
## by (1<<%3) then converted to a 16-bit signed integer quadruple according to
## the rounding mode %4. This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = fixed_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.fixed_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FIXEDW
    what: Floating Point Conversion to Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number is multiplied
      by (1<<%3) then converted to a 32-bit signed integer according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register. As this instructions belongs to the 32-bit ISA subset,
      the 32 upper bits of the destination register are cleared even if the resulting word is negative.
    execution: |
      new result1 = fixed_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUD
    what: Floating Point Conversion to Unsigned Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit floating-point number is multiplied
      by (1<<%3) then converted to a 64-bit unsigned integer according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUWP
    what: Floating Point Conversion to Unsigned Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number pair is multiplied
      by (1<<%3) then converted to a 32-bit unsigned integer pair according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUW
    what: Floating Point Conversion to Unsigned Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number is multiplied
      by (1<<%3) then converted to a 32-bit unsigned integer according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: MADDD
    what: Multiply-Add Double Word
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFD
    what: Multiply-Subtract Double Word
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDWP
    what: Multiply-Add Word Pair
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are added to the respective words of the %1.
      The resulting paired word is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument1.32[i] + _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFWP
    what: Multiply-Subtract Word Pair
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are subtracted from the respective words of the %1.
      The resulting paired word is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument1.32[i] - _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDHQ
    what: Multiply-Add Half Word Quadruple
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are added to the respective half words of the %1.
      The resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument1.16[i] + _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (READ.16[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFHQ
    what: Multiply-Subtract Half Word Quadruple
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are subtracted from to the respective half words of the %1.
      The resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument1.16[i] - _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (READ.16[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDHWQ
    what: Multiply-Add Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFHWQ
    what: Multiply-Subtract Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.16[i] - _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDUHWQ
    what: Multiply-Add Unsigned Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFUHWQ
    what: Multiply-Subtract Unsigned Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDSUHWQ
    what: Multiply-Add Signed by Unsigned Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFSUHWQ
    what: Multiply-Subtract Signed by Unsigned Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDWQ
    what: Multiply-Add Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four resulting words are added to the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDMWQ
    what: Multiply-Add Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four most significant words of the 64-bit results are added to the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + ((_SX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (SX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MADDUMWQ
    what: Multiply-Add Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming unsigned integers.
      The four most significant words of the 64-bit results are added to the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + ((_ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (ZX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MADDSUMWQ
    what: Multiply-Add Signed by Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words assuming unsigned integers and the %2 words assuming signed integers are multiplied.
      The four most significant words of the 64-bit results are added to the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + ((_ZX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MSBFWQ
    what: Multiply-Subtract Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four resulting words are subtracted from the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFMWQ
    what: Multiply-Subtract Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four most significant words of the 64-bit results are subtracted from the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - ((_SX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (SX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MSBFUMWQ
    what: Multiply-Subtract Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming unsigned integers.
      The four most significant words of the 64-bit results are subtracted from the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - ((_ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (ZX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MSBFSUMWQ
    what: Multiply-Subtract Signed by Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words assuming unsigned integers and the %2 words assuming signed integers are multiplied.
      The four most significant words of the 64-bit results are subtracted from the respective words of the %1,
      packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - ((_ZX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (SHR
              (MUL
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.32)))))
  - ID: MADDDT
    what: Multiply-Add Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is added to the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_SX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDUDT
    what: Multiply-Add Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is added to the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_ZX_64(argument3) * _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MADDSUDT
    what: Multiply-Add Signed by Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 assuming unsigned 64-bit integer and the %2 assuming signed 64-bit integer are multiplied.
      The product is added to the 128 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_ZX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDUZDT
    what: Multiply-Add Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is added to the upper 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1 >> 64) + _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (ZX.64
            (SHR
              (READ.argument1)
              (CONST.64)))
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MSBFDT
    what: Multiply-Subtract Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is subtracted from the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_SX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFUDT
    what: Multiply-Subtract Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is subtracted from the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_ZX_64(argument3) * _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MSBFSUDT
    what: Multiply-Subtract Signed by Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 assuming unsigned 64-bit integer and the %2 assuming signed 64-bit integer are multiplied.
      The product is subtracted from the 128 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_ZX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFUZDT
    what: Multiply-Subtract Unsigned Double to Quadruple Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is subtracted from the upper 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1 >> 64) - _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (ZX.64
            (SHR
              (READ.argument1)
              (CONST.64)))
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MULD
    what: Multiply Double Word
    formats: [ MAU_DDD0, MAU_DDD0.M ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers. The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MULDT
    what: Multiply Double Word to Tetra Word
    formats: [ MAU_QDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers. The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MULUDT
    what: Multiply Unsigned Double Words to Tetra Word
    formats: [ MAU_QDD1 ]
    description: >
      The %3 is multiplied by the %2 assuming unsigned double integers
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: MULSUDT
    what: Multiply Signed by Unsigned Double Words to Tetra Word
    formats: [ MAU_QDD1 ]
    description: >
      The %3 assuming unsigned double integer and the %2 assuming signed double integer are multiplied.
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: CMULDT
    what: Carryless Multiply Double Words to Tetra Word
    formats: [ MAU_QDD1 ]
    description: >
      The %3 assuming double integer is carryless multiplied by the %2 assuming double integer.
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = clm_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.clm_64_128
          (READ.argument2)
          (READ.argument3)))
  - ID: CMULXDT
    what: Carryless Multiply and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is carryless multiplied by the %2 assuming double integer.
      The final 128 bits of the result are XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ clm_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.clm_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGLXDT
    what: Carryless Multiply Galois Low and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is XOR-ed to itself left-shifted by 64 and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_bb_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_bb_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGMXDT
    what: Carryless Multiply Galois Middle and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is left-shifted by 64 and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_bt_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_bt_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGHXDT
    what: Carryless Multiply Galois High and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is left-shifted by 128 and 64, shift results are XOR-ed together and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_tt_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_tt_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CRCBELMW
    what: Cyclic Redundancy Check Big-Endian Least Significant with Most Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 most significant bytes
      of the %2 considered in reverse order. The result is reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3.
      The result is stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ _SWAP_16(_SWAP_8(argument2 >> 32));
      new result1 = crc32_be_u32(argument1_data.32[0], argument3.32[0]);
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (SWAP.16 (SWAP.8 (SHR (READ.argument2) (CONST.32))))))
        (WRITE.result1
          (APPLY.32.crc32_be_u32
            (READ.32[0].argument1_data)
            (READ.32[0].argument3))))
  - ID: CRCBELLW
    what: Cyclic Redundancy Check Big-Endian Least Significant with Least Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 least significant bytes
      of the %2 considered in reverse order. The result is reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3.
      The result is stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ _SWAP_16(_SWAP_8(argument2));
      new result1 = crc32_be_u32(argument1_data.32[0], argument3.32[0]);
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (SWAP.16 (SWAP.8 (READ.argument2) ))))
        (WRITE.result1
          (APPLY.32.crc32_be_u32
            (READ.32[0].argument1_data)
            (READ.32[0].argument3))))
  - ID: CRCLELMW
    what: Cyclic Redundancy Check Little-Endian Least Significant with Most Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 most significant bytes
      of the %2. The result is bit reversed and then reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3 bit reversed beforehand.
      The result is bit reversed and stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ argument2.32[1];
      new result1 = reflect_32(crc32_be_u32(reflect_32(argument1_data.32[0]), reflect_32(argument3.32[0])));
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (READ.32[1].argument2)))
        (WRITE.result1
          (APPLY.32.reflect_32
              (APPLY.32.crc32_be_u32
                (APPLY.32.reflect_32 (READ.32[0].argument1_data))
                (APPLY.32.reflect_32 (READ.32[0].argument3))))))
  - ID: CRCLELLW
    what: Cyclic Redundancy Check Little-Endian Least Significant with Least Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 least significant bytes
      of the %2. The result is bit reversed and then reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3 bit reversed beforehand.
      The result is bit reversed and stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ argument2.32[0];
      new result1 = reflect_32(crc32_be_u32(reflect_32(argument1_data.32[0]), reflect_32(argument3.32[0])));
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (READ.32[0].argument2)))
        (WRITE.result1
          (APPLY.32.reflect_32
              (APPLY.32.crc32_be_u32
                (APPLY.32.reflect_32 (READ.32[0].argument1_data))
                (APPLY.32.reflect_32 (READ.32[0].argument3))))))
  - ID: DOT2WD
    what: Dot product of 2x Word Vectors into Double Word
    formats: [ MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming signed integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _SX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                  + _SX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (SX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2)))
          (MUL
            (SX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: DOT2UWD
    what: Dot product of 2x Unsigned Word Vectors into Double Word
    formats: [ MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming unsigned integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0]) * _ZX_32(argument2.32[0])
                  + _ZX_32(argument3.32[1]) * _ZX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (ZX.32 (READ.32[0].argument3))
            (ZX.32 (READ.32[0].argument2)))
          (MUL
            (ZX.32 (READ.32[1].argument3))
            (ZX.32 (READ.32[1].argument2)))))
  - ID: DOT2SUWD
    what: Dot product of 2x Signed by Unsigned Word Vectors into Double Word
    formats: [ MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming unsigned and signed integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                  + _ZX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (ZX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2)))
          (MUL
            (ZX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: DOT2W
    what: Dot product of 2x Word Vectors into Word
    formats: [ MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming integers.
      The result is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0] * argument2.32[0]
                           + argument3.32[1] * argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (ADD
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2))
            (MUL
              (READ.32[1].argument3)
              (READ.32[1].argument2)))))
  - ID: DOT2WDP
    what: Dot products of 2x Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming signed integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming signed integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _SX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                    + _SX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
      result1.64[1] = _SX_32(argument3.32[2]) * _SX_32(argument2.32[2])
                    + _SX_32(argument3.32[3]) * _SX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (SX.32 (READ.32[0].argument3))
              (SX.32 (READ.32[0].argument2)))
            (MUL
              (SX.32 (READ.32[1].argument3))
              (SX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (SX.32 (READ.32[2].argument3))
              (SX.32 (READ.32[2].argument2)))
            (MUL
              (SX.32 (READ.32[3].argument3))
              (SX.32 (READ.32[3].argument2))))))
  - ID: DOT2UWDP
    what: Dot products of 2x Unsigned Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming unsigned integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming unsigned integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0]) * _ZX_32(argument2.32[0])
                    + _ZX_32(argument3.32[1]) * _ZX_32(argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2]) * _ZX_32(argument2.32[2])
                    + _ZX_32(argument3.32[3]) * _ZX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[0].argument3))
              (ZX.32 (READ.32[0].argument2)))
            (MUL
              (ZX.32 (READ.32[1].argument3))
              (ZX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[2].argument3))
              (ZX.32 (READ.32[2].argument2)))
            (MUL
              (ZX.32 (READ.32[3].argument3))
              (ZX.32 (READ.32[3].argument2))))))
  - ID: DOT2SUWDP
    what: Dot products of 2x Signed by Unsigned Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming unsigned and signed integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming unsigned and signed integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                    + _ZX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2]) * _SX_32(argument2.32[2])
                    + _ZX_32(argument3.32[3]) * _SX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[0].argument3))
              (SX.32 (READ.32[0].argument2)))
            (MUL
              (ZX.32 (READ.32[1].argument3))
              (SX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[2].argument3))
              (SX.32 (READ.32[2].argument2)))
            (MUL
              (ZX.32 (READ.32[3].argument3))
              (SX.32 (READ.32[3].argument2))))))
  - ID: DOT2WZP
    what: Dot products of 2x Word Vectors into Word Zero Extended Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming integers.
      The resulting pair of words are zero-extended to 64-bit, packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0] * argument2.32[0] + argument3.32[1] * argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2] * argument2.32[2] + argument3.32[3] * argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ZX.32
            (ADD
              (MUL
                (READ.32[0].argument3)
                (READ.32[0].argument2))
              (MUL
                (READ.32[1].argument3)
                (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ZX.32
            (ADD
              (MUL
                (READ.32[2].argument3)
                (READ.32[2].argument2))
              (MUL
                (READ.32[3].argument3)
                (READ.32[3].argument2))))))
  - ID: MULWQ
    what: Multiply Word Quadruple
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four resulting words are packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULMWQ
    what: Multiply Most Significant Word Quadruple
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four most significant words of the 64-bit results are packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = (_SX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.32))))
  - ID: MULUMWQ
    what: Multiply Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming unsigned integers.
      The four most significant words of the 64-bit results are packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = (_ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i])) >> 32;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.32))))
  - ID: MULSUMWQ
    what: Multiply Signed by Unsigned Most Significant Word Quadruple
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words assuming unsigned integers and the %2 words assuming signed integers are multiplied.
      The four most significant words of the 64-bit results are packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = (_ZX_32(argument3.32[i]) * _SX_32(argument2.32[i])) >> 32;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.32))))
  - ID: MULWP
    what: Multiply Word Pair
    formats: [ MAU_DDD0, MAU_DDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are packed and stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULHQ
    what: Multiply Half Word Quadruple
    formats: [ MAU_DDD0, MAU_DDD0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MUL
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULHWQ
    what: Multiply Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULUHWQ
    what: Multiply Unsigned Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULSUHWQ
    what: Multiply Signed by Unsigned Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MADDWD
    what: Multiply-Add Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers, and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MADDUWD
    what: Multiply-Add Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers, and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: MADDSUWD
    what: Multiply-Add Signed by Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The product is added to the 64 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 + _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MADDW
    what: Multiply-Add Words
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied.
      The multiplication result is added to the value of the %1.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument1 + argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (ADD
            (READ.argument1)
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2)))))
  - ID: MSBFWD
    what: Multiply-Subtract Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers, and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MSBFUWD
    what: Multiply-Subtract Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers, and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: MSBFSUWD
    what: Multiply-Subtract Signed by Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The product is subtracted from the 64 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1) - _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (ZX.64 (READ.argument1))
          (MUL
            (ZX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MSBFW
    what: Multiply-Subtract Words
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied.
      The multiplication result is subtracted from the value of the %1.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument1 - argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (SUB
            (READ.argument1)
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2)))))
  - ID: MULWD
    what: Multiply Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers. The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MULUWD
    what: Multiply Unsigned Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers.
      The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.32 (READ.argument3))
          (ZX.32 (READ.argument2))))
  - ID: MULSUWD
    what: Multiply Signed by Unsigned Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MULW
    what: Multiply Words
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied, assuming signed integers.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (MUL
            (READ.32[0].argument3)
            (READ.32[0].argument2))))
  - ID: MADDWDP
    what: Multiply-Add Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming signed integers, and the product pair is added
      to the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDUWDP
    what: Multiply-Add Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming unsigned integers, and the product pair is added
      to the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDSUWDP
    what: Multiply-Add Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integer and the %2 words assuming signed integer are multiplied.
      The product pair is added to the 64-bit pair of the %1 and the resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MMA212W
    what: Matrix Multiply-Add 2x1x2 Word
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are added to the four words of the %1, and stored back into the %1.
    execution: |
      new argument1_x = argument1.32[0];
      new argument1_y = argument1.32[1];
      new argument1_z = argument1.32[2];
      new argument1_t = argument1.32[3];
      new result1_x = _ZX_32(argument1_x + argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument1_y + argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument1_z + argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument1_t + argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.argument1_x (READ.32[0].argument1))
        (WRITE.argument1_y (READ.32[1].argument1))
        (WRITE.argument1_z (READ.32[2].argument1))
        (WRITE.argument1_t (READ.32[3].argument1))
        (WRITE.result1_x
          (ZX.32
            (ADD
              (READ.argument1_x)
              (MUL
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_y
          (ZX.32
            (ADD
              (READ.argument1_y)
              (MUL
                (READ.32[0].argument2)
                (READ.32[1].argument3)))))
        (WRITE.result1_z
          (ZX.32
            (ADD
              (READ.argument1_z)
              (MUL
                (READ.32[1].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_t
          (ZX.32
            (ADD
              (READ.argument1_t)
              (MUL
                (READ.32[1].argument2)
                (READ.32[1].argument3)))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: MSBFWDP
    what: Multiply-Subtract Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming signed integers, and the product pair is subtracted
      from the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFUWDP
    what: Multiply-Subtract Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2, assuming unsigned integers, and the product pair is subtracted
      from the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFSUWDP
    what: Multiply-Subtract Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integer and the %2 words assuming signed integer are multiplied.
      The product pair is subtracted from the 64-bit pair of the %1 and the resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MMS212W
    what: Matrix Multiply-Subtract 2x1x2 Word
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are subtracted from the four words of the %1, and stored back into the %1.
    execution: |
      new argument1_x = argument1.32[0];
      new argument1_y = argument1.32[1];
      new argument1_z = argument1.32[2];
      new argument1_t = argument1.32[3];
      new result1_x = _ZX_32(argument1_x - argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument1_y - argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument1_z - argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument1_t - argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.argument1_x (READ.32[0].argument1))
        (WRITE.argument1_y (READ.32[1].argument1))
        (WRITE.argument1_z (READ.32[2].argument1))
        (WRITE.argument1_t (READ.32[3].argument1))
        (WRITE.result1_x
          (ZX.32
            (SUB
              (READ.argument1_x)
              (MUL
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_y
          (ZX.32
            (SUB
              (READ.argument1_y)
              (MUL
                (READ.32[0].argument2)
                (READ.32[1].argument3)))))
        (WRITE.result1_z
          (ZX.32
            (SUB
              (READ.argument1_z)
              (MUL
                (READ.32[1].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_t
          (ZX.32
            (SUB
              (READ.argument1_t)
              (MUL
                (READ.32[1].argument2)
                (READ.32[1].argument3)))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: MULWDP
    what: Multiply Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words , assuming signed integers.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULUWDP
    what: Multiply Unsigned Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming unsigned integers.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULSUWDP
    what: Multiply Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integers and the %2 words assuming signed integers are multiplied.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MM212W
    what: Matrix Multiply 2x1x2 Word Quadruple
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are stored back into the %1.
    execution: |
      new result1_x = _ZX_32(argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.result1_x
          (ZX.32
            (MUL
              (READ.32[0].argument2)
              (READ.32[0].argument3))))
        (WRITE.result1_y
          (ZX.32
            (MUL
              (READ.32[0].argument2)
              (READ.32[1].argument3))))
        (WRITE.result1_z
          (ZX.32
            (MUL
              (READ.32[1].argument2)
              (READ.32[0].argument3))))
        (WRITE.result1_t
          (ZX.32
            (MUL
              (READ.32[1].argument2)
              (READ.32[1].argument3))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: FFMAD
    what: Floating-Point Fused Multiply-Add Double
    class: FPU
    formats: [ MAU_FMAD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 64 floating-point
      numbers, and the product is added to the %1. The result is rounded
      to the binary 64 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_mulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWP
    what: Floating-Point Fused Multiply-Add Word Pair
    class: FPU
    formats: [ MAU_FMAWP ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number pairs, and the product pair is added to the %1. The resulting pair is rounded
      to the binary 32 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulAdd_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulAdd_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAHQ
    what: Floating-Point Fused Multiply-Add Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number quadruples, and the product quadruple is added to the %1. The resulting quadruple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulAdd_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulAdd_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWQ
    what: Floating-Point Fused Multiply-Add Word Quadruple
    class: FPU
    formats: [ MAU_FMAWQ ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number quadruples, and the product quadruple is added to the %1. The resulting quadruple is rounded
      to the binary 32 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulAdd_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulAdd_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAHO
    what: Floating-Point Fused Multiply-Add Half Word Octuple
    class: FPU
    formats: [ MAU_FQQQQ ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number octuples, and the product octuple is added to the %1. The resulting octuple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulAdd_x8(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulAdd_x8
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSD
    what: Floating-Point Fused Multiply-Subtract Double
    class: FPU
    formats: [ MAU_FMAD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 64 floating-point
      numbers, and the product is subtracted from the %1. The result is
      rounded to the binary 64 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_mulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWP
    what: Floating-Point Fused Multiply-Subtract Word Pair
    class: FPU
    formats: [ MAU_FMAWP ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number pairs, and the product pair is subtracted from the %1. The resulting pair is
      rounded to the binary 32 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulSub_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulSub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHQ
    what: Floating-Point Fused Multiply-Subtract Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number quadruples, and the product quadruple is subtracted from the %1. The resulting quadruple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulSub_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulSub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWQ
    what: Floating-Point Fused Multiply-Subtract Word Quadruple
    class: FPU
    formats: [ MAU_FMAWQ ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number quadruples, and the product quadruple is subtracted from the %1. The resulting quadruple is
      rounded to the binary 32 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulSub_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulSub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHO
    what: Floating-Point Fused Multiply-Subtract Half Word Octuple
    class: FPU
    formats: [ MAU_FQQQQ ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number octuples, and the product octuple is subtracted from the %1. The resulting octuple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulSub_x8(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulSub_x8
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FMULD
    what: Floating-Point Multiply Double Word
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 64 floating-point
      numbers. The result is rounded to the binary 64 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_mul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWP
    what: Floating-Point Multiply Word Pair
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number pairs. The resulting pair is rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULHQ
    what: Floating-Point Multiply Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point
      number quadruples. The results are rounded to the binary 16 floating-point
      format according to the rounding mode set in the CS register, packed and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f16_mul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWDP
    what: Floating-Point Multiply Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number pairs. The resulting pair is rounded to the binary 64 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_widenMul_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMul_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULHWQ
    what: Floating-Point Multiply Half Word to Word Quadruple
    class: FPU
    formats: [ MAU_FQDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point
      number quadruples. The results are rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register, packed and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_widenMul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
## - ID: FMULDP
## what: Floating-Point Multiply Double Word Pair
## class: FPU
## formats: [ MAU_FQQQ0 ]
## description: >
## The %2 is multiplied by the %3, assuming binary 64 floating-point
## number pairs. The resulting pair is rounded to the binary 64 floating-point
## format according to the rounding mode set in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
## execution: |
## new result1 = f64_mul_x2(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.f64_mul_x2
## (READ.RM)
## (READ.argument2)
## (READ.argument3)
## (READ.argument3)
## )
## )
  - ID: FMULWQ
    what: Floating-Point Multiply Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number quadruples. The resulting quadruple is rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULHO
    what: Floating-Point Multiply Half Word Octuple
    class: FPU
    formats: [ MAU_FQQQ2 ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point
      number octuples. The resulting octuple is rounded to the binary 16 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f16_mul_x8(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mul_x8
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWC
    what: Floating-Point Multiply Word Complex
    class: FPU
    formats: [ MAU_FMULCW ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      These numbers are multiplied according to the rounding mode set in the CS register.
      If the %4 is set, the complex conjugate of the %2 is used in the complex multiplication.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32(argument2);
      }
      new result1 = fmulc_32_32(RM, argument2, argument3);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.64.fconj_32_32
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.fmulc_32_32
            (READ.RM)
            (READ.argument2)
            (READ.argument3))))
  - ID: FFMAWC
    what: Floating-Point Multiply Add Word Complex
    class: FPU
    formats: [ MAU_FMAWC ]
    description: >
      The %1, the %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The %2 is multiplied by the %3 to produce a complex product.
      If the %4 is set, the complex conjugate of the %2 is used in the complex multiplication.
      The complex product is added to the %1 and rounded according to the rounding mode.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32(argument2);
      }
      new result1 = ffmac_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.64.fconj_32_32
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.ffmac_32_32
            (READ.RM)
            (READ.argument2)
            (READ.argument3)
            (READ.argument1))))
  - ID: FFMSWC
    what: Floating-Point Multiply Subtract Word Complex
    class: FPU
    formats: [ MAU_FMAWC ]
    description: >
      The %1, the %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The %2 is multiplied by the %3 to produce a complex product.
      If the %4 is set, the complex conjugate of the %2 is used in the complex multiplication.
      The complex product is subtracted from the %1 and rounded according to the rounding mode.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32(argument2);
      }
      new result1 = ffmsc_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.64.fconj_32_32
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.ffmsc_32_32
            (READ.RM)
            (READ.argument2)
            (READ.argument3)
            (READ.argument1))))
  - ID: FMULWCP
    what: Floating-Point Multiply Word Complex Pair
    class: FPU
    formats: [ MAU_FMULWCP ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low complex product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high complex product.
      If the %4 is set, the complex conjugates of the %2 are used in the complex multiplication.
      The resulting binary 32 floating-point complex number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32_x2(argument2);
      }
      new result1 = fmulc_32_32_x2(RM, argument2, argument3);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.128.fconj_32_32_x2
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.fmulc_32_32_x2
            (READ.RM)
            (READ.argument2)
            (READ.argument3))))
  - ID: FFDMAW
    what: Floating-Point Fused Dual Multiply Add Word
    class: FPU
    formats: [ MAU_FDMAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the low product and the high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdma_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdma_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMAWP
    what: Floating-Point Fused Dual Multiply Add Word Pair
    class: FPU
    formats: [ MAU_FDMAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the low product pair and the high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdma_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdma_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMAWQ
    what: Floating-Point Fused Dual Multiply Add Word Quadruple
    class: FPU
    formats: [ MAU_FDMAWQ ]
    description: >
      The %3 and the %2 are considered as quadruples of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product quadruple.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product quadruple.
      The sums of the low product quadruple and the high product quadruple are rounded according to the rounding mode.
      The resulting binary 32 floating-point number quadruple is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdma_32_32_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdma_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMSW
    what: Floating-Point Fused Dual Multiply Subtract Word
    class: FPU
    formats: [ MAU_FDMAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the low product and the negated high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdms_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdms_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMSWP
    what: Floating-Point Fused Dual Multiply Subtract Word Pair
    class: FPU
    formats: [ MAU_FDMAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the low product pair and the negated high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdms_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdms_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMSWQ
    what: Floating-Point Fused Dual Multiply Subtract Word Quadruple
    class: FPU
    formats: [ MAU_FDMAWQ ]
    description: >
      The %3 and the %2 are considered as quadruples of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product quadruple.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product quadruple.
      The sums of the low product quadruple and the negated high product quadruple are rounded according to the rounding mode.
      The resulting binary 32 floating-point number quadruple is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdms_32_32_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.ffdms_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFDMDAW
    what: Floating-Point Fused Dual Multiply Dual Add Word
    class: FPU
    formats: [ MAU_FDMDAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the %1, the low product and the high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmda_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmda_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMDAWP
    what: Floating-Point Fused Dual Multiply Dual Add Word Pair
    class: FPU
    formats: [ MAU_FDMDAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the %1, the low product pair and the high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmda_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmda_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMDAWQ
    what: Floating-Point Fused Dual Multiply Dual Add Word Quadruple
    class: FPU
    formats: [ MAU_FDMDAWQ ]
    description: >
      The %3 and the %2 are considered as quadruples of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product quadruple.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product quadruple.
      The sums of the %1, the low product quadruple and the high product quadruple are rounded according to the rounding mode.
      The resulting binary 32 floating-point number quadruple is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmda_32_32_x4(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmda_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMSAW
    what: Floating-Point Fused Dual Multiply Subtract Add Word
    class: FPU
    formats: [ MAU_FDMDAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the %1, the negated low product and the high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmsa_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmsa_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMSAWP
    what: Floating-Point Fused Dual Multiply Subtract Add Word Pair
    class: FPU
    formats: [ MAU_FDMDAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the %1, the negated low product pair and the high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmsa_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmsa_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMSAWQ
    what: Floating-Point Fused Dual Multiply Subtract Add Word Quadruple
    class: FPU
    formats: [ MAU_FDMDAWQ ]
    description: >
      The %3 and the %2 are considered as quadruples of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product quadruple.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product quadruple.
      The sums of the %1, the negated low product quadruple and the high product quadruple are rounded according to the rounding mode.
      The resulting binary 32 floating-point number quadruple is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmsa_32_32_x4(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmsa_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMDSW
    what: Floating-Point Fused Dual Multiply Dual Subtract Word
    class: FPU
    formats: [ MAU_FDMDAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the %1, the negated low product and the negated high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmds_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmds_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMDSWP
    what: Floating-Point Fused Dual Multiply Dual Subtract Word Pair
    class: FPU
    formats: [ MAU_FDMDAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the %1, the negated low product pair and the negated high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmds_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmds_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMDSWQ
    what: Floating-Point Fused Dual Multiply Dual Subtract Word Quadruple
    class: FPU
    formats: [ MAU_FDMDAWQ ]
    description: >
      The %3 and the %2 are considered as quadruples of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product quadruple.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product quadruple.
      The sums of the %1, the negated low product quadruple and the negated high product quadruple are rounded according to the rounding mode.
      The resulting binary 32 floating-point number quadruple is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmds_32_32_x4(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmds_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMASW
    what: Floating-Point Fused Dual Multiply Add Subtract Word
    class: FPU
    formats: [ MAU_FDMDAW ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high product.
      The sum of the %1, the low product and the negated high product is rounded according to the rounding mode.
      The resulting binary 32 floating-point number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmas_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmas_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMASWP
    what: Floating-Point Fused Dual Multiply Add Subtract Word pair
    class: FPU
    formats: [ MAU_FDMDAWP ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the %1, the low product pair and the negated high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmas_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmas_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FFDMASWQ
    what: Floating-Point Fused Dual Multiply Add Subtract Word Quadruple
    class: FPU
    formats: [ MAU_FDMDAWQ ]
    description: >
      The %3 and the %2 are considered as pairs of pairs of binary 32 floating-point numbers.
      The low half of each %2 inner pair is multiplied by the low half of each %3 inner pair to produce a low product pair.
      The high half of each %2 inner pair is multiplied by the high half of each %3 inner pair to produce a high product pair.
      The sums of the %1, the low product pair and the negated high product pair are rounded according to the rounding mode.
      The resulting binary 32 floating-point number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = ffdmas_32_32_x4(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.ffdmas_32_32_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FMM212W
    what: Floating-Point Matrix Multiply 2x1x2 Word
    class: FPU
    formats: [ MAU_FMMW ]
    description: >
      The %1 is considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %3 and the %2 are considered as 2-element vectors of 32 floating-point numbers.
      The matrix multiplication between the %2 words and the %3 words is computed using one product per element.
      The resulting four binary 32 floating-point numbers are stored into the %1 in row-major order.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmm212_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmm212_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FMM222W
    what: Floating-Point Matrix Multiply 2x2x2 Word
    class: FPU
    formats: [ MAU_FMMWP ]
    description: >
      The %1, the %3 and the %2 are considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %2 and the %3 are assumed row-major or column-major layout, as respectively specified by bits 0 and 1 of the %4.
      The matrix multiplication between the %2 words and the %3 words is computed using a 2-deep dot product per element.
      The resulting four binary 32 floating-point numbers are stored into the %1 in row-major order.
      Each dot product is rounded once according to the rounding mode.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmm222_32_32(RM, argument2, argument3, transpose);
    behavior: |
      (WRITE.result1
        (APPLY.fmm222_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.transpose)))
  - ID: FMMA212W
    what: Floating-Point Matrix Multiply Add 2x1x2 Word
    class: FPU
    formats: [ MAU_FMMAW ]
    description: >
      The %1 is considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %3 and the %2 are considered as 2-element vectors of 32 floating-point numbers.
      The matrix multiplication between the %2 words and the %3 words is computed using one product per element.
      The resulting four binary 32 floating-point numbers are added to the %1 elements in row-major order.
      The sum of each product and the corresponding element of the %1 is rounded according to the rounding mode.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmma212_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.fmma212_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FMMA222W
    what: Floating-Point Matrix Multiply Add 2x2x2 Word
    class: FPU
    formats: [ MAU_FMMAWP ]
    description: >
      The %1, the %3 and the %2 are considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %2 and the %3 are assumed row-major or column-major layout, as respectively specified by bits 0 and 1 of the %4.
      The matrix multiplication between the %2 words and the %3 words is computed using a 2-deep dot product per element.
      The resulting four binary 32 floating-point numbers are added to the %1 elements in row-major order.
      The sum of each dot product and the corresponding element of the %1 is rounded according to the rounding mode.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmma222_32_32(RM, argument2, argument3, argument1, transpose);
    behavior: |
      (WRITE.result1
        (APPLY.fmma222_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)
          (READ.transpose)))
  - ID: FMMS212W
    what: Floating-Point Matrix Multiply Subtract 2x1x2 Word
    class: FPU
    formats: [ MAU_FMMAW ]
    description: >
      The %1 is considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %3 and the %2 are considered as 2-element vectors of 32 floating-point numbers.
      The matrix multiplication between the %2 words and the %3 words is computed using one product per element.
      The resulting four binary 32 floating-point numbers are subtracted from the %1 elements in row-major order.
      The sum of each negated product and the corresponding element of the %1 is rounded according to the rounding mode.
      The resulting four binary 32 floating-point numbers are stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmms212_32_32(RM, argument2, argument3, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.fmms212_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)))
  - ID: FMMS222W
    what: Floating-Point Matrix Multiply Subtract 2x2x2 Word
    class: FPU
    formats: [ MAU_FMMAWP ]
    description: >
      The %1, the %3 and the %2 are considered as a $2\times 2$ matrix of binary 32 floating-point numbers packed into 128 bits.
      The %2 and the %3 are assumed row-major or column-major layout, as respectively specified by bits 0 and 1 of the %4.
      The matrix multiplication between the %2 words and the %3 words is computed using a 2-deep dot product per element.
      The resulting four binary 32 floating-point numbers subtracted from to the %1 elements in row-major order.
      The sum of each negated dot product and the corresponding element of the %1 is rounded according to the rounding mode.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmms222_32_32(RM, argument2, argument3, argument1, transpose);
    behavior: |
      (WRITE.result1
        (APPLY.fmms222_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
          (READ.argument1)
          (READ.transpose)))
  - ID: FFMAWCP
    what: Floating-Point Multiply Add Word Complex Pair
    class: FPU
    formats: [ MAU_FMAWCP ]
    description: >
      The %1, the %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low complex product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high complex product.
      If the %4 is set, the complex conjugates of the %2 are used in the complex multiplication.
      The complex product pair is added to the %1 and rounded according to the rounding mode.
      The resulting binary 32 floating-point complex number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32_x2(argument2);
      }
      new result1 = ffmac_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.128.fconj_32_32_x2
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.ffmac_32_32_x2
            (READ.RM)
            (READ.argument2)
            (READ.argument3)
            (READ.argument1))))
  - ID: FFMSWCP
    what: Floating-Point Multiply Subtract Word Complex Pair
    class: FPU
    formats: [ MAU_FMAWCP ]
    description: >
      The %1, the %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The low half of the %2 is multiplied by the low half of the %3 to produce a low complex product.
      The high half of the %2 is multiplied by the high half of the %3 to produce a high complex product.
      If the %4 is set, the complex conjugates of the %2 are used in the complex multiplication.
      The complex product pair is subtracted from the %1 and rounded according to the rounding mode.
      The resulting binary 32 floating-point complex number pair is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      if (conjugate) {
        argument2 = fconj_32_32_x2(argument2);
      }
      new result1 = ffmsc_32_32_x2(RM, argument2, argument3, argument1);
    behavior: |
      (SEQ
        (IF
          (I2B (READ.conjugate))
          (WRITE.argument2
            (APPLY.128.fconj_32_32_x2
              (READ.argument2)))
           (SKIP))
        (WRITE.result1
          (APPLY.ffmsc_32_32_x2
            (READ.RM)
            (READ.argument2)
            (READ.argument3)
            (READ.argument1))))
  - ID: FADDD
    what: Floating-Point Add Double Word
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 64 floating-point numbers.
      The result is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_add(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_add
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWP
    what: Floating-Point Add Word Pair
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point number pairs.
      The resulting pair is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_add_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDHQ
    what: Floating-Point Add Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 16 floating-point number quadruples.
      The results are rounded to the binary 16 floating-point format
      according to the rounding mode set in the CS register, packed and stored
      into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f16_add_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_add_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDDP
    what: Floating-Point Add Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %2 is added to the %3, assuming binary 64 floating-point number pairs.
      The resulting pair is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_add_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_add_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWQ
    what: Floating-Point Add Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point number quadruples.
      The resulting quadruple is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_add_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDHO
    what: Floating-Point Add Half Word Octuple
    class: FPU
    formats: [ MAU_FQQQ2 ]
    description: >
      The %2 is added to the %3, assuming binary 16 floating-point number octuples.
      The resulting octuple is rounded to the binary 16 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f16_add_x8(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_add_x8
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWC.C
    what: Floating-Point Add Word Complex Conjugate
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is added to the %3, according to the rounding mode set in the CS register.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.faddcc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FADDDC.C
    what: Floating-Point Add Double Word Complex Conjugate
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %3 and the %2 are considered as binary 64 floating-point complex numbers.
      The conjugate of the %2 is added to the %3, according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_64_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.faddcc_64_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FADDWCP.C
    what: Floating-Point Add Word Complex Pair Conjugate
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The conjugate of the %2 pair is added to the %3 pair, according to the rounding mode set in the CS register.
      The resulting pair of binary 32 floating-point complex numbers is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.faddcc_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFD
    what: Floating-Point Subtract From Double Word
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 64
      floating-point numbers. The result is rounded to the binary 64
      floating-point format according to the rounding mode set in the CS
      register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f64_sub(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_sub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWP
    what: Floating-Point Subtract From Word Pair
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32
      floating-point number pairs. The resulting pair is rounded to the binary 32
      floating-point format according to the rounding mode stored in the
      CS register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub_x2(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFHQ
    what: Floating-Point Subtract From Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 16 floating-point number quadruples.
      The results are rounded to the binary 16 floating-point format
      according to the rounding mode set in the CS register, packed and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f16_sub_x4(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f16_sub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFDP
    what: Floating-Point Subtract Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 64 floating-point number pairs.
      The resulting pair is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_sub_x2(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_sub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWQ
    what: Floating-Point Subtract From Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32
      floating-point number quadruples. The resulting quadruple is rounded to the binary 32
      floating-point format according to the rounding mode stored in the
      CS register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub_x4(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFHO
    what: Floating-Point Subtract From Half Word Octuple
    class: FPU
    formats: [ MAU_FQQQ2 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 16
      floating-point number octuples. The resulting octuple is rounded to the binary 16
      floating-point format according to the rounding mode stored in the
      CS register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f16_sub_x8(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f16_sub_x8
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWC.C
    what: Floating-Point Subtract From Word Complex Conjugate
    class: FPU
    formats: [ MAU_FDDD1 ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is subtracted from the %3, according to the rounding mode set in the CS register.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fsbfcc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFDC.C
    what: Floating-Point Subtract From Double Word Complex Conjugate
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %3 and the %2 are considered as binary 64 floating-point complex numbers.
      The conjugate of the %2 is subtracted from the %3, according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_64_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fsbfcc_64_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFWCP.C
    what: Floating-Point Subtract From Word Complex Pair Conjugate
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The conjugate of the %2 pair is subtracted from the %3 pair, according to the rounding mode set in the CS register.
      The resulting pair of binary 32 floating-point complex numbers is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.fsbfcc_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFMAHW
    what: Floating-Point Fused Multiply-Add Half Words to Word
    class: FPU
    formats: [ MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      numbers, and the product is added to the %1, assuming binary 32
      floating-point format. The result is rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAW
    what: Floating-Point Fused Multiply-Add Words
    class: FPU
    formats: [ MAU_FMAW ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is added to the %1. The result is rounded
      to the binary 32 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWD
    what: Floating-Point Fused Multiply-Add Words to Double Word
    class: FPU
    formats: [ MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is added to the %1, assuming binary 64
      floating-point format. The result is rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWDP
    what: Floating-Point Fused Multiply-Add Words to Double Word Pair
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming pairs of binary 32 floating-point
      numbers, and the pair of products is added to the %1, assuming a pair of binary 64
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulAdd_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulAdd_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAHWQ
    what: Floating-Point Fused Multiply-Add Half Words to Word Quadruple
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming quadruples of binary 16 floating-point
      numbers, and the quadruples of products is added to the %1, assuming a quadruple of binary 32
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulAdd_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulAdd_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHW
    what: Floating-Point Fused Multiply-Subtract Half Words to Word
    class: FPU
    formats: [ MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      numbers, and the product is subtracted from the %1, assuming
      binary 32 floating-point format. The result is rounded according
      to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSW
    what: Floating-Point Fused Multiply-Subtract Words
    class: FPU
    formats: [ MAU_FMAW ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is subtracted from the %1. The result is
      rounded to the binary 32 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWD
    what: Floating-Point Fused Multiply-Subtract Words to Double Word
    class: FPU
    formats: [ MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is subtracted from the %1, assuming
      binary 64 floating-point format. The result is rounded according
      to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWDP
    what: Floating-Point Fused Multiply-Subtract Words to Double Word Pair
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming pairs of binary 32 floating-point
      numbers, and the pair of products is subtracted from the %1, assuming a pair of binary 64
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulSub_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulSub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHWQ
    what: Floating-Point Fused Multiply-Subtract Half Words to Word Quadruple
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming quadruples of binary 16 floating-point
      numbers, and the quadruples of products is subtracted from the %1, assuming a quadruple of binary 32
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulSub_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulSub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
## - ID: FADDH
## what: Floating-Point Add Half Words
## class: FPU
## formats: [ MAU_FSSS, MAU_FSSS.X ]
## description: >
## The %2 is added to the %3, assuming binary 16 floating-point numbers.
## The result is rounded to the binary 16 floating-point format
## according to the rounding mode set in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow exception bits in the CS register.
## execution: |
## new result1 = f16_add(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.f16_add
## (READ.RM)
## (READ.argument2)
## (READ.argument3)
## )
## )
  - ID: FADDW
    what: Floating-Point Add Words
    class: FPU
    formats: [ MAU_FSSS ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_add(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
## - ID: FSBFH
## what: Floating-Point Subtract From Half Words
## class: FPU
## formats: [ MAU_FSSS, MAU_FSSS.X ]
## description: >
## The %2 is subtracted from the %3, assuming binary 16 floating-point numbers.
## The result is rounded to the binary 16 floating-point format
## according to the rounding mode stored in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow exception bits in the CS register.
## execution: |
## new result1 = f16_sub(RM, argument3, argument2);
## behavior: |
## (WRITE.result1
## (APPLY.f16_sub
## (READ.RM)
## (READ.argument3)
## (READ.argument2)
## )
## )
  - ID: FSBFW
    what: Floating-Point Subtract From Words
    class: FPU
    formats: [ MAU_FSSS ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode stored in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FMULHW
    what: Floating-Point Multiply Half Words to Word
    class: FPU
    formats: [ MAU_FSSS ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_widenMul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULW
    what: Floating-Point Multiply Words
    class: FPU
    formats: [ MAU_FSSS ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWD
    what: Floating-Point Multiply Words to Double Word
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_widenMul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FDOT2W
    what: Floating-Point Dot Product x2 Word
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 32 floating-point number is stored back into the %1.
    execution: |
      new result1 = fdot2_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WD
    what: Floating-Point Dot Product x2 Word to Double Word
    class: FPU
    formats: [ MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 64 floating-point number is stored back into the %1.
    execution: |
      new result1 = fdot2_32_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WZP
    what: Floating-Point Dot Product x2 Word Zero Extended Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 32 floating-point number is zero-extended to 64 bits and stored back into the %1.
    execution: |
      new result1 = fdot2_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.fdot2_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WDP
    what: Floating-Point Dot Product x2 Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming binary 32 floating-point numbers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming binary 32 floating-point numbers.
      The resulting pair of binary 64 floating-point numbers is packed and stored back into the %1.
    execution: |
      new result1 = fdot2_32_64_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_64_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: COPYQ
    what: Copy Quadruple Word
    formats: [ MAU_COPYQ ]
    description: >
      The %1 operand receives the concatenation of the %2 and %3 values.
    execution: |
      new result1 = _ZX_64(argument2) | (argument3 << 64);
    behavior: |
      (WRITE.result1
        (IOR
          (ZX.64 (READ.argument2))
          (SHL (READ.argument3) (CONST.64))))
  - ID: COPYO
    what: Copy Octuple Word
    formats: [ LSU_COPYO ]
    description: >
      The %1 operand receives the %2 value.
    execution: |
      new result1 = argument2;
    behavior: |
      (WRITE.result1
        (READ.argument2))
  - ID: XSPLATDO
    what: Move To Extension Double Word
    formats: [ ALU_XSDOI, ALU_XSDOI.X, ALU_XSDOI.Y ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the %2 value replicated 4 times.
    execution: |
      new result1 = 0;
      result1.64[0] = argument2;
      result1.64[1] = argument2;
      result1.64[2] = argument2;
      result1.64[3] = argument2;
    behavior: |
      (SEQ
        (WRITE.result1 (CONST.0))
        (WRITE.64[0].result1 (READ.argument2))
        (WRITE.64[1].result1 (READ.argument2))
        (WRITE.64[2].result1 (READ.argument2))
        (WRITE.64[3].result1 (READ.argument2)))
  - ID: XMOVETD
    what: Move To Extension Double Word
    formats: [ ALU_XMTD0, ALU_XMTD1, ALU_XMTD2, ALU_XMTD3 ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the %2 value.
    execution: |
      new result1 = _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (ZX.64 (READ.argument2)))
  - ID: XMOVETQ
    what: Move To Extension Quadruple Word
    formats: [ ALU_XMTQ0, ALU_XMTQ1 ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the concatenation of the %2 value and the %3 value.
    execution: |
      new result1 = 0;
      result1.64[0] = argument2;
      result1.64[1] = argument3;
    behavior: |
      (SEQ
        (WRITE.result1 (CONST.0))
        (WRITE.64[0].result1 (READ.argument2))
        (WRITE.64[1].result1 (READ.argument3)))
  - ID: XSENDO
    what: Send Extension Octuple Word to Channel
    formats: [ ALU_CSC ]
    properties: { '%0': Extension }
    description: >
      The %1 operand is sent to the channel designated by the %2.
    execution: |
      stage E4:
      if (!comm_owner) {
        _THROW(PRIVILEGE);
      } else {
        sendv(argument, schannel ^ exchange);
      }
    behavior: |
     (SEQ
        (IF (NOTL (TEST.comm_owner))
          (THROW.E4.PRIVILEGE)
          (EFFECT.E4.sendv
            (READ.argument) (XOR (READ.schannel) (READ.exchange)))))
  - ID: XRECVO
    what: Receive Extension Octuple Word from Channel
    formats: [ ALU_CRC ]
    properties: { '%0': Extension }
    description: >
      The %1 operand is received from the channel designated by the %2.
    execution: |
      if (!comm_owner) {
        _THROW(PRIVILEGE);
      } else {
        new result = recvv(rchannel ^ exchange);
      }
    behavior: |
     (SEQ
        (IF (NOTL (TEST.comm_owner))
          (THROW.RR.PRIVILEGE)
          (WRITE.result
            (APPLY.recvv (XOR (READ.rchannel) (READ.exchange))))))
  - ID: XSENDRECVO
    what: Send and Receive Octuple Word to/from Channels
    formats: [ ALU_CSRC ]
    properties: { '%0': Extension }
    description: >
      The %2 operand is sent to the channel designated by the %4.
      The %1 operand is received from the channel designated by the %3.
    execution: |
      if (!comm_owner) {
        _THROW(PRIVILEGE);
      } else {
        new result = sendrecvv(argument, schannel ^ exchange, rchannel ^ exchange);
      }
    behavior: |
     (SEQ
        (IF (NOTL (TEST.comm_owner))
          (THROW.RR.PRIVILEGE)
          (SEQ
            (WRITE.result
              (APPLY.sendrecvv
                (READ.argument)
                  (XOR (READ.schannel) (READ.exchange))
                  (XOR (READ.rchannel) (READ.exchange)))))))
  - ID: XACCESSO
    what: Access from Extension into Octuple Word
    formats: [ BCU_XACCESSO2, BCU_XACCESSO4, BCU_XACCESSO8, BCU_XACCESSO16, BCU_XACCESSO32, BCU_XACCESSO64 ]
    properties: { '%0': Extension }
    description: &descriptionXALIGN >
      The 5 least significant bits of the %3 are interpreted as a byte count. The most significant
      bits of the %3 are interpreted as a vector register index into the buffer specified by the %2.
      The vector register indexed and its successor modulo the buffer size are concatenated, and
      shifted right bt the byte count. The resulting 32 bytes are written to the %1.
    execution: &executionXALIGN |
      new shift = (address & 31) * 8;
      new index_0 = address >> 5;
      new index_1 = index_0 + 1;
      new where_0 = buffer + (index_0 & mask);
      new where_1 = buffer + (index_1 & mask);
      new result1_0 = XVR[where_0];
      new result1_1 = XVR[where_1];
      new result1 = result1_0;
      if (shift) {
        result1 = (_ZX_256(result1_0) >> shift) | (_ZX_256(result1_1) << (256 - shift));
      }
    behavior: &behaviorXALIGN |
      (SEQ
        (WRITE.shift
          (MUL
            (AND
              (READ.address)
              (CONST.31))
            (CONST.8)))
        (WRITE.index_0
          (SHR
            (READ.address)
            (CONST.5)))
        (WRITE.index_1
          (ADD
            (READ.index_0)
            (CONST.1)))
        (WRITE.where_0
          (ADD
            (READ.buffer)
            (AND
              (READ.index_0)
              (READ.mask))))
        (WRITE.where_1
          (ADD
            (READ.buffer)
            (AND
              (READ.index_1)
              (READ.mask))))
        (WRITE.result1_0
          (F2I.256 (LOAD.RR (AGGL.XVR (READ.where_0) (CONST.1)))))
        (WRITE.result1_1
          (F2I.256 (LOAD.RR (AGGL.XVR (READ.where_1) (CONST.1)))))
        (WRITE.result1
          (READ.result1_0))
        (IF
          (I2B (READ.shift))
          (WRITE.result1
            (IOR
              (SHR
                (ZX.256 (READ.result1_0))
                (READ.shift))
              (SHL
                (ZX.256
                  (READ.result1_1))
                (SUB
                  (CONST.256)
                  (READ.shift)))))
          (SKIP)))
  - ID: XALIGNO
    what: Align Extension into Octuple Word
    formats: [ BCU_XALIGNO2, BCU_XALIGNO4, BCU_XALIGNO8, BCU_XALIGNO16, BCU_XALIGNO32, BCU_XALIGNO64 ]
    properties: { '%0': Extension }
    description: *descriptionXALIGN
    execution: *executionXALIGN
    behavior: *behaviorXALIGN
  - ID: XSPLATOX
    what: Splat Word Octuple to Hexadecuple
    class: EXT
    formats: [ EXT_XSPLATOX ]
    properties: { '%0': Extension }
    description: >
      The %2 is duplicated to produce a hexadecuple word (512 bits). Depending on the %3, the
      eight double words that compose these 512 bits are shuffled and the result is stored back into the %1.
    execution: &executionXSPLATOX |
      new result1_0 = argument2_0;
      new result1_1 = argument2_1;
      if (shuffleX == 1) {
        result1_0 = join_64_x4(argument2_0.64[0], argument2_1.64[0], argument2_0.64[1], argument2_1.64[1]);
        result1_1 = join_64_x4(argument2_0.64[2], argument2_1.64[2], argument2_0.64[3], argument2_1.64[3]);
      }
      if (shuffleX == 2) {
        result1_0 = join_64_x4(argument2_0.64[0], argument2_0.64[2], argument2_1.64[0], argument2_1.64[2]);
        result1_1 = join_64_x4(argument2_0.64[1], argument2_0.64[3], argument2_1.64[1], argument2_1.64[3]);
      }
      if (shuffleX == 3) {
        result1_0 = join_64_x4(argument2_0.64[0], argument2_0.64[1], argument2_1.64[0], argument2_1.64[1]);
        result1_1 = join_64_x4(argument2_0.64[2], argument2_0.64[3], argument2_1.64[2], argument2_1.64[3]);
      }
      if (shuffleX == 4) {
        result1_0 = join_32_x8(argument2_0.32[0], argument2_0.32[2], argument2_0.32[1], argument2_0.32[3], argument2_1.32[0], argument2_1.32[2], argument2_1.32[1], argument2_1.32[3]);
        result1_1 = join_32_x8(argument2_0.32[4], argument2_0.32[6], argument2_0.32[5], argument2_0.32[7], argument2_1.32[4], argument2_1.32[6], argument2_1.32[5], argument2_1.32[7]);
      }
      if (shuffleX == 5) {
        result1_0 = join_32_x8(argument2_0.32[0], argument2_1.32[0], argument2_0.32[1], argument2_1.32[1], argument2_0.32[2], argument2_1.32[2], argument2_0.32[3], argument2_1.32[3]);
        result1_1 = join_32_x8(argument2_0.32[4], argument2_1.32[4], argument2_0.32[5], argument2_1.32[5], argument2_0.32[6], argument2_1.32[6], argument2_0.32[7], argument2_1.32[7]);
      }
      if (shuffleX == 6) {
        result1_0 = join_32_x8(argument2_0.32[0], argument2_0.32[2], argument2_0.32[4], argument2_0.32[6], argument2_1.32[0], argument2_1.32[2], argument2_1.32[4], argument2_1.32[6]);
        result1_1 = join_32_x8(argument2_0.32[1], argument2_0.32[3], argument2_0.32[5], argument2_0.32[7], argument2_1.32[1], argument2_1.32[3], argument2_1.32[5], argument2_1.32[7]);
      }
    behavior: &behaviorXSPLATOX |
      (SEQ
        (WRITE.result1_0
          (READ.argument2_0))
        (WRITE.result1_1
          (READ.argument2_1))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.1))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_64_x4
                (READ.64[0].argument2_0)
                (READ.64[0].argument2_1)
                (READ.64[1].argument2_0)
                (READ.64[1].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_64_x4
                (READ.64[2].argument2_0)
                (READ.64[2].argument2_1)
                (READ.64[3].argument2_0)
                (READ.64[3].argument2_1))))
          (SKIP))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.2))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_64_x4
                (READ.64[0].argument2_0)
                (READ.64[2].argument2_0)
                (READ.64[0].argument2_1)
                (READ.64[2].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_64_x4
                (READ.64[1].argument2_0)
                (READ.64[3].argument2_0)
                (READ.64[1].argument2_1)
                (READ.64[3].argument2_1))))
          (SKIP))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.3))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_64_x4
                (READ.64[0].argument2_0)
                (READ.64[1].argument2_0)
                (READ.64[0].argument2_1)
                (READ.64[1].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_64_x4
                (READ.64[2].argument2_0)
                (READ.64[3].argument2_0)
                (READ.64[2].argument2_1)
                (READ.64[3].argument2_1))))
          (SKIP))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.4))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_32_x8
                (READ.32[0].argument2_0)
                (READ.32[2].argument2_0)
                (READ.32[1].argument2_0)
                (READ.32[3].argument2_0)
                (READ.32[0].argument2_1)
                (READ.32[2].argument2_1)
                (READ.32[1].argument2_1)
                (READ.32[3].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_32_x8
                (READ.32[4].argument2_0)
                (READ.32[6].argument2_0)
                (READ.32[5].argument2_0)
                (READ.32[7].argument2_0)
                (READ.32[4].argument2_1)
                (READ.32[6].argument2_1)
                (READ.32[5].argument2_1)
                (READ.32[7].argument2_1))))
          (SKIP))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.5))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_32_x8
                (READ.32[0].argument2_0)
                (READ.32[0].argument2_1)
                (READ.32[1].argument2_0)
                (READ.32[1].argument2_1)
                (READ.32[2].argument2_0)
                (READ.32[2].argument2_1)
                (READ.32[3].argument2_0)
                (READ.32[3].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_32_x8
                (READ.32[4].argument2_0)
                (READ.32[4].argument2_1)
                (READ.32[5].argument2_0)
                (READ.32[5].argument2_1)
                (READ.32[6].argument2_0)
                (READ.32[6].argument2_1)
                (READ.32[7].argument2_0)
                (READ.32[7].argument2_1))))
          (SKIP))
        (IF
          (EQ
            (READ.shuffleX)
            (CONST.6))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_32_x8
                (READ.32[0].argument2_0)
                (READ.32[2].argument2_0)
                (READ.32[4].argument2_0)
                (READ.32[6].argument2_0)
                (READ.32[0].argument2_1)
                (READ.32[2].argument2_1)
                (READ.32[4].argument2_1)
                (READ.32[6].argument2_1)))
            (WRITE.result1_1
              (APPLY.256.join_32_x8
                (READ.32[1].argument2_0)
                (READ.32[3].argument2_0)
                (READ.32[5].argument2_0)
                (READ.32[7].argument2_0)
                (READ.32[1].argument2_1)
                (READ.32[3].argument2_1)
                (READ.32[5].argument2_1)
                (READ.32[7].argument2_1))))
          (SKIP)))
  - ID: XCOPYX
    what: Copy Word Hexadecuple
    class: EXT
    formats: [ EXT_XCOPYX ]
    properties: { '%0': Extension }
    description: >
      The eight double words that compose the %2 are copied or shuffled depending on the %3 and the result is stored back into the %1.
    execution: *executionXSPLATOX
    behavior: *behaviorXSPLATOX
  - ID: XSPLATOV
    what: Splat Word Octuple to Vector
    class: EXT
    formats: [ EXT_XSPLATOV ]
    properties: { '%0': Extension }
    description: >
      The %2 is duplicated to produce a vector of words (1024 bits). Depending on the %3, the
      $4 \times 4$ double words that compose these 1024 bits are transposed and the result is stored back into the %1.
    execution: &executionXSPLATOV |
      new result1_0 = argument2_0;
      new result1_1 = argument2_1;
      new result1_2 = argument2_2;
      new result1_3 = argument2_3;
      if (shuffleV) {
        result1_0 = join_64_x4(argument2_0.64[0], argument2_1.64[0], argument2_2.64[0], argument2_3.64[0]);
        result1_1 = join_64_x4(argument2_0.64[1], argument2_1.64[1], argument2_2.64[1], argument2_3.64[1]);
        result1_2 = join_64_x4(argument2_0.64[2], argument2_1.64[2], argument2_2.64[2], argument2_3.64[2]);
        result1_3 = join_64_x4(argument2_0.64[3], argument2_1.64[3], argument2_2.64[3], argument2_3.64[3]);
      }
    behavior: &behaviorXSPLATOV |
      (SEQ
        (WRITE.result1_0
          (READ.argument2_0))
        (WRITE.result1_1
          (READ.argument2_1))
        (WRITE.result1_2
          (READ.argument2_2))
        (WRITE.result1_3
          (READ.argument2_3))
        (IF
          (I2B (READ.shuffleV))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.join_64_x4
                (READ.64[0].argument2_0)
                (READ.64[0].argument2_1)
                (READ.64[0].argument2_2)
                (READ.64[0].argument2_3)))
            (WRITE.result1_1
              (APPLY.256.join_64_x4
                (READ.64[1].argument2_0)
                (READ.64[1].argument2_1)
                (READ.64[1].argument2_2)
                (READ.64[1].argument2_3)))
            (WRITE.result1_2
              (APPLY.256.join_64_x4
                (READ.64[2].argument2_0)
                (READ.64[2].argument2_1)
                (READ.64[2].argument2_2)
                (READ.64[2].argument2_3)))
            (WRITE.result1_3
              (APPLY.256.join_64_x4
                (READ.64[3].argument2_0)
                (READ.64[3].argument2_1)
                (READ.64[3].argument2_2)
                (READ.64[3].argument2_3))))
          (SKIP)))
  - ID: XCOPYV
    what: Copy Word Vector
    class: EXT
    formats: [ EXT_XCOPYV ]
    properties: { '%0': Extension }
    description: >
      The $4 \times 4$ double words that compose the %2 are copied or transposed depending on the %3
      and the result is stored back into the %1.
    execution: *executionXSPLATOV
    behavior: *behaviorXSPLATOV
  - ID: XSBMM8DQ
    what: Swapped Bit Matrix Multiplication 8$\times$8 Double Quadruple
    formats: [ EXT_XSBMM8 ]
    description: >
      The %3 and the %2 are interpreted as a vector of four 64-bit elements.
      Each %3 element interpreted as a 8$\times$8 bit matrix is multiplied by the corresponding %2 element
      interpreted as a 8$\times$8 bit matrix. The resulting 8$\times$8 bit matrices are packed and stored into the %1.
    execution: |
      new result1_0 = _BMM_8(_ZX_64(argument3.64[0]), _ZX_64(argument2.64[0]));
      new result1_1 = _BMM_8(_ZX_64(argument3.64[1]), _ZX_64(argument2.64[1]));
      new result1_2 = _BMM_8(_ZX_64(argument3.64[2]), _ZX_64(argument2.64[2]));
      new result1_3 = _BMM_8(_ZX_64(argument3.64[3]), _ZX_64(argument2.64[3]));
      new result1 = join_64_x4(result1_0, result1_1, result1_2, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.64._BMM_8
            (ZX.64 (READ.64[0].argument3))
            (ZX.64 (READ.64[0].argument2))))
        (WRITE.result1_1
          (APPLY.64._BMM_8
            (ZX.64 (READ.64[1].argument3))
            (ZX.64 (READ.64[1].argument2))))
        (WRITE.result1_2
          (APPLY.64._BMM_8
            (ZX.64 (READ.64[2].argument3))
            (ZX.64 (READ.64[2].argument2))))
        (WRITE.result1_3
          (APPLY.64._BMM_8
            (ZX.64 (READ.64[3].argument3))
            (ZX.64 (READ.64[3].argument2))))
        (WRITE.result1
          (APPLY.256.join_64_x4
            (READ.result1_0)
            (READ.result1_1)
            (READ.result1_2)
            (READ.result1_3))))
  - ID: XSBMMT8DQ
    what: Swapped Bit Matrix Multiplication 8$\times$8 Double Quadruple
    formats: [ EXT_XSBMM8 ]
    description: >
      The %3 and the %2 are interpreted as a vector of four 64-bit elements.
      Each %3 element interpreted as a 8$\times$8 bit matrix is multiplied by the corresponding %2 element
      interpreted as a 8$\times$8 bit matrix. The resulting 8$\times$8 bit matrices are transposed, packed and stored into the %1.
    execution: |
      new result1_0 = _BMT_8(_BMM_8(_ZX_64(argument3.64[0]), _ZX_64(argument2.64[0])));
      new result1_1 = _BMT_8(_BMM_8(_ZX_64(argument3.64[1]), _ZX_64(argument2.64[1])));
      new result1_2 = _BMT_8(_BMM_8(_ZX_64(argument3.64[2]), _ZX_64(argument2.64[2])));
      new result1_3 = _BMT_8(_BMM_8(_ZX_64(argument3.64[3]), _ZX_64(argument2.64[3])));
      new result1 = join_64_x4(result1_0, result1_1, result1_2, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.64._BMT_8
            (APPLY.64._BMM_8
              (ZX.64 (READ.64[0].argument3))
              (ZX.64 (READ.64[0].argument2)))))
        (WRITE.result1_1
          (APPLY.64._BMT_8
            (APPLY.64._BMM_8
              (ZX.64 (READ.64[1].argument3))
              (ZX.64 (READ.64[1].argument2)))))
        (WRITE.result1_2
          (APPLY.64._BMT_8
            (APPLY.64._BMM_8
              (ZX.64 (READ.64[2].argument3))
              (ZX.64 (READ.64[2].argument2)))))
        (WRITE.result1_3
          (APPLY.64._BMT_8
            (APPLY.64._BMM_8
              (ZX.64 (READ.64[3].argument3))
              (ZX.64 (READ.64[3].argument2)))))
        (WRITE.result1
          (APPLY.256.join_64_x4
            (READ.result1_0)
            (READ.result1_1)
            (READ.result1_2)
            (READ.result1_3))))
  - ID: XANDO
    what: Bitwise And Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (READ.argument3)))
  - ID: XNANDO
    what: Bitwise Not And Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 & argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (AND
            (READ.argument2)
            (READ.argument3))))
  - ID: XIORO
    what: Bitwise Or Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (READ.argument2)
          (READ.argument3)))
  - ID: XNIORO
    what: Bitwise Not Or Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 | argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (IOR
            (READ.argument2)
            (READ.argument3))))
  - ID: XEORO
    what: Bitwise Exclusive Or Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 ^ argument3;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (READ.argument3)))
  - ID: XNEORO
    what: Bitwise Not Exclusive Or Between Octuple Words
    formats: [ EXT_XBWO ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 ^ argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (XOR
            (READ.argument2)
            (READ.argument3))))
  - ID: XANDNO
    what: Bitwise And with Not Operand Between Octuple Words
    properties: { '%0': Bitwise }
    formats: [ EXT_XBWO ]
    description: >
      Bitwise and of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: XIORNO
    what: Bitwise Or with Not Operand Between Octuple Words
    properties: { '%0': Bitwise }
    formats: [ EXT_XBWO ]
    description: >
      Bitwise inclusive or of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: XMMA4164BW
    what: Matrix Multiply-Add 4x16x4 Bytes to Words
    class: EXT
    formats: [ EXT_MMABW0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words accumulates the product
      of the %2 interpreted as a 4x16 matrix of signed bytes by the transposed %3 interpreted as 4x16 matrix of signed bytes.
    execution: |
      new result1_0;
      result1_0.32[0] = dot16add_8_32(argument2_r_0, argument3_r_0, argument1_0_0);
      result1_0.32[1] = dot16add_8_32(argument2_r_0, argument3_r_1, argument1_0_1);
      result1_0.32[2] = dot16add_8_32(argument2_r_1, argument3_r_0, argument1_1_0);
      result1_0.32[3] = dot16add_8_32(argument2_r_1, argument3_r_1, argument1_1_1);
      result1_0.32[4] = dot16add_8_32(argument2_r_2, argument3_r_0, argument1_2_0);
      result1_0.32[5] = dot16add_8_32(argument2_r_2, argument3_r_1, argument1_2_1);
      result1_0.32[6] = dot16add_8_32(argument2_r_3, argument3_r_0, argument1_3_0);
      result1_0.32[7] = dot16add_8_32(argument2_r_3, argument3_r_1, argument1_3_1);
      new result1_1;
      result1_1.32[0] = dot16add_8_32(argument2_r_0, argument3_r_2, argument1_0_2);
      result1_1.32[1] = dot16add_8_32(argument2_r_0, argument3_r_3, argument1_0_3);
      result1_1.32[2] = dot16add_8_32(argument2_r_1, argument3_r_2, argument1_1_2);
      result1_1.32[3] = dot16add_8_32(argument2_r_1, argument3_r_3, argument1_1_3);
      result1_1.32[4] = dot16add_8_32(argument2_r_2, argument3_r_2, argument1_2_2);
      result1_1.32[5] = dot16add_8_32(argument2_r_2, argument3_r_3, argument1_2_3);
      result1_1.32[6] = dot16add_8_32(argument2_r_3, argument3_r_2, argument1_3_2);
      result1_1.32[7] = dot16add_8_32(argument2_r_3, argument3_r_3, argument1_3_3);
    behavior: |
      (SEQ
        (WRITE.32[0].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_0) (READ.argument3_r_0) (READ.argument1_0_0)))
        (WRITE.32[1].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_0) (READ.argument3_r_1) (READ.argument1_0_1)))
        (WRITE.32[2].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_1) (READ.argument3_r_0) (READ.argument1_1_0)))
        (WRITE.32[3].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_1) (READ.argument3_r_1) (READ.argument1_1_1)))
        (WRITE.32[4].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_2) (READ.argument3_r_0) (READ.argument1_2_0)))
        (WRITE.32[5].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_2) (READ.argument3_r_1) (READ.argument1_2_1)))
        (WRITE.32[6].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_3) (READ.argument3_r_0) (READ.argument1_3_0)))
        (WRITE.32[7].result1_0
          (APPLY.32.dot16add_8_32 (READ.argument2_r_3) (READ.argument3_r_1) (READ.argument1_3_1)))
        (WRITE.32[0].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_0) (READ.argument3_r_2) (READ.argument1_0_2)))
        (WRITE.32[1].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_0) (READ.argument3_r_3) (READ.argument1_0_3)))
        (WRITE.32[2].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_1) (READ.argument3_r_2) (READ.argument1_1_2)))
        (WRITE.32[3].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_1) (READ.argument3_r_3) (READ.argument1_1_3)))
        (WRITE.32[4].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_2) (READ.argument3_r_2) (READ.argument1_2_2)))
        (WRITE.32[5].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_2) (READ.argument3_r_3) (READ.argument1_2_3)))
        (WRITE.32[6].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_3) (READ.argument3_r_2) (READ.argument1_3_2)))
        (WRITE.32[7].result1_1
          (APPLY.32.dot16add_8_32 (READ.argument2_r_3) (READ.argument3_r_3) (READ.argument1_3_3))))
  - ID: XMMAU4164BW
    what: Matrix Multiply-Add 4x16x4 Unsigned by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMABW1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words accumulates the product
      of the %2 interpreted as a 4x16 matrix of unsigned bytes by the transposed %3 interpreted as a 4x16 matrix of unsigned bytes.
    execution: |
      new result1_0;
      result1_0.32[0] = dot16addu_8_32(argument2_r_0, argument3_r_0, argument1_0_0);
      result1_0.32[1] = dot16addu_8_32(argument2_r_0, argument3_r_1, argument1_0_1);
      result1_0.32[2] = dot16addu_8_32(argument2_r_1, argument3_r_0, argument1_1_0);
      result1_0.32[3] = dot16addu_8_32(argument2_r_1, argument3_r_1, argument1_1_1);
      result1_0.32[4] = dot16addu_8_32(argument2_r_2, argument3_r_0, argument1_2_0);
      result1_0.32[5] = dot16addu_8_32(argument2_r_2, argument3_r_1, argument1_2_1);
      result1_0.32[6] = dot16addu_8_32(argument2_r_3, argument3_r_0, argument1_3_0);
      result1_0.32[7] = dot16addu_8_32(argument2_r_3, argument3_r_1, argument1_3_1);
      new result1_1;
      result1_1.32[0] = dot16addu_8_32(argument2_r_0, argument3_r_2, argument1_0_2);
      result1_1.32[1] = dot16addu_8_32(argument2_r_0, argument3_r_3, argument1_0_3);
      result1_1.32[2] = dot16addu_8_32(argument2_r_1, argument3_r_2, argument1_1_2);
      result1_1.32[3] = dot16addu_8_32(argument2_r_1, argument3_r_3, argument1_1_3);
      result1_1.32[4] = dot16addu_8_32(argument2_r_2, argument3_r_2, argument1_2_2);
      result1_1.32[5] = dot16addu_8_32(argument2_r_2, argument3_r_3, argument1_2_3);
      result1_1.32[6] = dot16addu_8_32(argument2_r_3, argument3_r_2, argument1_3_2);
      result1_1.32[7] = dot16addu_8_32(argument2_r_3, argument3_r_3, argument1_3_3);
    behavior: |
      (SEQ
        (WRITE.32[0].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_0) (READ.argument3_r_0) (READ.argument1_0_0)))
        (WRITE.32[1].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_0) (READ.argument3_r_1) (READ.argument1_0_1)))
        (WRITE.32[2].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_1) (READ.argument3_r_0) (READ.argument1_1_0)))
        (WRITE.32[3].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_1) (READ.argument3_r_1) (READ.argument1_1_1)))
        (WRITE.32[4].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_2) (READ.argument3_r_0) (READ.argument1_2_0)))
        (WRITE.32[5].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_2) (READ.argument3_r_1) (READ.argument1_2_1)))
        (WRITE.32[6].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_3) (READ.argument3_r_0) (READ.argument1_3_0)))
        (WRITE.32[7].result1_0
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_3) (READ.argument3_r_1) (READ.argument1_3_1)))
        (WRITE.32[0].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_0) (READ.argument3_r_2) (READ.argument1_0_2)))
        (WRITE.32[1].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_0) (READ.argument3_r_3) (READ.argument1_0_3)))
        (WRITE.32[2].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_1) (READ.argument3_r_2) (READ.argument1_1_2)))
        (WRITE.32[3].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_1) (READ.argument3_r_3) (READ.argument1_1_3)))
        (WRITE.32[4].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_2) (READ.argument3_r_2) (READ.argument1_2_2)))
        (WRITE.32[5].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_2) (READ.argument3_r_3) (READ.argument1_2_3)))
        (WRITE.32[6].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_3) (READ.argument3_r_2) (READ.argument1_3_2)))
        (WRITE.32[7].result1_1
          (APPLY.32.dot16addu_8_32 (READ.argument2_r_3) (READ.argument3_r_3) (READ.argument1_3_3))))
  - ID: XMMASU4164BW
    what: Matrix Multiply-Add 4x16x4 Signed by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMABW2 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words accumulates the product
      of the %2 interpreted as a 4x16 matrix of signed bytes by the transposed %3 interpreted as a 4x16 matrix of unsigned bytes.
    execution: |
      new result1_0;
      result1_0.32[0] = dot16addsu_8_32(argument2_r_0, argument3_r_0, argument1_0_0);
      result1_0.32[1] = dot16addsu_8_32(argument2_r_0, argument3_r_1, argument1_0_1);
      result1_0.32[2] = dot16addsu_8_32(argument2_r_1, argument3_r_0, argument1_1_0);
      result1_0.32[3] = dot16addsu_8_32(argument2_r_1, argument3_r_1, argument1_1_1);
      result1_0.32[4] = dot16addsu_8_32(argument2_r_2, argument3_r_0, argument1_2_0);
      result1_0.32[5] = dot16addsu_8_32(argument2_r_2, argument3_r_1, argument1_2_1);
      result1_0.32[6] = dot16addsu_8_32(argument2_r_3, argument3_r_0, argument1_3_0);
      result1_0.32[7] = dot16addsu_8_32(argument2_r_3, argument3_r_1, argument1_3_1);
      new result1_1;
      result1_1.32[0] = dot16addsu_8_32(argument2_r_0, argument3_r_2, argument1_0_2);
      result1_1.32[1] = dot16addsu_8_32(argument2_r_0, argument3_r_3, argument1_0_3);
      result1_1.32[2] = dot16addsu_8_32(argument2_r_1, argument3_r_2, argument1_1_2);
      result1_1.32[3] = dot16addsu_8_32(argument2_r_1, argument3_r_3, argument1_1_3);
      result1_1.32[4] = dot16addsu_8_32(argument2_r_2, argument3_r_2, argument1_2_2);
      result1_1.32[5] = dot16addsu_8_32(argument2_r_2, argument3_r_3, argument1_2_3);
      result1_1.32[6] = dot16addsu_8_32(argument2_r_3, argument3_r_2, argument1_3_2);
      result1_1.32[7] = dot16addsu_8_32(argument2_r_3, argument3_r_3, argument1_3_3);
    behavior: |
      (SEQ
        (WRITE.32[0].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_0) (READ.argument3_r_0) (READ.argument1_0_0)))
        (WRITE.32[1].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_0) (READ.argument3_r_1) (READ.argument1_0_1)))
        (WRITE.32[2].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_1) (READ.argument3_r_0) (READ.argument1_1_0)))
        (WRITE.32[3].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_1) (READ.argument3_r_1) (READ.argument1_1_1)))
        (WRITE.32[4].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_2) (READ.argument3_r_0) (READ.argument1_2_0)))
        (WRITE.32[5].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_2) (READ.argument3_r_1) (READ.argument1_2_1)))
        (WRITE.32[6].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_3) (READ.argument3_r_0) (READ.argument1_3_0)))
        (WRITE.32[7].result1_0
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_3) (READ.argument3_r_1) (READ.argument1_3_1)))
        (WRITE.32[0].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_0) (READ.argument3_r_2) (READ.argument1_0_2)))
        (WRITE.32[1].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_0) (READ.argument3_r_3) (READ.argument1_0_3)))
        (WRITE.32[2].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_1) (READ.argument3_r_2) (READ.argument1_1_2)))
        (WRITE.32[3].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_1) (READ.argument3_r_3) (READ.argument1_1_3)))
        (WRITE.32[4].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_2) (READ.argument3_r_2) (READ.argument1_2_2)))
        (WRITE.32[5].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_2) (READ.argument3_r_3) (READ.argument1_2_3)))
        (WRITE.32[6].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_3) (READ.argument3_r_2) (READ.argument1_3_2)))
        (WRITE.32[7].result1_1
          (APPLY.32.dot16addsu_8_32 (READ.argument2_r_3) (READ.argument3_r_3) (READ.argument1_3_3))))
  - ID: XMMAUS4164BW
    what: Matrix Multiply-Add 4x16x4 Unsigned by Signed Bytes to Words
    class: EXT
    formats: [ EXT_MMABW3 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words accumulates the product
      of the %2 interpreted as a 4x16 matrix of unsigned bytes by the transposed %3 interpreted as a 4x16 matrix of signed bytes.
    execution: |
      new result1_0;
      result1_0.32[0] = dot16addus_8_32(argument2_r_0, argument3_r_0, argument1_0_0);
      result1_0.32[1] = dot16addus_8_32(argument2_r_0, argument3_r_1, argument1_0_1);
      result1_0.32[2] = dot16addus_8_32(argument2_r_1, argument3_r_0, argument1_1_0);
      result1_0.32[3] = dot16addus_8_32(argument2_r_1, argument3_r_1, argument1_1_1);
      result1_0.32[4] = dot16addus_8_32(argument2_r_2, argument3_r_0, argument1_2_0);
      result1_0.32[5] = dot16addus_8_32(argument2_r_2, argument3_r_1, argument1_2_1);
      result1_0.32[6] = dot16addus_8_32(argument2_r_3, argument3_r_0, argument1_3_0);
      result1_0.32[7] = dot16addus_8_32(argument2_r_3, argument3_r_1, argument1_3_1);
      new result1_1;
      result1_1.32[0] = dot16addus_8_32(argument2_r_0, argument3_r_2, argument1_0_2);
      result1_1.32[1] = dot16addus_8_32(argument2_r_0, argument3_r_3, argument1_0_3);
      result1_1.32[2] = dot16addus_8_32(argument2_r_1, argument3_r_2, argument1_1_2);
      result1_1.32[3] = dot16addus_8_32(argument2_r_1, argument3_r_3, argument1_1_3);
      result1_1.32[4] = dot16addus_8_32(argument2_r_2, argument3_r_2, argument1_2_2);
      result1_1.32[5] = dot16addus_8_32(argument2_r_2, argument3_r_3, argument1_2_3);
      result1_1.32[6] = dot16addus_8_32(argument2_r_3, argument3_r_2, argument1_3_2);
      result1_1.32[7] = dot16addus_8_32(argument2_r_3, argument3_r_3, argument1_3_3);
    behavior: |
      (SEQ
        (WRITE.32[0].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_0) (READ.argument3_r_0) (READ.argument1_0_0)))
        (WRITE.32[1].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_0) (READ.argument3_r_1) (READ.argument1_0_1)))
        (WRITE.32[2].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_1) (READ.argument3_r_0) (READ.argument1_1_0)))
        (WRITE.32[3].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_1) (READ.argument3_r_1) (READ.argument1_1_1)))
        (WRITE.32[4].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_2) (READ.argument3_r_0) (READ.argument1_2_0)))
        (WRITE.32[5].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_2) (READ.argument3_r_1) (READ.argument1_2_1)))
        (WRITE.32[6].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_3) (READ.argument3_r_0) (READ.argument1_3_0)))
        (WRITE.32[7].result1_0
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_3) (READ.argument3_r_1) (READ.argument1_3_1)))
        (WRITE.32[0].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_0) (READ.argument3_r_2) (READ.argument1_0_2)))
        (WRITE.32[1].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_0) (READ.argument3_r_3) (READ.argument1_0_3)))
        (WRITE.32[2].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_1) (READ.argument3_r_2) (READ.argument1_1_2)))
        (WRITE.32[3].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_1) (READ.argument3_r_3) (READ.argument1_1_3)))
        (WRITE.32[4].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_2) (READ.argument3_r_2) (READ.argument1_2_2)))
        (WRITE.32[5].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_2) (READ.argument3_r_3) (READ.argument1_2_3)))
        (WRITE.32[6].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_3) (READ.argument3_r_2) (READ.argument1_3_2)))
        (WRITE.32[7].result1_1
          (APPLY.32.dot16addus_8_32 (READ.argument2_r_3) (READ.argument3_r_3) (READ.argument1_3_3))))
  - ID: XMMA484BW
    what: Extension Matrix Multiply-Add 4x8x4 Bytes to Words
    class: EXT
    formats: [ EXT_MMABW ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %1 interpreted as a 4x4 matrix of words to the product
      of the %2 interpreted as a 4x8 matrix of signed bytes by the transposed %3 interpreted as a 4x8 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot8_8_32(argument2_0, argument3_0);
      new result1_0_1 = dot8_8_32(argument2_0, argument3_1);
      new result1_0_2 = dot8_8_32(argument2_0, argument3_2);
      new result1_0_3 = dot8_8_32(argument2_0, argument3_3);
      new result1_1_0 = dot8_8_32(argument2_1, argument3_0);
      new result1_1_1 = dot8_8_32(argument2_1, argument3_1);
      new result1_1_2 = dot8_8_32(argument2_1, argument3_2);
      new result1_1_3 = dot8_8_32(argument2_1, argument3_3);
      new result1_2_0 = dot8_8_32(argument2_2, argument3_0);
      new result1_2_1 = dot8_8_32(argument2_2, argument3_1);
      new result1_2_2 = dot8_8_32(argument2_2, argument3_2);
      new result1_2_3 = dot8_8_32(argument2_2, argument3_3);
      new result1_3_0 = dot8_8_32(argument2_3, argument3_0);
      new result1_3_1 = dot8_8_32(argument2_3, argument3_1);
      new result1_3_2 = dot8_8_32(argument2_3, argument3_2);
      new result1_3_3 = dot8_8_32(argument2_3, argument3_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument1_0, result1_0);
      result1_1 = add_32_32_x8(argument1_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8_8_32
            (READ.argument2_0)
            (READ.argument3_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8_8_32
            (READ.argument2_0)
            (READ.argument3_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8_8_32
            (READ.argument2_0)
            (READ.argument3_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8_8_32
            (READ.argument2_0)
            (READ.argument3_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8_8_32
            (READ.argument2_1)
            (READ.argument3_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8_8_32
            (READ.argument2_1)
            (READ.argument3_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8_8_32
            (READ.argument2_1)
            (READ.argument3_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8_8_32
            (READ.argument2_1)
            (READ.argument3_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8_8_32
            (READ.argument2_2)
            (READ.argument3_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8_8_32
            (READ.argument2_2)
            (READ.argument3_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8_8_32
            (READ.argument2_2)
            (READ.argument3_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8_8_32
            (READ.argument2_2)
            (READ.argument3_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8_8_32
            (READ.argument2_3)
            (READ.argument3_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8_8_32
            (READ.argument2_3)
            (READ.argument3_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8_8_32
            (READ.argument2_3)
            (READ.argument3_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8_8_32
            (READ.argument2_3)
            (READ.argument3_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument1_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument1_1)
            (READ.result1_1))))
  - ID: XMMAU484BW
    what: Matrix Multiply-Add 4x8x4 Unsigned by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMAUBW ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %1 interpreted as a 4x4 matrix of words to the product
      of the %2 interpreted as a 4x8 matrix of unsigned bytes by the transposed %3 interpreted as a 4x8 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot8u_8_32(argument2_0, argument3_0);
      new result1_0_1 = dot8u_8_32(argument2_0, argument3_1);
      new result1_0_2 = dot8u_8_32(argument2_0, argument3_2);
      new result1_0_3 = dot8u_8_32(argument2_0, argument3_3);
      new result1_1_0 = dot8u_8_32(argument2_1, argument3_0);
      new result1_1_1 = dot8u_8_32(argument2_1, argument3_1);
      new result1_1_2 = dot8u_8_32(argument2_1, argument3_2);
      new result1_1_3 = dot8u_8_32(argument2_1, argument3_3);
      new result1_2_0 = dot8u_8_32(argument2_2, argument3_0);
      new result1_2_1 = dot8u_8_32(argument2_2, argument3_1);
      new result1_2_2 = dot8u_8_32(argument2_2, argument3_2);
      new result1_2_3 = dot8u_8_32(argument2_2, argument3_3);
      new result1_3_0 = dot8u_8_32(argument2_3, argument3_0);
      new result1_3_1 = dot8u_8_32(argument2_3, argument3_1);
      new result1_3_2 = dot8u_8_32(argument2_3, argument3_2);
      new result1_3_3 = dot8u_8_32(argument2_3, argument3_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument1_0, result1_0);
      result1_1 = add_32_32_x8(argument1_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8u_8_32
            (READ.argument2_0)
            (READ.argument3_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8u_8_32
            (READ.argument2_0)
            (READ.argument3_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8u_8_32
            (READ.argument2_0)
            (READ.argument3_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8u_8_32
            (READ.argument2_0)
            (READ.argument3_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8u_8_32
            (READ.argument2_1)
            (READ.argument3_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8u_8_32
            (READ.argument2_1)
            (READ.argument3_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8u_8_32
            (READ.argument2_1)
            (READ.argument3_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8u_8_32
            (READ.argument2_1)
            (READ.argument3_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8u_8_32
            (READ.argument2_2)
            (READ.argument3_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8u_8_32
            (READ.argument2_2)
            (READ.argument3_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8u_8_32
            (READ.argument2_2)
            (READ.argument3_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8u_8_32
            (READ.argument2_2)
            (READ.argument3_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8u_8_32
            (READ.argument2_3)
            (READ.argument3_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8u_8_32
            (READ.argument2_3)
            (READ.argument3_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8u_8_32
            (READ.argument2_3)
            (READ.argument3_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8u_8_32
            (READ.argument2_3)
            (READ.argument3_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument1_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument1_1)
            (READ.result1_1))))
  - ID: XMMASU484BW
    what: Matrix Multiply-Add 4x8x4 Signed by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMASUBW ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %1 interpreted as a 4x4 matrix of words to the product
      of the %2 interpreted as a 4x8 matrix of signed bytes by the transposed %3 interpreted as a 4x8 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot8su_8_32(argument2_0, argument3_0);
      new result1_0_1 = dot8su_8_32(argument2_0, argument3_1);
      new result1_0_2 = dot8su_8_32(argument2_0, argument3_2);
      new result1_0_3 = dot8su_8_32(argument2_0, argument3_3);
      new result1_1_0 = dot8su_8_32(argument2_1, argument3_0);
      new result1_1_1 = dot8su_8_32(argument2_1, argument3_1);
      new result1_1_2 = dot8su_8_32(argument2_1, argument3_2);
      new result1_1_3 = dot8su_8_32(argument2_1, argument3_3);
      new result1_2_0 = dot8su_8_32(argument2_2, argument3_0);
      new result1_2_1 = dot8su_8_32(argument2_2, argument3_1);
      new result1_2_2 = dot8su_8_32(argument2_2, argument3_2);
      new result1_2_3 = dot8su_8_32(argument2_2, argument3_3);
      new result1_3_0 = dot8su_8_32(argument2_3, argument3_0);
      new result1_3_1 = dot8su_8_32(argument2_3, argument3_1);
      new result1_3_2 = dot8su_8_32(argument2_3, argument3_2);
      new result1_3_3 = dot8su_8_32(argument2_3, argument3_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument1_0, result1_0);
      result1_1 = add_32_32_x8(argument1_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8su_8_32
            (READ.argument2_0)
            (READ.argument3_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8su_8_32
            (READ.argument2_0)
            (READ.argument3_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8su_8_32
            (READ.argument2_0)
            (READ.argument3_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8su_8_32
            (READ.argument2_0)
            (READ.argument3_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8su_8_32
            (READ.argument2_1)
            (READ.argument3_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8su_8_32
            (READ.argument2_1)
            (READ.argument3_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8su_8_32
            (READ.argument2_1)
            (READ.argument3_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8su_8_32
            (READ.argument2_1)
            (READ.argument3_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8su_8_32
            (READ.argument2_2)
            (READ.argument3_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8su_8_32
            (READ.argument2_2)
            (READ.argument3_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8su_8_32
            (READ.argument2_2)
            (READ.argument3_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8su_8_32
            (READ.argument2_2)
            (READ.argument3_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8su_8_32
            (READ.argument2_3)
            (READ.argument3_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8su_8_32
            (READ.argument2_3)
            (READ.argument3_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8su_8_32
            (READ.argument2_3)
            (READ.argument3_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8su_8_32
            (READ.argument2_3)
            (READ.argument3_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument1_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument1_1)
            (READ.result1_1))))
  - ID: XMMAUS484BW
    what: Matrix Multiply-Add 4x8x4 Unsigned by Signed Bytes to Words
    class: EXT
    formats: [ EXT_MMAUSBW ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %1 interpreted as a 4x4 matrix of words to the product
      of the %2 interpreted as a 4x8 matrix of unsigned bytes by the transposed %3 interpreted as a 4x8 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot8us_8_32(argument2_0, argument3_0);
      new result1_0_1 = dot8us_8_32(argument2_0, argument3_1);
      new result1_0_2 = dot8us_8_32(argument2_0, argument3_2);
      new result1_0_3 = dot8us_8_32(argument2_0, argument3_3);
      new result1_1_0 = dot8us_8_32(argument2_1, argument3_0);
      new result1_1_1 = dot8us_8_32(argument2_1, argument3_1);
      new result1_1_2 = dot8us_8_32(argument2_1, argument3_2);
      new result1_1_3 = dot8us_8_32(argument2_1, argument3_3);
      new result1_2_0 = dot8us_8_32(argument2_2, argument3_0);
      new result1_2_1 = dot8us_8_32(argument2_2, argument3_1);
      new result1_2_2 = dot8us_8_32(argument2_2, argument3_2);
      new result1_2_3 = dot8us_8_32(argument2_2, argument3_3);
      new result1_3_0 = dot8us_8_32(argument2_3, argument3_0);
      new result1_3_1 = dot8us_8_32(argument2_3, argument3_1);
      new result1_3_2 = dot8us_8_32(argument2_3, argument3_2);
      new result1_3_3 = dot8us_8_32(argument2_3, argument3_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument1_0, result1_0);
      result1_1 = add_32_32_x8(argument1_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8us_8_32
            (READ.argument2_0)
            (READ.argument3_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8us_8_32
            (READ.argument2_0)
            (READ.argument3_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8us_8_32
            (READ.argument2_0)
            (READ.argument3_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8us_8_32
            (READ.argument2_0)
            (READ.argument3_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8us_8_32
            (READ.argument2_1)
            (READ.argument3_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8us_8_32
            (READ.argument2_1)
            (READ.argument3_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8us_8_32
            (READ.argument2_1)
            (READ.argument3_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8us_8_32
            (READ.argument2_1)
            (READ.argument3_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8us_8_32
            (READ.argument2_2)
            (READ.argument3_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8us_8_32
            (READ.argument2_2)
            (READ.argument3_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8us_8_32
            (READ.argument2_2)
            (READ.argument3_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8us_8_32
            (READ.argument2_2)
            (READ.argument3_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8us_8_32
            (READ.argument2_3)
            (READ.argument3_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8us_8_32
            (READ.argument2_3)
            (READ.argument3_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8us_8_32
            (READ.argument2_3)
            (READ.argument3_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8us_8_32
            (READ.argument2_3)
            (READ.argument3_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument1_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument1_1)
            (READ.result1_1))))
  - ID: XFMMA484HW
    what: Floating-Point Matrix Multiply-Add 4x8x4 Half Words to Words
    class: EXT
    formats: [ EXT_FMMAHW ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words accumulates the product
      of the %2 interpreted as a 4x8 matrix of half words by the transposed %3 interpreted as a 4x8 matrix of half words.
    execution: |
      new result1_0;
      result1_0.32[0] = fdot8add_16_32_reset(XRM, argument2_r_0, argument3_r_0, argument1_0_0_0);
      result1_0.32[1] = fdot8add_16_32_noreset(XRM, argument2_r_0, argument3_r_1, argument1_0_0_1);
      result1_0.32[2] = fdot8add_16_32_noreset(XRM, argument2_r_1, argument3_r_0, argument1_0_1_0);
      result1_0.32[3] = fdot8add_16_32_noreset(XRM, argument2_r_1, argument3_r_1, argument1_0_1_1);
      result1_0.32[4] = fdot8add_16_32_noreset(XRM, argument2_r_2, argument3_r_0, argument1_0_2_0);
      result1_0.32[5] = fdot8add_16_32_noreset(XRM, argument2_r_2, argument3_r_1, argument1_0_2_1);
      result1_0.32[6] = fdot8add_16_32_noreset(XRM, argument2_r_3, argument3_r_0, argument1_0_3_0);
      result1_0.32[7] = fdot8add_16_32_noreset(XRM, argument2_r_3, argument3_r_1, argument1_0_3_1);
      new result1_1;
      result1_1.32[0] = fdot8add_16_32_noreset(XRM, argument2_r_0, argument3_r_2, argument1_1_0_0);
      result1_1.32[1] = fdot8add_16_32_noreset(XRM, argument2_r_0, argument3_r_3, argument1_1_0_1);
      result1_1.32[2] = fdot8add_16_32_noreset(XRM, argument2_r_1, argument3_r_2, argument1_1_1_0);
      result1_1.32[3] = fdot8add_16_32_noreset(XRM, argument2_r_1, argument3_r_3, argument1_1_1_1);
      result1_1.32[4] = fdot8add_16_32_noreset(XRM, argument2_r_2, argument3_r_2, argument1_1_2_0);
      result1_1.32[5] = fdot8add_16_32_noreset(XRM, argument2_r_2, argument3_r_3, argument1_1_2_1);
      result1_1.32[6] = fdot8add_16_32_noreset(XRM, argument2_r_3, argument3_r_2, argument1_1_3_0);
      result1_1.32[7] = fdot8add_16_32_noreset(XRM, argument2_r_3, argument3_r_3, argument1_1_3_1);
    behavior: |
      (SEQ
        (WRITE.32[0].result1_0
          (APPLY.32.fdot8add_16_32_reset (READ.XRM) (READ.argument2_r_0) (READ.argument3_r_0) (READ.argument1_0_0_0)))
        (WRITE.32[1].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_0) (READ.argument3_r_1) (READ.argument1_0_0_1)))
        (WRITE.32[2].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_1) (READ.argument3_r_0) (READ.argument1_0_1_0)))
        (WRITE.32[3].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_1) (READ.argument3_r_1) (READ.argument1_0_1_1)))
        (WRITE.32[4].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_2) (READ.argument3_r_0) (READ.argument1_0_2_0)))
        (WRITE.32[5].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_2) (READ.argument3_r_1) (READ.argument1_0_2_1)))
        (WRITE.32[6].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_3) (READ.argument3_r_0) (READ.argument1_0_3_0)))
        (WRITE.32[7].result1_0
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_3) (READ.argument3_r_1) (READ.argument1_0_3_1)))
        (WRITE.32[0].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_0) (READ.argument3_r_2) (READ.argument1_1_0_0)))
        (WRITE.32[1].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_0) (READ.argument3_r_3) (READ.argument1_1_0_1)))
        (WRITE.32[2].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_1) (READ.argument3_r_2) (READ.argument1_1_1_0)))
        (WRITE.32[3].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_1) (READ.argument3_r_3) (READ.argument1_1_1_1)))
        (WRITE.32[4].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_2) (READ.argument3_r_2) (READ.argument1_1_2_0)))
        (WRITE.32[5].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_2) (READ.argument3_r_3) (READ.argument1_1_2_1)))
        (WRITE.32[6].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_3) (READ.argument3_r_2) (READ.argument1_1_3_0)))
        (WRITE.32[7].result1_1
          (APPLY.32.fdot8add_16_32_noreset (READ.XRM) (READ.argument2_r_3) (READ.argument3_r_3) (READ.argument1_1_3_1))))
  - ID: XMADDIFWO
    what: Multiply Add Integer Floating Point Word Octuple
    class: EXT
    formats: [ EXT_MADDIFWO ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a vector of 8 32-bit integers, and the %3 as a vector of 8 binary 32
      floating-point numbers. The element-wise product of these vectors is computed and added to the %1
      interpreted as a vector of 8 32-bit integers. Those operations are computed with unlimited precision.
      The results are saturated to fit into 32-bit signed integers, and stored to the elements of the %1.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = maddif_32_32_x8(XRM, argument1, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.maddif_32_32_x8
          (READ.XRM)
          (READ.argument1)
          (READ.argument2)
          (READ.argument3)))
  - ID: XMSBFIFWO
    what: Multiply Subtract Integer Floating Point Word Octuple
    class: EXT
    formats: [ EXT_MADDIFWO ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a vector of 8 32-bit integers, and the %3 as a vector of 8 binary 32
      floating-point numbers. The element-wise product of these vectors is computed and subtracted from the %1
      interpreted as a vector of 8 32-bit integers. Those operations are computed with unlimited precision.
      The results are saturated to fit into 32-bit signed integers, and stored to the elements of the %1.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = msbfif_32_32_x8(XRM, argument1, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.msbfif_32_32_x8
          (READ.XRM)
          (READ.argument1)
          (READ.argument2)
          (READ.argument3)))
  - ID: XMADD44BW0
    what: Multiply Add 4x4 Matrix Byte to Word 0
    class: EXT
    formats: [ EXT_MADD44BW0 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the first four columns of the %2 is sign-extended and multiplied by the corresponding
      sign-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: &executionMADD44BW |
      new row_0 = mul_8_32_x4(argument2_0, argument3_0);
      new row_1 = mul_8_32_x4(argument2_1, argument3_1);
      new row_2 = mul_8_32_x4(argument2_2, argument3_2);
      new row_3 = mul_8_32_x4(argument2_3, argument3_3);
      new column_0 = transpose_64_4x4_0(row_0, row_1, row_2, row_3);
      new column_1 = transpose_64_4x4_1(row_0, row_1, row_2, row_3);
      new column_2 = transpose_64_4x4_2(row_0, row_1, row_2, row_3);
      new column_3 = transpose_64_4x4_3(row_0, row_1, row_2, row_3);
      new result1_0 = add_32_32_x8(argument1_0, column_0);
      new result1_1 = add_32_32_x8(argument1_1, column_1);
    behavior: &behaviorMADD44BW |
      (SEQ
        (WRITE.row_0 (APPLY.128.mul_8_32_x4 (READ.argument2_0) (READ.argument3_0)))
        (WRITE.row_1 (APPLY.128.mul_8_32_x4 (READ.argument2_1) (READ.argument3_1)))
        (WRITE.row_2 (APPLY.128.mul_8_32_x4 (READ.argument2_2) (READ.argument3_2)))
        (WRITE.row_3 (APPLY.128.mul_8_32_x4 (READ.argument2_3) (READ.argument3_3)))
        (WRITE.column_0
          (APPLY.256.transpose_64_4x4_0
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_1
          (APPLY.256.transpose_64_4x4_1
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_2
          (APPLY.256.transpose_64_4x4_2
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_3
          (APPLY.256.transpose_64_4x4_3
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_0 (APPLY.add_32_32_x8 (READ.argument1_0) (READ.column_0)))
        (WRITE.result1_1 (APPLY.add_32_32_x8 (READ.argument1_1) (READ.column_1))))
  - ID: XMADDU44BW0
    what: Multiply-Add Unsigned 4x4 Matrix Byte to Word 0
    class: EXT
    formats: [ EXT_MADD44BW0 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the first four columns of the %2 is zero-extended and multiplied by the corresponding
      zero-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: &executionMADDU44BW |
      new row_0 = mulu_8_32_x4(argument2_0, argument3_0);
      new row_1 = mulu_8_32_x4(argument2_1, argument3_1);
      new row_2 = mulu_8_32_x4(argument2_2, argument3_2);
      new row_3 = mulu_8_32_x4(argument2_3, argument3_3);
      new column_0 = transpose_64_4x4_0(row_0, row_1, row_2, row_3);
      new column_1 = transpose_64_4x4_1(row_0, row_1, row_2, row_3);
      new column_2 = transpose_64_4x4_2(row_0, row_1, row_2, row_3);
      new column_3 = transpose_64_4x4_3(row_0, row_1, row_2, row_3);
      new result1_0 = add_32_32_x8(argument1_0, column_0);
      new result1_1 = add_32_32_x8(argument1_1, column_1);
    behavior: &behaviorMADDU44BW |
      (SEQ
        (WRITE.row_0 (APPLY.128.mulu_8_32_x4 (READ.argument2_0) (READ.argument3_0)))
        (WRITE.row_1 (APPLY.128.mulu_8_32_x4 (READ.argument2_1) (READ.argument3_1)))
        (WRITE.row_2 (APPLY.128.mulu_8_32_x4 (READ.argument2_2) (READ.argument3_2)))
        (WRITE.row_3 (APPLY.128.mulu_8_32_x4 (READ.argument2_3) (READ.argument3_3)))
        (WRITE.column_0
          (APPLY.256.transpose_64_4x4_0
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_1
          (APPLY.256.transpose_64_4x4_1
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_2
          (APPLY.256.transpose_64_4x4_2
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_3
          (APPLY.256.transpose_64_4x4_3
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_0 (APPLY.add_32_32_x8 (READ.argument1_0) (READ.column_0)))
        (WRITE.result1_1 (APPLY.add_32_32_x8 (READ.argument1_1) (READ.column_1))))
  - ID: XMADDSU44BW0
    what: Multiply-Add Signed by Unsigned 4x4 Matrix Byte to Word 0
    class: EXT
    formats: [ EXT_MADD44BW0 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the first four columns of the %2 is sign-extended and multiplied by the corresponding
      zero-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: &executionMADDSU44BW |
      new row_0 = mulsu_8_32_x4(argument2_0, argument3_0);
      new row_1 = mulsu_8_32_x4(argument2_1, argument3_1);
      new row_2 = mulsu_8_32_x4(argument2_2, argument3_2);
      new row_3 = mulsu_8_32_x4(argument2_3, argument3_3);
      new column_0 = transpose_64_4x4_0(row_0, row_1, row_2, row_3);
      new column_1 = transpose_64_4x4_1(row_0, row_1, row_2, row_3);
      new column_2 = transpose_64_4x4_2(row_0, row_1, row_2, row_3);
      new column_3 = transpose_64_4x4_3(row_0, row_1, row_2, row_3);
      new result1_0 = add_32_32_x8(argument1_0, column_0);
      new result1_1 = add_32_32_x8(argument1_1, column_1);
    behavior: &behaviorMADDSU44BW |
      (SEQ
        (WRITE.row_0 (APPLY.128.mulsu_8_32_x4 (READ.argument2_0) (READ.argument3_0)))
        (WRITE.row_1 (APPLY.128.mulsu_8_32_x4 (READ.argument2_1) (READ.argument3_1)))
        (WRITE.row_2 (APPLY.128.mulsu_8_32_x4 (READ.argument2_2) (READ.argument3_2)))
        (WRITE.row_3 (APPLY.128.mulsu_8_32_x4 (READ.argument2_3) (READ.argument3_3)))
        (WRITE.column_0
          (APPLY.256.transpose_64_4x4_0
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_1
          (APPLY.256.transpose_64_4x4_1
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_2
          (APPLY.256.transpose_64_4x4_2
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.column_3
          (APPLY.256.transpose_64_4x4_3
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_0 (APPLY.add_32_32_x8 (READ.argument1_0) (READ.column_0)))
        (WRITE.result1_1 (APPLY.add_32_32_x8 (READ.argument1_1) (READ.column_1))))
  - ID: XMADD44BW1
    what: Multiply Add 4x4 Matrix Byte to Word 1
    class: EXT
    formats: [ EXT_MADD44BW1 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the last four columns of the %2 is sign-extended and multiplied by the corresponding
      sign-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: *executionMADD44BW
    behavior: *behaviorMADD44BW
  - ID: XMADDU44BW1
    what: Multiply-Add Unsigned 4x4 Matrix Byte to Word 1
    class: EXT
    formats: [ EXT_MADD44BW1 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the last four columns of the %2 is zero-extended and multiplied by the corresponding
      zero-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: *executionMADDU44BW
    behavior: *behaviorMADDU44BW
  - ID: XMADDSU44BW1
    what: Multiply-Add Signed by Unsigned 4x4 Matrix Byte to Word 1
    class: EXT
    formats: [ EXT_MADD44BW1 ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x8 matrices of bytes, and the %1 is interpreted as a 4x4 matrix of words.
      Each element of the last four columns of the %2 is sign-extended and multiplied by the corresponding
      zero-extended element of the %3 and the product is added to the corresponding elements of the %1.
      The resulting 4x4 matrix of words is stored back into the %1.
    execution: *executionMADDSU44BW
    behavior: *behaviorMADDSU44BW
  - ID: XFFMA44HW
    what: Floating-Point Fused Multiply-Add 4x4 Half Words to Words
    class: EXT
    formats: [ EXT_FFMAHW ]
    properties: { '%0': Extension }
    description: >
      The %2 and the %3 are interpreted as 4x4 matrices of binary 16 floating-point numbers, and the %1 is interpreted
      as a 4x4 matrix of binary 32 floating-point numbers. Each element of the first two columns of the %2 is multiplied
      by the corresponding element of the %3 and the product is added to the corresponding elements of the %1.
      Each result is rounded and the resulting 4x4 matrix of words is stored back into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new input3_0 = join_32_x4(argument3_0, argument3_2, argument3_4, argument3_6);
      new input2_0 = join_32_x4(argument2_0, argument2_2, argument2_4, argument2_6);
      new result1_0 = f32_widenMulAdd_x8(XRM, input3_0, input2_0, argument1_0);
      new input3_1 = join_32_x4(argument3_1, argument3_3, argument3_5, argument3_7);
      new input2_1 = join_32_x4(argument2_1, argument2_3, argument2_5, argument2_7);
      new result1_1 = f32_widenMulAdd_x8_noreset(XRM, input3_1, input2_1, argument1_1);
    behavior: |
      (SEQ
        (WRITE.input3_0
          (APPLY.128.join_32_x4
            (READ.argument3_0)
            (READ.argument3_2)
            (READ.argument3_4)
            (READ.argument3_6)
          )
        )
        (WRITE.input2_0
          (APPLY.128.join_32_x4
            (READ.argument2_0)
            (READ.argument2_2)
            (READ.argument2_4)
            (READ.argument2_6)
          )
        )
        (WRITE.result1_0
          (APPLY.f32_widenMulAdd_x8
            (READ.XRM)
            (READ.input3_0)
            (READ.input2_0)
            (READ.argument1_0)
          )
        )
        (WRITE.input3_1
          (APPLY.128.join_32_x4
            (READ.argument3_1)
            (READ.argument3_3)
            (READ.argument3_5)
            (READ.argument3_7)
          )
        )
        (WRITE.input2_1
          (APPLY.128.join_32_x4
            (READ.argument2_1)
            (READ.argument2_3)
            (READ.argument2_5)
            (READ.argument2_7)
          )
        )
        (WRITE.result1_1
          (APPLY.f32_widenMulAdd_x8_noreset
            (READ.XRM)
            (READ.input3_1)
            (READ.input2_1)
            (READ.argument1_1)
          )
        )
      )
  - ID: XFMINHX
    what: Floating-Point Minimum Half Word Hexadecuple
    class: EXT
    formats: [ EXT_FMINMAX ]
    description: >
      The %2 is compared to the %3, assuming hexadecuple of binary 16 floating-point
      numbers. The hexadecuple of minimum values is stored into the %1.
    execution: |
      new result1 = f16_minNum_x16(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_minNum_x16
          (READ.argument2)
          (READ.argument3)))
  - ID: XFMAXHX
    what: Floating-Point Maximum Half Word Hexadecuple
    class: EXT
    formats: [ EXT_FMINMAX ]
    description: >
      The %2 is compared to the %3, assuming hexadecuple of binary 16 floating-point
      numbers. The hexadecuple of maximum values is stored into the %1.
    execution: |
      new result1 = f16_maxNum_x16(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_maxNum_x16
          (READ.argument2)
          (READ.argument3)))
  - ID: XCLAMPWO
    what: Clamp Word Octuple
    class: EXT
    formats: [ EXT_CLAMPWO ]
    properties: { '%0': Extension }
    description: >
      The %1, %2, %3 are interpreted as vectors of 8 signed integer words. The element-wise maximum
      between the %1 and the %2 is computed, producing a temporary vector. The element-wise minimum between this
      temporary vector and the %3 is computed, producing a result which is stored back into the %1.
    execution: |
      new result1 = clamp_32_32_x8(argument1, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.256.clamp_32_32_x8
          (READ.argument1)
          (READ.argument2)
          (READ.argument3)))
  - ID: XFNARROW44WH
    what: Floating Point Narrow 4x4 Matrix Word to Half Word
    class: EXT
    formats: [ EXT_FNARROWWH ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a 4x4 matrix of binary 32 floating-point numbers.
      This matrix is converted to a 4x4 matrix of binary 16 floating-point numbers
      according to the current rounding mode and stored into the %1.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new argument_0 = join_64_x4(argument2_0_0_0_1, argument2_0_2_0_3, argument2_1_0_1_1, argument2_1_2_1_3);
      new argument_1 = join_64_x4(argument2_2_0_2_1, argument2_2_2_2_3, argument2_3_0_3_1, argument2_3_2_3_3);
      new result1_0 = f32_to_f16_x8(XRM, argument_0);
      new result1_1 = f32_to_f16_x8_noreset(XRM, argument_1);
    behavior: |
      (SEQ
        (WRITE.argument_0
          (APPLY.256.join_64_x4
            (READ.argument2_0_0_0_1)
            (READ.argument2_0_2_0_3)
            (READ.argument2_1_0_1_1)
            (READ.argument2_1_2_1_3)
          )
        )
        (WRITE.argument_1
          (APPLY.256.join_64_x4
            (READ.argument2_2_0_2_1)
            (READ.argument2_2_2_2_3)
            (READ.argument2_3_0_3_1)
            (READ.argument2_3_2_3_3)
          )
        )
        (WRITE.result1_0
          (APPLY.128.f32_to_f16_x8
            (READ.XRM)
            (READ.argument_0)
          )
        )
        (WRITE.result1_1
          (APPLY.128.f32_to_f16_x8_noreset
            (READ.XRM)
            (READ.argument_1)
          )
        )
      )
  - ID: XTRUNC48WB
    what: Truncate 4x8 Matrix Word to Byte
    class: EXT
    formats: [ EXT_TRUNCWB ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a 4x8 matrix of signed integer words. This matrix is truncated
      element-wise to a 4x8 matrix of bytes, which is stored into the %1.
    execution: |
      new row_0 = transpose_64_4x4_0(argument2_0, argument2_1, argument2_2, argument2_3);
      new row_1 = transpose_64_4x4_1(argument2_0, argument2_1, argument2_2, argument2_3);
      new row_2 = transpose_64_4x4_2(argument2_0, argument2_1, argument2_2, argument2_3);
      new row_3 = transpose_64_4x4_3(argument2_0, argument2_1, argument2_2, argument2_3);
      new result1_0 = trunc_32_8_x8(row_0);
      new result1_1 = trunc_32_8_x8(row_1);
      new result1_2 = trunc_32_8_x8(row_2);
      new result1_3 = trunc_32_8_x8(row_3);
      new result1 = join_64_x4(result1_0, result1_1, result1_2, result1_3);
    behavior: |
      (SEQ
        (WRITE.row_0
          (APPLY.256.transpose_64_4x4_0
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.row_1
          (APPLY.256.transpose_64_4x4_1
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.row_2
          (APPLY.256.transpose_64_4x4_2
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.row_3
          (APPLY.256.transpose_64_4x4_3
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.result1_0 (APPLY.64.trunc_32_8_x8 (READ.row_0)))
        (WRITE.result1_1 (APPLY.64.trunc_32_8_x8 (READ.row_1)))
        (WRITE.result1_2 (APPLY.64.trunc_32_8_x8 (READ.row_2)))
        (WRITE.result1_3 (APPLY.64.trunc_32_8_x8 (READ.row_3)))
        (WRITE.result1
          (APPLY.256.join_64_x4
            (READ.result1_0)
            (READ.result1_1)
            (READ.result1_2)
            (READ.result1_3))))
  - ID: XSX48BW
    what: Sign Extend 4x8 Matrix Byte to Word
    class: EXT
    formats: [ EXT_XEXTBW ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted a 4x8 matrix of bytes. Each byte element is sign-extended to 32 bits,
      and the resulting 4x8 matrix of integer words is stored into the %1.
    execution: |
      new row_0 = sx_8_32_x8(argument2_0);
      new row_1 = sx_8_32_x8(argument2_1);
      new row_2 = sx_8_32_x8(argument2_2);
      new row_3 = sx_8_32_x8(argument2_3);
      new result1_0 = transpose_64_4x4_0(row_0, row_1, row_2, row_3);
      new result1_1 = transpose_64_4x4_1(row_0, row_1, row_2, row_3);
      new result1_2 = transpose_64_4x4_2(row_0, row_1, row_2, row_3);
      new result1_3 = transpose_64_4x4_3(row_0, row_1, row_2, row_3);
    behavior: |
      (SEQ
        (WRITE.row_0 (APPLY.256.sx_8_32_x8 (READ.argument2_0)))
        (WRITE.row_1 (APPLY.256.sx_8_32_x8 (READ.argument2_1)))
        (WRITE.row_2 (APPLY.256.sx_8_32_x8 (READ.argument2_2)))
        (WRITE.row_3 (APPLY.256.sx_8_32_x8 (READ.argument2_3)))
        (WRITE.result1_0
          (APPLY.256.transpose_64_4x4_0
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_1
          (APPLY.256.transpose_64_4x4_1
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_2
          (APPLY.256.transpose_64_4x4_2
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_3
          (APPLY.256.transpose_64_4x4_3
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3))))
  - ID: XZX48BW
    what: Zero Extend 4x8 Matrix Byte to Word
    class: EXT
    formats: [ EXT_XEXTBW ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted a 4x8 matrix of bytes. Each byte element is zero-extended to 32 bits,
      and the resulting 4x8 matrix of integer words is stored into the %1.
    execution: |
      new row_0 = zx_8_32_x8(argument2_0);
      new row_1 = zx_8_32_x8(argument2_1);
      new row_2 = zx_8_32_x8(argument2_2);
      new row_3 = zx_8_32_x8(argument2_3);
      new result1_0 = transpose_64_4x4_0(row_0, row_1, row_2, row_3);
      new result1_1 = transpose_64_4x4_1(row_0, row_1, row_2, row_3);
      new result1_2 = transpose_64_4x4_2(row_0, row_1, row_2, row_3);
      new result1_3 = transpose_64_4x4_3(row_0, row_1, row_2, row_3);
    behavior: |
      (SEQ
        (WRITE.row_0 (APPLY.256.zx_8_32_x8 (READ.argument2_0)))
        (WRITE.row_1 (APPLY.256.zx_8_32_x8 (READ.argument2_1)))
        (WRITE.row_2 (APPLY.256.zx_8_32_x8 (READ.argument2_2)))
        (WRITE.row_3 (APPLY.256.zx_8_32_x8 (READ.argument2_3)))
        (WRITE.result1_0
          (APPLY.256.transpose_64_4x4_0
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_1
          (APPLY.256.transpose_64_4x4_1
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_2
          (APPLY.256.transpose_64_4x4_2
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3)))
        (WRITE.result1_3
          (APPLY.256.transpose_64_4x4_3
            (READ.row_0)
            (READ.row_1)
            (READ.row_2)
            (READ.row_3))))
Modifier:
  - ID: exunum
    what: Execution Unit Number in Immediate Extensions
    members: [ ALU0, ALU1, MAU, LSU ]
    execution: "_ZX_2(%0)"
    cases:
      - ALU 0
      - ALU 1
      - MAU
      - LSU
  - ID: scalarcond
    what: Scalar Condition
    members: [ .DNEZ, .DEQZ, .DLTZ, .DGEZ, .DLEZ, .DGTZ, .ODD, .EVEN, .WNEZ, .WEQZ, .WLTZ, .WGEZ, .WLEZ, .WGTZ ]
    cases:
      - Double Not Equal to Zero
      - Double Equal to Zero
      - Double Less Than Zero
      - Double Greater Than or Equal to Zero
      - Double Less Than or Equal to Zero
      - Double Greater Than Zero
      - Odd (LSB Set)
      - Even (LSB Clear)
      - Word Not Equal to Zero
      - Word Equal to Zero
      - Word Less Than Zero
      - Word Greater Than or Equal to Zero
      - Word Less Than or Equal to Zero
      - Word Greater Than Zero
    execution: "_ZX_4(%0)"
  - ID: lsomask
    what: LO and SO Mask
    members: [ .U0, .U1, .U2, .U3, .MT, .MF, .MTC, .MFC ]
    cases:
      - Unused 0
      - Unused 1
      - Unused 2
      - Unused 3
      - Mask True
      - Mask False
      - Mask True or Clear
      - Mask False or Clear
    execution: "_ZX_4(%0)"
  - ID: lsumask
    what: LSU Mask
    members: [ .DNEZ, .DEQZ, .WNEZ, .WEQZ, .MT, .MF, .MTC, .MFC ]
    cases:
      - Double Not Equal to Zero
      - Double Equal to Zero
      - Word Not Equal to Zero
      - Word Equal to Zero
      - Mask True
      - Mask False
      - Mask True or Clear
      - Mask False or Clear
    execution: "_ZX_4(%0)"
  - ID: simdcond
    what: SIMD Condition
    members: [ .NEZ, .EQZ, .LTZ, .GEZ, .LEZ, .GTZ, .ODD, .EVEN ]
    cases:
      - Not Equal to Zero
      - Equal to Zero
      - Less Than Zero
      - Greater Than or Equal to Zero
      - Less Than or Equal to Zero
      - Greater Than Zero
      - Odd (LSB Set)
      - Even (LSB Clear)
    execution: "_ZX_3(%0)"
  - ID: comparison
    what: Integer and Bit Comparison
    members: [ .NE, .EQ, .LT, .GE, .LE, .GT, .LTU, .GEU, .LEU, .GTU, .ALL, .NALL, .ANY, .NONE ]
    cases:
      - Not Equal
      - Equal
      - Less Than
      - Greater Than or Equal
      - Less Than or Equal
      - Greater Than
      - Less Than Unsigned
      - Greater Than or Equal Unsigned
      - Less Than or Equal Unsigned
      - Greater Than Unsigned
      - All Bits Set in Mask
      - Not All Bits Set in Mask
      - Any Bits Set in Mask
      - Not Any Bits Set in Mask
    execution: "_ZX_4(%0)"
  - ID: floatcomp
    what: Floating-Point Comparison
    members: [ .ONE, .UEQ, .OEQ, .UNE, .OLT, .UGE, .OGE, .ULT ]
    cases:
      - Ordered and Not Equal
      - Unordered or Equal
      - Ordered and Equal
      - Unordered or Not Equal
      - Ordered and Less Than
      - Unordered or Greater Than or Equal
      - Ordered and Greater Than or Equal
      - Unordered or Less Than
    execution: "_ZX_3(%0)"
  - ID: rounding
    what: Floating-Point Rounding Mode
    members: [ .RN, .RU, .RD, .RZ, .R4, .R5, .RO, . ]
    cases:
      - Round to Nearest, ties to Even
      - Round Upward
      - Round Downward
      - Round toward Zero
      - Reserved 4
      - Reserved 5
      - Reserved 6
      - Use CS rounding
    execution: "_ZX_3(%0)"
  - ID: silent
    what: Floating-Point Effects on CS
    members: [ ., .S ]
    cases:
      - Effects on CS
      - Silent on CS
    execution: "_ZX_1(%0)"
    properties:
      '%CS.S': NoWrite
  - ID: variant
    what: Load Variants
    members: [ ., .S, .U, .US ]
    cases:
      - Cached
      - Speculative
      - Uncached
      - Uncached Speculative
    execution: "_ZX_2(%0)"
    properties:
      '%0.S': Dismissible,
      '%0.U': MemoryLevel=2
      '%0.US': MemoryLevel=2;Dismissible
  - ID: speculate
    what: Speculative Load
    members: [ .U, .US ]
    cases:
      - Uncached
      - Uncached Speculative
    execution: "_ZX_1(%0)"
    properties:
      '%0.U': MemoryLevel=2
      '%0.US': MemoryLevel=2;Dismissible
  - ID: doscale
    what: Enable Scaling for Indexed Addressing
    members: [ ., .XS ]
    cases:
      - Scale by 1
      - Scale by sizeof
    execution: "_ZX_1(%0)"
  - ID: qindex
    what: Quarter Index
    members: [ .Q0, .Q1, .Q2, .Q3 ]
    cases:
      - Quarter 0
      - Quarter 1
      - Quarter 2
      - Quarter 3
    execution: "_ZX_2(%0)"
  - ID: hindex
    what: Half Index
    members: [ .H0, .H1 ]
    cases:
      - Half 0
      - Half 1
    execution: "_ZX_1(%0)"
  - ID: cachelev
    what: Cache Level for Set/Way maintenance
    members: [ .L1, .L2 ]
    cases:
      - L1 Cache
      - L2 Cache
    execution: "_ZX_2(%0)"
  - ID: coherency
    what: Coherency Domain for atomics
    members: [ ., .G, .S ]
    cases:
      - Local
      - Global
      - Reserved
    execution: "_ZX_2(%0)"
  - ID: boolcas
    what: Boolean Compare-and-Swap
    members: [ .V, . ]
    cases:
      - Valued CAS
      - Boolean CAS
    execution: "_ZX_1(%0)"
  - ID: accesses
    what: Fence Access
    members: [ ., .W, .R, .WA ]
    cases:
      - All Accesses
      - Write Accesses
      - Read Accesses
      - Write Accesses (asynchronous)
    execution: "_ZX_2(%0)"
  - ID: channel
    what: Coprocessor Channel
    members: [ .F, .B ]
    cases:
      - Forward Channel
      - Backward Channel
    execution: "_ZX_1(%0)"
  - ID: conjugate
    what: Complex Conjugate
    members: [ ., .C ]
    cases:
      - Default
      - Conjugate
    execution: "_ZX_1(%0)"
  - ID: transpose
    what: Transpose Multiplicands
    members: [ ., .TN, .NT, .TT ]
    cases:
      - Normal Normal
      - Transpose Normal
      - Normal Transpose
      - Transpose Transpose
    execution: "_ZX_2(%0)"
  - ID: shuffleV
    what: Shuffle a Word Vector (1024 bits)
    members: [ ., .TD ]
    cases:
      - No Shuffle
      - Transpose Double Words 4x4
    execution: "_ZX_1(%0)"
  - ID: shuffleX
    what: Shuffle a Word Hexadecuple (512 bits)
    members: [ ., .ZD, .UD, .TQ, .TW, .ZW, .UW ]
    cases:
      - No Shuffle
      - Zip Double Words
      - Unzip Double Words
      - Transpose Quadruple Words 2x2
      - Transpose Words 4x4
      - Zip Words
      - Unzip Words
    execution: "_ZX_3(%0)"
  - ID: splat32
    what: Splat 32-bit Immediate
    members: [ ., ".@" ]
    cases:
      - No splat
      - Splat x2
    execution: "_ZX_1(%0)"
NativeType:
  - ID: Void
    align: 0
    printf: ".void"
    sizeof: 0
    width: 0
    type: Void
  - ID: Bool
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 1
    type: Bool
  - ID: Int8
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 8
    type: Signed
  - ID: Int16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Signed
  - ID: Int32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Signed
  - ID: Int64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Signed
  - ID: Int128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Signed
  - ID: Int128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Signed
  - ID: Int128x4
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 64
    slice: 32
    width: 512
    type: Signed
  - ID: Int128x8
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 128
    slice: 32
    width: 1024
    type: Signed
  - ID: Int128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Signed
  - ID: UInt8
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 8
    type: Unsigned
  - ID: UInt16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Unsigned
  - ID: UInt32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Unsigned
  - ID: UInt64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Unsigned
  - ID: UInt128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Unsigned
  - ID: UInt128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Unsigned
  - ID: UInt128x4
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 64
    slice: 32
    width: 512
    type: Unsigned
  - ID: UInt128x8
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 128
    slice: 32
    width: 1024
    type: Unsigned
  - ID: Float16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Float
  - ID: Float32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Float
  - ID: Float64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Float
  - ID: Float128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Float
Platform:
  - ID: kv3_32
    charWidth: 8
    addrWidth: 32
    endian: Little
    alignText: 8
    alignData: 8
    alignHeap: 8
    alignStack: 8
    nativeInt: Int32
    nativeUInt: UInt32
    nativeFloat: Float64
    nativePtr: UInt32
  - ID: kv3_64
    charWidth: 8
    addrWidth: 32
    endian: Little
    alignText: 8
    alignData: 8
    alignHeap: 8
    alignStack: 8
    nativeInt: Int32
    nativeUInt: UInt32
    nativeFloat: Float64
    nativePtr: UInt64
Processor:
  - ID: cpu
    minTaken: 1
    interlocks: 1
    pipeline: [ ID, RR, E1, E2, CR, E3, E4, E5, WB, SF, SR ]
    stages: [ 0, 1, 2, 3, 4, 4, 5, 6, 6, 16, 24 ]
RegClass:
  - ID: aloneReg
    what: RegClas Implying Alone in Bundle
    registers: [ MMC, PS, SYOW, HTOW, ITOW, DOW, MOW, PSOW, SPS, SPS_PL0, SPS_PL1, SPS_PL2, SPS_PL3 ]
    execution: "SFR[%0]"
  - ID: onlyraReg
    what: Singleton RegClas with RA
    registers: [ RA ]
    execution: "SFR[%0]"
  - ID: onlygetReg
    what: Only GET System Registers
    include: systemReg
    exclude: [ RES31, [ RES<i>, 38..39 ], [ RES<i>, 47..63 ], [ RES<i>, 88..95 ], SYOW, HTOW, ITOW, DOW, MOW, PSOW, [ RES<i>, 102..127 ], [ RES<i>, 102..127 ], [ RES<i>, 129..131 ], [ RES<i>, 133..135 ], [ RES<i>, 137..139 ], [ RES<i>, 141..143 ], [ RES<i>, 145..147 ], [ RES<i>, 149..3839 ] ]
    execution: "SFR[%0]"
  - ID: onlysetReg
    what: Only SET System Registers without PS
    include: systemReg
    exclude: [ PC, RES31, [ RES<i>, 38..39 ], [ RES<i>, 47..63 ], [ RES<i>, 88..95 ], SYO, HTO, ITO, DO, MO, PSO, SYOW, HTOW, ITOW, DOW, MOW, PSOW, [ RES<i>, 102..127 ], [ RES<i>, 102..127 ], [ RES<i>, 129..131 ], [ RES<i>, 133..135 ], [ RES<i>, 137..139 ], [ RES<i>, 141..143 ], [ RES<i>, 145..147 ], [ RES<i>, 149..3839 ] ]
    execution: "SFR[%0]"
  - ID: onlyfxReg
    what: Only FX System Registers without PS
    registers: [ PCR, CS, CSIT, IPE, MEN, PMC, TCR, ILE, ILL, ILR, MMC, TEL, TEH, IXC, MES, WS, DC0, DC1, DC2, DC3, PMC2, [ SPS_PL<i>, 0..3 ], [ ES_PL<r>, 0..3 ], SPS, ES , [ TPCC_PL<r>, 0..3 ], TPCC ]
    execution: "SFR[%0]"
  - ID: onlyswapReg
    what: Only SWAP System Registers without PS
    include: systemReg
    exclude: [ PS ]
    execution: "SFR[%0]"
  - ID: xworddReg
    what: Extension Word Double Registers
    registers: C0..C255
    shortName: c
    execution: "XCR[%0]"
  - ID: xwordqReg
    what: Extension Word Quadruple Registers
    multi: [ xworddReg, xworddReg ]
    registers: B0..B127
    shortName: b
    execution: "XBR[%0]"
  - ID: xwordoReg
    multi: [ xworddReg, xworddReg, xworddReg, xworddReg ]
    what: Extension Word Octuple Registers
    registers: A0..A63
    shortName: a
    execution: "XVR[%0]"
  - ID: xwordxReg
    what: Extension Word Hexadecuple Register
    multi: [ xwordoReg, xwordoReg ]
    registers: T0..T31
    shortName: x
    execution: "XTR[%0]"
  - ID: xwordvReg
    what: Extension Word Vector Registers
    multi: [ xwordoReg, xwordoReg, xwordoReg, xwordoReg ]
    registers: M0..M15
    shortName: m
    execution: "XMR[%0]"
  - ID: xwordqRegE
    what: Block Registers Even Numbered
    registers: [ B0, B2, B4, B6, B8, B10, B12, B14, B16, B18, B20, B22, B24, B26, B28, B30, B32, B34, B36, B38, B40, B42, B44, B46, B48, B50, B52, B54, B56, B58, B60, B62, B64, B66, B68, B70, B72, B74, B76, B78, B80, B82, B84, B86, B88, B90, B92, B94, B96, B98, B100, B102, B104, B106, B108, B110, B112, B114, B116, B118, B120, B122, B124, B126 ]
    execution: "XBR[%0<<1]"
  - ID: xwordqRegO
    what: Block Registers Odd Numbered
    registers: [ B1, B3, B5, B7, B9, B11, B13, B15, B17, B19, B21, B23, B25, B27, B29, B31, B33, B35, B37, B39, B41, B43, B45, B47, B49, B51, B53, B55, B57, B59, B61, B63, B65, B67, B69, B71, B73, B75, B77, B79, B81, B83, B85, B87, B89, B91, B93, B95, B97, B99, B101, B103, B105, B107, B109, B111, B113, B115, B117, B119, B121, B123, B125, B127 ]
    execution: "XBR[(%0<<1)+1]"
  - ID: xworddReg0M4
    what: Coprocessor Registers 0 Modulo 4
    registers: [ C0, C4, C8, C12, C16, C20, C24, C28, C32, C36, C40, C44, C48, C52, C56, C60, C64, C68, C72, C76, C80, C84, C88, C92, C96, C100, C104, C108, C112, C116, C120, C124, C128, C132, C136, C140, C144, C148, C152, C156, C160, C164, C168, C172, C176, C180, C184, C188, C192, C196, C200, C204, C208, C212, C216, C220, C224, C228, C232, C236, C240, C244, C248, C252, ]
    execution: "XCR[%0<<2]"
  - ID: xworddReg1M4
    what: Coprocessor Registers 1 Modulo 4
    registers: [ C1, C5, C9, C13, C17, C21, C25, C29, C33, C37, C41, C45, C49, C53, C57, C61, C65, C69, C73, C77, C81, C85, C89, C93, C97, C101, C105, C109, C113, C117, C121, C125, C129, C133, C137, C141, C145, C149, C153, C157, C161, C165, C169, C173, C177, C181, C185, C189, C193, C197, C201, C205, C209, C213, C217, C221, C225, C229, C233, C237, C241, C245, C249, C253, ]
    execution: "XCR[(%0<<2)+1]"
  - ID: xworddReg2M4
    what: Coprocessor Registers 2 Modulo 4
    registers: [ C2, C6, C10, C14, C18, C22, C26, C30, C34, C38, C42, C46, C50, C54, C58, C62, C66, C70, C74, C78, C82, C86, C90, C94, C98, C102, C106, C110, C114, C118, C122, C126, C130, C134, C138, C142, C146, C150, C154, C158, C162, C166, C170, C174, C178, C182, C186, C190, C194, C198, C202, C206, C210, C214, C218, C222, C226, C230, C234, C238, C242, C246, C250, C254, ]
    execution: "XCR[(%0<<2)+2]"
  - ID: xworddReg3M4
    what: Coprocessor Registers 3 Modulo 4
    registers: [ C3, C7, C11, C15, C19, C23, C27, C31, C35, C39, C43, C47, C51, C55, C59, C63, C67, C71, C75, C79, C83, C87, C91, C95, C99, C103, C107, C111, C115, C119, C123, C127, C131, C135, C139, C143, C147, C151, C155, C159, C163, C167, C171, C175, C179, C183, C187, C191, C195, C199, C203, C207, C211, C215, C219, C223, C227, C231, C235, C239, C243, C247, C251, C255, ]
    execution: "XCR[(%0<<2)+3]"
RegField:
################ MEN ################
  - ID: MEN_MEN
    what: Miscellaneous External Notifications
    location: [ MEN, 0..15 ]
    owners: [ MO_MEN ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MEN
    reset: 0
################ SYO ################
  - ID: SYO_Q0
    what: Quarter 0 syscalls 0 to 1023 owner
    location: [ SYO, 0..1 ]
    reset: 0
  - ID: SYO_Q1
    what: Quarter 1 syscalls 1024 to 2047 owner
    location: [ SYO, 2..3 ]
    reset: 0
  - ID: SYO_Q2
    what: Quarter 2 syscalls 2048 to 3071 owner
    location: [ SYO, 4..5 ]
    reset: 0
  - ID: SYO_Q3
    what: Quarter 3 syscalls 3072 to 4095 owner
    location: [ SYO, 6..7 ]
    reset: 0
################ SYOW ################
  - ID: SYOW_Q0
    what: Quarter 0 syscalls 0 to 1023 owner
    location: [ SYO, 0..1 ]
    owners: [ SYO_Q0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q1
    what: Quarter 1 syscalls 1024 to 2047 owner
    location: [ SYO, 2..3 ]
    owners: [ SYO_Q1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q2
    what: Quarter 2 syscalls 2048 to 3071 owner
    location: [ SYO, 4..5 ]
    owners: [ SYO_Q2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q3
    what: Quarter 3 syscalls 3072 to 4095 owner
    location: [ SYO, 6..7 ]
    owners: [ SYO_Q3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
################ HTO ################
  - ID: HTO_OPC
    what: OPCode trap owner
    location: [ HTO, 0..1 ]
    reset: 0
  - ID: HTO_DMIS
    what: Data MISalign access trap owner
    location: [ HTO, 2..3 ]
    reset: 0
  - ID: HTO_PSYS
    what: Program System Error trap owner
    location: [ HTO, 4..5 ]
    reset: 0
  - ID: HTO_DSYS
    what: Data System Error trap owner
    location: [ HTO, 6..7 ]
    reset: 0
  - ID: HTO_DECCG
    what: Double ECC traps group owner
    location: [ HTO, 8..9 ]
    reset: 0
  - ID: HTO_SECCG
    what: Single ECC traps group owner
    location: [ HTO, 10..11 ]
    reset: 0
  - ID: HTO_NOMAP
    what: No mapping trap owner
    location: [ HTO, 12..13 ]
    reset: 0
  - ID: HTO_PROT
    what: PROTection trap owner
    location: [ HTO, 14..15 ]
    reset: 0
  - ID: HTO_W2CL
    what: Write to clean trap owner
    location: [ HTO, 16..17 ]
    reset: 0
  - ID: HTO_A2CL
    what: Atomic to clean trap owner
    location: [ HTO, 18..19 ]
    reset: 0
  - ID: HTO_DE
    what: Double Exception trap owner
    location: [ HTO, 20..21 ]
    reset: 0
  - ID: HTO_VSFR
    what: Virtual SFR trap owner
    location: [ HTO, 22..23 ]
    reset: 0
  - ID: HTO_PLO
    what: Privilege Level Overflow trap owner
    location: [ HTO, 24..25 ]
    reset: 0
################ HTOW ################
  - ID: HTOW_OPC
    what: OPCode trap owner
    location: [ HTO, 0..1 ]
    owners: [ HTO_OPC ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DMIS
    what: Data MISalign access trap owner
    location: [ HTO, 2..3 ]
    owners: [ HTO_DMIS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PSYS
    what: Program System Error trap owner
    location: [ HTO, 4..5 ]
    owners: [ HTO_PSYS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DSYS
    what: Data System Error trap owner
    location: [ HTO, 6..7 ]
    owners: [ HTO_DSYS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DECCG
    what: Double ECC traps group owner
    location: [ HTO, 8..9 ]
    owners: [ HTO_DECCG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_SECCG
    what: Single ECC traps group owner
    location: [ HTO, 10..11 ]
    owners: [ HTO_SECCG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_NOMAP
    what: No mapping trap owner
    location: [ HTO, 12..13 ]
    owners: [ HTO_NOMAP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PROT
    what: PROTection trap owner
    location: [ HTO, 14..15 ]
    owners: [ HTO_PROT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_W2CL
    what: Write to clean trap owner
    location: [ HTO, 16..17 ]
    owners: [ HTO_W2CL ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_A2CL
    what: Atomic to clean trap owner
    location: [ HTO, 18..19 ]
    owners: [ HTO_A2CL ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DE
    what: Double Exception trap owner
    location: [ HTO, 20..21 ]
    owners: [ HTO_DE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_VSFR
    what: Virtual SFR trap owner
    location: [ HTO, 22..23 ]
    owners: [ HTO_VSFR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PLO
    what: Privilege Level Overflow trap owner
    location: [ HTO, 24..25 ]
    owners: [ HTO_PLO ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
################ ITO ################
  - ID: ITO_IT0
    what: Interrupt 0 owner
    location: [ ITO, 0..1 ]
    reset: 0
  - ID: ITO_IT1
    what: Interrupt 1 owner
    location: [ ITO, 2..3 ]
    reset: 0
  - ID: ITO_IT2
    what: Interrupt 2 owner
    location: [ ITO, 4..5 ]
    reset: 0
  - ID: ITO_IT3
    what: Interrupt 3 owner
    location: [ ITO, 6..7 ]
    reset: 0
  - ID: ITO_IT4
    what: Interrupt 4 owner
    location: [ ITO, 8..9 ]
    reset: 0
  - ID: ITO_IT5
    what: Interrupt 5 owner
    location: [ ITO, 10..11 ]
    reset: 0
  - ID: ITO_IT6
    what: Interrupt 6 owner
    location: [ ITO, 12..13 ]
    reset: 0
  - ID: ITO_IT7
    what: Interrupt 7 owner
    location: [ ITO, 14..15 ]
    reset: 0
  - ID: ITO_IT8
    what: Interrupt 8 owner
    location: [ ITO, 16..17 ]
    reset: 0
  - ID: ITO_IT9
    what: Interrupt 9 owner
    location: [ ITO, 18..19 ]
    reset: 0
  - ID: ITO_IT10
    what: Interrupt 10 owner
    location: [ ITO, 20..21 ]
    reset: 0
  - ID: ITO_IT11
    what: Interrupt 11 owner
    location: [ ITO, 22..23 ]
    reset: 0
  - ID: ITO_IT12
    what: Interrupt 12 owner
    location: [ ITO, 24..25 ]
    reset: 0
  - ID: ITO_IT13
    what: Interrupt 13 owner
    location: [ ITO, 26..27 ]
    reset: 0
  - ID: ITO_IT14
    what: Interrupt 14 owner
    location: [ ITO, 28..29 ]
    reset: 0
  - ID: ITO_IT15
    what: Interrupt 15 owner
    location: [ ITO, 30..31 ]
    reset: 0
  - ID: ITO_IT16
    what: Interrupt 16 owner
    location: [ ITO, 32..33 ]
    reset: 0
  - ID: ITO_IT17
    what: Interrupt 17 owner
    location: [ ITO, 34..35 ]
    reset: 0
  - ID: ITO_IT18
    what: Interrupt 18 owner
    location: [ ITO, 36..37 ]
    reset: 0
  - ID: ITO_IT19
    what: Interrupt 19 owner
    location: [ ITO, 38..39 ]
    reset: 0
  - ID: ITO_IT20
    what: Interrupt 20 owner
    location: [ ITO, 40..41 ]
    reset: 0
  - ID: ITO_IT21
    what: Interrupt 21 owner
    location: [ ITO, 42..43 ]
    reset: 0
  - ID: ITO_IT22
    what: Interrupt 22 owner
    location: [ ITO, 44..45 ]
    reset: 0
  - ID: ITO_IT23
    what: Interrupt 23 owner
    location: [ ITO, 46..47 ]
    reset: 0
  - ID: ITO_IT24
    what: Interrupt 24 owner
    location: [ ITO, 48..49 ]
    reset: 0
  - ID: ITO_IT25
    what: Interrupt 25 owner
    location: [ ITO, 50..51 ]
    reset: 0
  - ID: ITO_IT26
    what: Interrupt 26 owner
    location: [ ITO, 52..53 ]
    reset: 0
  - ID: ITO_IT27
    what: Interrupt 27 owner
    location: [ ITO, 54..55 ]
    reset: 0
  - ID: ITO_IT28
    what: Interrupt 28 owner
    location: [ ITO, 56..57 ]
    reset: 0
  - ID: ITO_IT29
    what: Interrupt 29 owner
    location: [ ITO, 58..59 ]
    reset: 0
  - ID: ITO_IT30
    what: Interrupt 30 owner
    location: [ ITO, 60..61 ]
    reset: 0
  - ID: ITO_IT31
    what: Interrupt 31 owner
    location: [ ITO, 62..63 ]
    reset: 0
################ ILE ################
  - ID: ILE_IT0
    what: Interrupt 0 owner
    location: [ ILE, 0 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT1
    what: Interrupt 1 owner
    location: [ ILE, 1 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT2
    what: Interrupt 2 owner
    location: [ ILE, 2 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT3
    what: Interrupt 3 owner
    location: [ ILE, 3 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT4
    what: Interrupt 4 owner
    location: [ ILE, 4 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT5
    what: Interrupt 5 owner
    location: [ ILE, 5 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT6
    what: Interrupt 6 owner
    location: [ ILE, 6 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT7
    what: Interrupt 7 owner
    location: [ ILE, 7 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT8
    what: Interrupt 8 owner
    location: [ ILE, 8 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT9
    what: Interrupt 9 owner
    location: [ ILE, 9 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT10
    what: Interrupt 10 owner
    location: [ ILE, 10 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT11
    what: Interrupt 11 owner
    location: [ ILE, 11 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT12
    what: Interrupt 12 owner
    location: [ ILE, 12 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT13
    what: Interrupt 13 owner
    location: [ ILE, 13 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT14
    what: Interrupt 14 owner
    location: [ ILE, 14 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT15
    what: Interrupt 15 owner
    location: [ ILE, 15 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT16
    what: Interrupt 16 owner
    location: [ ILE, 16 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT17
    what: Interrupt 17 owner
    location: [ ILE, 17 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT18
    what: Interrupt 18 owner
    location: [ ILE, 18 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT19
    what: Interrupt 19 owner
    location: [ ILE, 19 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT20
    what: Interrupt 20 owner
    location: [ ILE, 20 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT21
    what: Interrupt 21 owner
    location: [ ILE, 21 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT22
    what: Interrupt 22 owner
    location: [ ILE, 22 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT23
    what: Interrupt 23 owner
    location: [ ILE, 23 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT24
    what: Interrupt 24 owner
    location: [ ILE, 24 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT25
    what: Interrupt 25 owner
    location: [ ILE, 25 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT26
    what: Interrupt 26 owner
    location: [ ILE, 26 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT27
    what: Interrupt 27 owner
    location: [ ILE, 27 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT28
    what: Interrupt 28 owner
    location: [ ILE, 28 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT29
    what: Interrupt 29 owner
    location: [ ILE, 29 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT30
    what: Interrupt 30 owner
    location: [ ILE, 30 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT31
    what: Interrupt 31 owner
    location: [ ILE, 31 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ILL ################
  - ID: ILL_IT0
    what: Interrupt 0 owner
    location: [ ILL, 0..1 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT1
    what: Interrupt 1 owner
    location: [ ILL, 2..3 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT2
    what: Interrupt 2 owner
    location: [ ILL, 4..5 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT3
    what: Interrupt 3 owner
    location: [ ILL, 6..7 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT4
    what: Interrupt 4 owner
    location: [ ILL, 8..9 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT5
    what: Interrupt 5 owner
    location: [ ILL, 10..11 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT6
    what: Interrupt 6 owner
    location: [ ILL, 12..13 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT7
    what: Interrupt 7 owner
    location: [ ILL, 14..15 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT8
    what: Interrupt 8 owner
    location: [ ILL, 16..17 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT9
    what: Interrupt 9 owner
    location: [ ILL, 18..19 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT10
    what: Interrupt 10 owner
    location: [ ILL, 20..21 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT11
    what: Interrupt 11 owner
    location: [ ILL, 22..23 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT12
    what: Interrupt 12 owner
    location: [ ILL, 24..25 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT13
    what: Interrupt 13 owner
    location: [ ILL, 26..27 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT14
    what: Interrupt 14 owner
    location: [ ILL, 28..29 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT15
    what: Interrupt 15 owner
    location: [ ILL, 30..31 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT16
    what: Interrupt 16 owner
    location: [ ILL, 32..33 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT17
    what: Interrupt 17 owner
    location: [ ILL, 34..35 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT18
    what: Interrupt 18 owner
    location: [ ILL, 36..37 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT19
    what: Interrupt 19 owner
    location: [ ILL, 38..39 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT20
    what: Interrupt 20 owner
    location: [ ILL, 40..41 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT21
    what: Interrupt 21 owner
    location: [ ILL, 42..43 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT22
    what: Interrupt 22 owner
    location: [ ILL, 44..45 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT23
    what: Interrupt 23 owner
    location: [ ILL, 46..47 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT24
    what: Interrupt 24 owner
    location: [ ILL, 48..49 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT25
    what: Interrupt 25 owner
    location: [ ILL, 50..51 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT26
    what: Interrupt 26 owner
    location: [ ILL, 52..53 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT27
    what: Interrupt 27 owner
    location: [ ILL, 54..55 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT28
    what: Interrupt 28 owner
    location: [ ILL, 56..57 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT29
    what: Interrupt 29 owner
    location: [ ILL, 58..59 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT30
    what: Interrupt 30 owner
    location: [ ILL, 60..61 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT31
    what: Interrupt 31 owner
    location: [ ILL, 62..63 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ILR ################
  - ID: ILR_IT0
    what: Interrupt 0 owner
    location: [ ILR, 0 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT1
    what: Interrupt 1 owner
    location: [ ILR, 1 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT2
    what: Interrupt 2 owner
    location: [ ILR, 2 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT3
    what: Interrupt 3 owner
    location: [ ILR, 3 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT4
    what: Interrupt 4 owner
    location: [ ILR, 4 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT5
    what: Interrupt 5 owner
    location: [ ILR, 5 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT6
    what: Interrupt 6 owner
    location: [ ILR, 6 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT7
    what: Interrupt 7 owner
    location: [ ILR, 7 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT8
    what: Interrupt 8 owner
    location: [ ILR, 8 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT9
    what: Interrupt 9 owner
    location: [ ILR, 9 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT10
    what: Interrupt 10 owner
    location: [ ILR, 10 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT11
    what: Interrupt 11 owner
    location: [ ILR, 11 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT12
    what: Interrupt 12 owner
    location: [ ILR, 12 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT13
    what: Interrupt 13 owner
    location: [ ILR, 13 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT14
    what: Interrupt 14 owner
    location: [ ILR, 14 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT15
    what: Interrupt 15 owner
    location: [ ILR, 15 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT16
    what: Interrupt 16 owner
    location: [ ILR, 16 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT17
    what: Interrupt 17 owner
    location: [ ILR, 17 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT18
    what: Interrupt 18 owner
    location: [ ILR, 18 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT19
    what: Interrupt 19 owner
    location: [ ILR, 19 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT20
    what: Interrupt 20 owner
    location: [ ILR, 20 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT21
    what: Interrupt 21 owner
    location: [ ILR, 21 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT22
    what: Interrupt 22 owner
    location: [ ILR, 22 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT23
    what: Interrupt 23 owner
    location: [ ILR, 23 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT24
    what: Interrupt 24 owner
    location: [ ILR, 24 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT25
    what: Interrupt 25 owner
    location: [ ILR, 25 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT26
    what: Interrupt 26 owner
    location: [ ILR, 26 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT27
    what: Interrupt 27 owner
    location: [ ILR, 27 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT28
    what: Interrupt 28 owner
    location: [ ILR, 28 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT29
    what: Interrupt 29 owner
    location: [ ILR, 29 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT30
    what: Interrupt 30 owner
    location: [ ILR, 30 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT31
    what: Interrupt 31 owner
    location: [ ILR, 31 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ITOW ################
  - ID: ITOW_IT0
    what: Interrupt 0 owner
    location: [ ITO, 0..1 ]
    owners: [ ITO_IT0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT1
    what: Interrupt 1 owner
    location: [ ITO, 2..3 ]
    owners: [ ITO_IT1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT2
    what: Interrupt 2 owner
    location: [ ITO, 4..5 ]
    owners: [ ITO_IT2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT3
    what: Interrupt 3 owner
    location: [ ITO, 6..7 ]
    owners: [ ITO_IT3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT4
    what: Interrupt 4 owner
    location: [ ITO, 8..9 ]
    owners: [ ITO_IT4 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT5
    what: Interrupt 5 owner
    location: [ ITO, 10..11 ]
    owners: [ ITO_IT5 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT6
    what: Interrupt 6 owner
    location: [ ITO, 12..13 ]
    owners: [ ITO_IT6 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT7
    what: Interrupt 7 owner
    location: [ ITO, 14..15 ]
    owners: [ ITO_IT7 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT8
    what: Interrupt 8 owner
    location: [ ITO, 16..17 ]
    owners: [ ITO_IT8 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT9
    what: Interrupt 9 owner
    location: [ ITO, 18..19 ]
    owners: [ ITO_IT9 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT10
    what: Interrupt 10 owner
    location: [ ITO, 20..21 ]
    owners: [ ITO_IT10 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT11
    what: Interrupt 11 owner
    location: [ ITO, 22..23 ]
    owners: [ ITO_IT11 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT12
    what: Interrupt 12 owner
    location: [ ITO, 24..25 ]
    owners: [ ITO_IT12 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT13
    what: Interrupt 13 owner
    location: [ ITO, 26..27 ]
    owners: [ ITO_IT13 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT14
    what: Interrupt 14 owner
    location: [ ITO, 28..29 ]
    owners: [ ITO_IT14 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT15
    what: Interrupt 15 owner
    location: [ ITO, 30..31 ]
    owners: [ ITO_IT15 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT16
    what: Interrupt 16 owner
    location: [ ITO, 32..33 ]
    owners: [ ITO_IT16 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT17
    what: Interrupt 17 owner
    location: [ ITO, 34..35 ]
    owners: [ ITO_IT17 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT18
    what: Interrupt 18 owner
    location: [ ITO, 36..37 ]
    owners: [ ITO_IT18 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT19
    what: Interrupt 19 owner
    location: [ ITO, 38..39 ]
    owners: [ ITO_IT19 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT20
    what: Interrupt 20 owner
    location: [ ITO, 40..41 ]
    owners: [ ITO_IT20 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT21
    what: Interrupt 21 owner
    location: [ ITO, 42..43 ]
    owners: [ ITO_IT21 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT22
    what: Interrupt 22 owner
    location: [ ITO, 44..45 ]
    owners: [ ITO_IT22 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT23
    what: Interrupt 23 owner
    location: [ ITO, 46..47 ]
    owners: [ ITO_IT23 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT24
    what: Interrupt 24 owner
    location: [ ITO, 48..49 ]
    owners: [ ITO_IT24 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT25
    what: Interrupt 25 owner
    location: [ ITO, 50..51 ]
    owners: [ ITO_IT25 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT26
    what: Interrupt 26 owner
    location: [ ITO, 52..53 ]
    owners: [ ITO_IT26 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT27
    what: Interrupt 27 owner
    location: [ ITO, 54..55 ]
    owners: [ ITO_IT27 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT28
    what: Interrupt 28 owner
    location: [ ITO, 56..57 ]
    owners: [ ITO_IT28 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT29
    what: Interrupt 29 owner
    location: [ ITO, 58..59 ]
    owners: [ ITO_IT29 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT30
    what: Interrupt 30 owner
    location: [ ITO, 60..61 ]
    owners: [ ITO_IT30 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT31
    what: Interrupt 31 owner
    location: [ ITO, 62..63 ]
    owners: [ ITO_IT31 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
################ DO ################
  - ID: DO_B0
    what: Breakpoint 0 owner.
    location: [ DO, 0..1 ]
    reset: 0
  - ID: DO_B1
    what: Breakpoint 1 owner.
    location: [ DO, 2..3 ]
    reset: 0
  - ID: DO_W0
    what: Watchpoint 0 owner.
    location: [ DO, 4..5 ]
    reset: 0
  - ID: DO_W1
    what: Watchpoint 1 owner.
    location: [ DO, 6..7 ]
    reset: 0
  - ID: DO_B2
    what: Breakpoint 2 owner.
    location: [ DO, 8..9 ]
    reset: 0
  - ID: DO_B3
    what: Breakpoint 3 owner.
    location: [ DO, 10..11 ]
    reset: 0
  - ID: DO_W2
    what: Watchpoint 2 owner.
    location: [ DO, 12..13 ]
    reset: 0
  - ID: DO_W3
    what: Watchpoint 3 owner.
    location: [ DO, 14..15 ]
    reset: 0
  - ID: DO_BI0
    what: Breakpoint instruction 0 owner.
    location: [ DO, 16..17 ]
    reset: 0
  - ID: DO_BI1
    what: Breakpoint instruction 1 owner.
    location: [ DO, 18..19 ]
    reset: 0
  - ID: DO_BI2
    what: Breakpoint instruction 2 owner.
    location: [ DO, 20..21 ]
    reset: 0
  - ID: DO_BI3
    what: Breakpoint instruction 3 owner.
    location: [ DO, 22..23 ]
    reset: 0
################ DBA0 ################
  - ID: DBA0_DBA0
    what: Debug Breakpoint Address 0
    location: [ DBA0, 0..63 ]
    owners: [ DO_B0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA0
    reset: 0
################ DBA1 ################
  - ID: DBA1_DBA1
    what: Debug Breakpoint Address 1
    location: [ DBA1, 0..63 ]
    owners: [ DO_B1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA1
    reset: 0
################ DWA0 ################
  - ID: DWA0_DWA0
    what: Debug Breakpoint Address 0
    location: [ DWA0, 0..63 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA0
    reset: 0
################ DWA1 ################
  - ID: DWA1_DWA1
    what: Debug Breakpoint Address 1
    location: [ DWA1, 0..63 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA1
    reset: 0
################ DBA2 ################
  - ID: DBA2_DBA2
    what: Debug Breakpoint Address 2
    location: [ DBA2, 0..63 ]
    owners: [ DO_B2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA2
    reset: 0
################ DBA3 ################
  - ID: DBA3_DBA3
    what: Debug Breakpoint Address 3
    location: [ DBA3, 0..63 ]
    owners: [ DO_B3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA3
    reset: 0
################ DWA2 ################
  - ID: DWA2_DWA2
    what: Debug Breakpoint Address 2
    location: [ DWA2, 0..63 ]
    owners: [ DO_W2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA2
    reset: 0
################ DWA3 ################
  - ID: DWA3_DWA3
    what: Debug Breakpoint Address 3
    location: [ DWA3, 0..63 ]
    owners: [ DO_W3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA3
    reset: 0
################ DOW ################
  - ID: DOW_B0
    what: Breakpoint 0 owner.
    location: [ DO, 0..1 ]
    owners: [ DO_B0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_B1
    what: Breakpoint 1 owner.
    location: [ DO, 2..3 ]
    owners: [ DO_B1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W0
    what: Watchpoint 0 owner.
    location: [ DO, 4..5 ]
    owners: [ DO_W0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W1
    what: Watchpoint 1 owner.
    location: [ DO, 6..7 ]
    owners: [ DO_W1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_B2
    what: Breakpoint 2 owner.
    location: [ DO, 8..9 ]
    owners: [ DO_B2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_B3
    what: Breakpoint 3 owner.
    location: [ DO, 10..11 ]
    owners: [ DO_B3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W2
    what: Watchpoint 2 owner.
    location: [ DO, 12..13 ]
    owners: [ DO_W2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W3
    what: Watchpoint 3 owner.
    location: [ DO, 14..15 ]
    owners: [ DO_W3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_BI0
    what: Breakpoint instruction 0 owner.
    location: [ DO, 16..17 ]
    owners: [ DO_BI0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_BI1
    what: Breakpoint instruction 1 owner.
    location: [ DO, 18..19 ]
    owners: [ DO_BI1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_BI2
    what: Breakpoint instruction 2 owner.
    location: [ DO, 20..21 ]
    owners: [ DO_BI2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_BI3
    what: Breakpoint instruction 3 owner.
    location: [ DO, 22..23 ]
    owners: [ DO_BI3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
################ MO ################
  - ID: MO_MMI
    what: Memory Management Instructions owner.
    location: [ MO, 0..1 ]
    reset: 0
  - ID: MO_RFE
    what: RFE instruction owner.
    location: [ MO, 2..3 ]
    reset: 0
  - ID: MO_STOP
    what: STOP instruction owner.
    location: [ MO, 4..5 ]
    reset: 0
  - ID: MO_SYNC
    what: SYNCGROUP instruction owner.
    location: [ MO, 6..7 ]
    reset: 0
  - ID: MO_PCR
    what: PCR register owner.
    location: [ MO, 8..9 ]
    reset: 0
  - ID: MO_MSG
    what: MMU SFR GROUP registers owner.
    location: [ MO, 10..11 ]
    reset: 0
  - ID: MO_MEN
    what: Miscellaneous External Notifications register owner.
    location: [ MO, 12..13 ]
    reset: 0
  - ID: MO_MES
    what: Memory Error Status register owner.
    location: [ MO, 14..15 ]
    reset: 0
  - ID: MO_CSIT
    what: Compute Status Artithmetic Interrupt register owner.
    location: [ MO, 16..17 ]
    reset: 0
  - ID: MO_T0
    what: Timer 0 register group owner
    location: [ MO, 18..19 ]
    reset: 0
  - ID: MO_T1
    what: Timer 1 register group owner
    location: [ MO, 20..21 ]
    reset: 0
  - ID: MO_WD
    what: Watch Dog register group owner.
    location: [ MO, 22..23 ]
    reset: 0
  - ID: MO_PM0
    what: Performance Monitor 0 register owner.
    location: [ MO, 24..25 ]
    reset: 0
  - ID: MO_PM1
    what: Performance Monitor 1 register owner.
    location: [ MO, 26..27 ]
    reset: 0
  - ID: MO_PM2
    what: Performance Monitor 2 register owner.
    location: [ MO, 28..29 ]
    reset: 0
  - ID: MO_PM3
    what: Performance Monitor 3 register owner.
    location: [ MO, 30..31 ]
    reset: 0
  - ID: MO_PMIT
    what: Performance Monitor Interrupt register group owner.
    location: [ MO, 32..33 ]
    reset: 0
  - ID: MO_COMM
    what: SENDV and RECVV instruction owner.
    location: [ MO, 34..35 ]
    reset: 0
  - ID: MO_TPCM
    what: TPCM 0, 1, 2 & control register owner.
    location: [ MO, 36..37 ]
    reset: 0
  - ID: MO_DISW
    what: DINVALSW instruction owner.
    location: [ MO, 38..39 ]
    reset: 0
  - ID: MO_PM4
    what: Performance Monitor 4 register owner.
    location: [ MO, 40..41 ]
    reset: 0
  - ID: MO_PM5
    what: Performance Monitor 5 register owner.
    location: [ MO, 42..43 ]
    reset: 0
  - ID: MO_PM6
    what: Performance Monitor 6 register owner.
    location: [ MO, 44..45 ]
    reset: 0
  - ID: MO_PM7
    what: Performance Monitor 7 register owner.
    location: [ MO, 46..47 ]
    reset: 0
  - ID: MO_SRHPC
    what: SRHPC register owner.
    location: [ MO, 48..49 ]
    reset: 0
################ MOW ################
  - ID: MOW_MMI
    what: Memory Management Instructions owner.
    location: [ MO, 0..1 ]
    owners: [ MO_MMI ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_RFE
    what: RFE instruction owner.
    location: [ MO, 2..3 ]
    owners: [ MO_RFE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_STOP
    what: STOP instruction owner.
    location: [ MO, 4..5 ]
    owners: [ MO_STOP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_SYNC
    what: SYNCGROUP instruction owner.
    location: [ MO, 6..7 ]
    owners: [ MO_SYNC ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PCR
    what: PCR register owner.
    location: [ MO, 8..9 ]
    owners: [ MO_PCR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MSG
    what: MMU SFR GROUP registers owner.
    location: [ MO, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MEN
    what: Miscellaneous External Notifications register owner.
    location: [ MO, 12..13 ]
    owners: [ MO_MEN ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MES
    what: Memory Error Status register owner.
    location: [ MO, 14..15 ]
    owners: [ MO_MES ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_CSIT
    what: Compute Status Artithmetic Interrupt register owner.
    location: [ MO, 16..17 ]
    owners: [ MO_CSIT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_T0
    what: Timer 0 register group owner
    location: [ MO, 18..19 ]
    owners: [ MO_T0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_T1
    what: Timer 1 register group owner
    location: [ MO, 20..21 ]
    owners: [ MO_T1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_WD
    what: Watch Dog register group owner.
    location: [ MO, 22..23 ]
    owners: [ MO_WD ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM0
    what: Performance Monitor 0 register owner.
    location: [ MO, 24..25 ]
    owners: [ MO_PM0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM1
    what: Performance Monitor 1 register owner.
    location: [ MO, 26..27 ]
    owners: [ MO_PM1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM2
    what: Performance Monitor 2 register owner.
    location: [ MO, 28..29 ]
    owners: [ MO_PM2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM3
    what: Performance Monitor 3 register owner.
    location: [ MO, 30..31 ]
    owners: [ MO_PM3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PMIT
    what: Performance Monitor Interrupt register group owner.
    location: [ MO, 32..33 ]
    owners: [ MO_PMIT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_COMM
    what: SENDV and RECVV instruction owner.
    location: [ MO, 34..35 ]
    owners: [ MO_COMM ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_TPCM
    what: TPCM 0, 1, 2 & control register owner.
    location: [ MO, 36..37 ]
    owners: [ MO_TPCM ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_DISW
    what: DINVALSW instruction owner.
    location: [ MO, 38..39 ]
    owners: [ MO_DISW ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM4
    what: Performance Monitor 4 register owner.
    location: [ MO, 40..41 ]
    owners: [ MO_PM4 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM5
    what: Performance Monitor 5 register owner.
    location: [ MO, 42..43 ]
    owners: [ MO_PM5 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM6
    what: Performance Monitor 6 register owner.
    location: [ MO, 44..45 ]
    owners: [ MO_PM6 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM7
    what: Performance Monitor 7 register owner.
    location: [ MO, 46..47 ]
    owners: [ MO_PM7 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_SRHPC
    what: SRHPC register owner.
    location: [ MO, 48..49 ]
    owners: [ MO_SRHPC ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
################ PS ################
  - ID: PS_PL
    what: Current Privilege Level
    location: [ PS, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_ET
    what: Exception Taken
    location: [ PS, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
  - ID: PS_HTD
    what: Hardware Trap Disable
    location: [ PS, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_IE
    what: Interrupt Enable
    location: [ PS, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_HLE
    what: Hardware Loop Enable
    location: [ PS, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SRE
    what: Software REserved
    location: [ PS, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_DAUS
    what: Data Accesses Use SPS settings
    location: [ PS, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_ICE
    what: Instruction Cache Enable
    location: [ PS, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_USE
    what: Uncached Streaming Enable
    location: [ PS, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_DCE
    what: Data Cache Enable
    location: [ PS, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_MME
    what: Memory Management Enable
    location: [ PS, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_IL
    what: Interrupt Level
    location: [ PS, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_VS
    what: Virtual Space
    location: [ PS, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_V64
    what: Virtual 64 bits mode.
    location: [ PS, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_L2E
    what: L2 cache Enable.
    location: [ PS, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SME
    what: Step Mode Enabled
    location: [ PS, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SMR
    what: Step Mode Ready
    location: [ PS, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_PMJ
    what: Page Mask in JTLB.
    location: [ PS, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: PS_MMUP
    what: Privileged on MMU.
    location: [ PS, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x1
################ SPS ################
  - ID: SPS_PL
    what: Current Privilege Level
    location: [ SPS, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_ET
    what: Exception Taken
    location: [ SPS, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_HTD
    what: Hardware Trap Disable
    location: [ SPS, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_IE
    what: Interrupt Enable
    location: [ SPS, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_HLE
    what: Hardware Loop Enable
    location: [ SPS, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SRE
    what: Software REserved
    location: [ SPS, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_ICE
    what: Instruction Cache Enable
    location: [ SPS, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_USE
    what: Uncached Streaming Enable
    location: [ SPS, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_DCE
    what: Data Cache Enable
    location: [ SPS, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_MME
    what: Memory Management Enable
    location: [ SPS, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_IL
    what: Interrupt Level
    location: [ SPS, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_VS
    what: Virtual Space
    location: [ SPS, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_V64
    what: Virtual 64 bits mode.
    location: [ SPS, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_L2E
    what: L2 cache Enable.
    location: [ SPS, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SME
    what: Step Mode Enabled
    location: [ SPS, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SMR
    what: Step Mode Ready
    location: [ SPS, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PMJ
    what: Page Mask in JTLB.
    location: [ SPS, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_MMUP
    what: Privileged on MMU.
    location: [ SPS, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL0 ################
  - ID: SPS_PL0_PL
    what: Current Privilege Level
    location: [ SPS_PL0, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_ET
    what: Exception Taken
    location: [ SPS_PL0, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL0, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_IE
    what: Interrupt Enable
    location: [ SPS_PL0, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL0, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SRE
    what: Software REserved
    location: [ SPS_PL0, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL0, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL0, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL0, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_DCE
    what: Data Cache Enable
    location: [ SPS_PL0, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_MME
    what: Memory Management Enable
    location: [ SPS_PL0, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_IL
    what: Interrupt Level
    location: [ SPS_PL0, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_VS
    what: Virtual Space
    location: [ SPS_PL0, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL0, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_L2E
    what: L2 cache Enable.
    location: [ SPS_PL0, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SME
    what: Step Mode Enabled
    location: [ SPS_PL0, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SMR
    what: Step Mode Ready
    location: [ SPS_PL0, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL0, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL0_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL0, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL1 ################
  - ID: SPS_PL1_PL
    what: Current Privilege Level
    location: [ SPS_PL1, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_ET
    what: Exception Taken
    location: [ SPS_PL1, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL1, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_IE
    what: Interrupt Enable
    location: [ SPS_PL1, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL1, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SRE
    what: Software REserved
    location: [ SPS_PL1, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL1, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL1, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL1, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_DCE
    what: Data Cache Enable
    location: [ SPS_PL1, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_MME
    what: Memory Management Enable
    location: [ SPS_PL1, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_IL
    what: Interrupt Level
    location: [ SPS_PL1, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_VS
    what: Virtual Space
    location: [ SPS_PL1, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL1, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_L2E
    what: L2 cache Enable.
    location: [ SPS_PL1, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SME
    what: Step Mode Enabled
    location: [ SPS_PL1, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SMR
    what: Step Mode Ready
    location: [ SPS_PL1, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL1, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL1_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL1, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL2 ################
  - ID: SPS_PL2_PL
    what: Current Privilege Level
    location: [ SPS_PL2, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_ET
    what: Exception Taken
    location: [ SPS_PL2, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL2, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_IE
    what: Interrupt Enable
    location: [ SPS_PL2, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL2, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SRE
    what: Software REserved
    location: [ SPS_PL2, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL2, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL2, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL2, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_DCE
    what: Data Cache Enable
    location: [ SPS_PL2, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_MME
    what: Memory Management Enable
    location: [ SPS_PL2, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_IL
    what: Interrupt Level
    location: [ SPS_PL2, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_VS
    what: Virtual Space
    location: [ SPS_PL2, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL2, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_L2E
    what: L2 cache Enable.
    location: [ SPS_PL2, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SME
    what: Step Mode Enabled
    location: [ SPS_PL2, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SMR
    what: Step Mode Ready
    location: [ SPS_PL2, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL2, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL2_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL2, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL3 ################
  - ID: SPS_PL3_PL
    what: Current Privilege Level
    location: [ SPS_PL3, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_ET
    what: Exception Taken
    location: [ SPS_PL3, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL3, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_IE
    what: Interrupt Enable
    location: [ SPS_PL3, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL3, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SRE
    what: Software REserved
    location: [ SPS_PL3, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL3, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL3, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL3, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_DCE
    what: Data Cache Enable
    location: [ SPS_PL3, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_MME
    what: Memory Management Enable
    location: [ SPS_PL3, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_IL
    what: Interrupt Level
    location: [ SPS_PL3, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_VS
    what: Virtual Space
    location: [ SPS_PL3, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL3, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_L2E
    what: L2 cache Enable.
    location: [ SPS_PL3, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SME
    what: Step Mode Enabled
    location: [ SPS_PL3, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SMR
    what: Step Mode Ready
    location: [ SPS_PL3, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL3, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL3_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL3, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ PSO ################
  - ID: PSO_PL0
    what: Current Privilege Level bit 0 owner
    location: [ PSO, 0..1 ]
    reset: 0
  - ID: PSO_PL1
    what: Current Privilege Level bit 1 owner
    location: [ PSO, 2..3 ]
    reset: 0
  - ID: PSO_ET
    what: Exception Taken owner
    location: [ PSO, 4..5 ]
    reset: 0
  - ID: PSO_HTD
    what: Hardware Trap Disable owner
    location: [ PSO, 6..7 ]
    reset: 0
  - ID: PSO_IE
    what: Interrupt Enable owner
    location: [ PSO, 8..9 ]
    reset: 0
  - ID: PSO_HLE
    what: Hardware Loop Enable owner
    location: [ PSO, 10..11 ]
    reset: 0
  - ID: PSO_SRE
    what: Software REserved owner
    location: [ PSO, 12..13 ]
    reset: 0
  - ID: PSO_DAUS
    what: Data Accesses Use SPS settings owner
    location: [ PSO, 14..15 ]
    reset: 0
  - ID: PSO_ICE
    what: Instruction Cache Enable owner
    location: [ PSO, 16..17 ]
    reset: 0
  - ID: PSO_USE
    what: Uncached Streaming Enable owner
    location: [ PSO, 18..19 ]
    reset: 0
  - ID: PSO_DCE
    what: Data Cache Enable owner
    location: [ PSO, 20..21 ]
    reset: 0
  - ID: PSO_MME
    what: Memory Management Enable owner
    location: [ PSO, 22..23 ]
    reset: 0
  - ID: PSO_IL0
    what: Interrupt Level bit 0 owner
    location: [ PSO, 24..25 ]
    reset: 0
  - ID: PSO_IL1
    what: Interrupt Level bit 1 owner
    location: [ PSO, 26..27 ]
    reset: 0
  - ID: PSO_VS0
    what: Virtual Space bit 0 owner
    location: [ PSO, 28..29 ]
    reset: 0
  - ID: PSO_VS1
    what: Virtual Space bit 1 owner
    location: [ PSO, 30..31 ]
    reset: 0
  - ID: PSO_V64
    what: Virtual 64 bits mode owner
    location: [ PSO, 32..33 ]
    reset: 0
  - ID: PSO_L2E
    what: L2 cache Enable owner
    location: [ PSO, 34..35 ]
    reset: 0
  - ID: PSO_SME
    what: Step Mode Enabled owner
    location: [ PSO, 36..37 ]
    reset: 0
  - ID: PSO_SMR
    what: Step Mode Ready owner
    location: [ PSO, 38..39 ]
    reset: 0
  - ID: PSO_PMJ0
    what: Page Mask in JTLB bit 0 owner
    location: [ PSO, 40..41 ]
    reset: 0
  - ID: PSO_PMJ1
    what: Page Mask in JTLB bit 1 owner
    location: [ PSO, 42..43 ]
    reset: 0
  - ID: PSO_PMJ2
    what: Page Mask in JTLB bit 2 owner
    location: [ PSO, 44..45 ]
    reset: 0
  - ID: PSO_PMJ3
    what: Page Mask in JTLB bit 3 owner
    location: [ PSO, 46..47 ]
    reset: 0
  - ID: PSO_MMUP
    what: Privileged on MMU owner.
    location: [ PSO, 48..49 ]
    reset: 0
################ PSOW ################
  - ID: PSOW_PL0
    what: Current Privilege Level bit 0 owner
    location: [ PSO, 0..1 ]
    owners: [ PSO_PL0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PL1
    what: Current Privilege Level bit 1 owner
    location: [ PSO, 2..3 ]
    owners: [ PSO_PL1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_ET
    what: Exception Taken owner
    location: [ PSO, 4..5 ]
    owners: [ PSO_ET ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_HTD
    what: Hardware Trap Disable owner
    location: [ PSO, 6..7 ]
    owners: [ PSO_HTD ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IE
    what: Interrupt Enable owner
    location: [ PSO, 8..9 ]
    owners: [ PSO_IE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_HLE
    what: Hardware Loop Enable owner
    location: [ PSO, 10..11 ]
    owners: [ PSO_HLE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SRE
    what: Software REserved owner
    location: [ PSO, 12..13 ]
    owners: [ PSO_SRE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_DAUS
    what: Data Accesses Use SPS settings owner
    location: [ PSO, 14..15 ]
    owners: [ PSO_DAUS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_ICE
    what: Instruction Cache Enable owner
    location: [ PSO, 16..17 ]
    owners: [ PSO_ICE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_USE
    what: Uncached Streaming Enable owner
    location: [ PSO, 18..19 ]
    owners: [ PSO_USE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_DCE
    what: Data Cache Enable owner
    location: [ PSO, 20..21 ]
    owners: [ PSO_DCE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_MME
    what: Memory Management Enable owner
    location: [ PSO, 22..23 ]
    owners: [ PSO_MME ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IL0
    what: Interrupt Level bit 0 owner
    location: [ PSO, 24..25 ]
    owners: [ PSO_IL0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IL1
    what: Interrupt Level bit 1 owner
    location: [ PSO, 26..27 ]
    owners: [ PSO_IL1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_VS0
    what: Virtual Space bit 0 owner
    location: [ PSO, 28..29 ]
    owners: [ PSO_VS0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_VS1
    what: Virtual Space bit 1 owner
    location: [ PSO, 30..31 ]
    owners: [ PSO_VS1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_V64
    what: Virtual 64 bits mode owner
    location: [ PSO, 32..33 ]
    owners: [ PSO_V64 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_L2E
    what: L2 cache Enable owner
    location: [ PSO, 34..35 ]
    owners: [ PSO_L2E ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SME
    what: Step Mode Enabled owner
    location: [ PSO, 36..37 ]
    owners: [ PSO_SME ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SMR
    what: Step Mode Ready owner
    location: [ PSO, 38..39 ]
    owners: [ PSO_SMR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ0
    what: Page Mask in JTLB bit 0 owner
    location: [ PSO, 40..41 ]
    owners: [ PSO_PMJ0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ1
    what: Page Mask in JTLB bit 1 owner
    location: [ PSO, 42..43 ]
    owners: [ PSO_PMJ1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ2
    what: Page Mask in JTLB bit 2 owner
    location: [ PSO, 44..45 ]
    owners: [ PSO_PMJ2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ3
    what: Page Mask in JTLB bit 3 owner
    location: [ PSO, 46..47 ]
    owners: [ PSO_PMJ3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_MMUP
    what: Privileged on MMU owner.
    location: [ PSO, 48..49 ]
    owners: [ PSO_MMUP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
################ CS ################
  - ID: CS_IC
    what: Integer Carry
    location: [ CS, 0 ]
    reset: 0
  - ID: CS_IO
    what: IEEE 754 Invalid Operation
    location: [ CS, 1 ]
    reset: 0
  - ID: CS_DZ
    what: IEEE 754 Divide by Zero
    location: [ CS, 2 ]
    reset: 0
  - ID: CS_OV
    what: IEEE 754 Overflow
    location: [ CS, 3 ]
    reset: 0
  - ID: CS_UN
    what: IEEE 754 Underflow
    location: [ CS, 4 ]
    reset: 0
  - ID: CS_IN
    what: IEEE 754 Inexact
    location: [ CS, 5 ]
    reset: 0
  - ID: CS_XIO
    what: Extension IEEE 754 Invalid Operation
    location: [ CS, 9 ]
    reset: 0
  - ID: CS_XDZ
    what: Extension IEEE 754 Divide by Zero
    location: [ CS, 10 ]
    reset: 0
  - ID: CS_XOV
    what: Extension IEEE 754 Overflow
    location: [ CS, 11 ]
    reset: 0
  - ID: CS_XUN
    what: Extension IEEE 754 Underflow
    location: [ CS, 12 ]
    reset: 0
  - ID: CS_XIN
    what: Extension IEEE 754 Inexact
    location: [ CS, 13 ]
    reset: 0
  - ID: CS_RM
    what: IEEE 754 Rounding Mode
    location: [ CS, 16..17 ]
    reset: 0
  - ID: CS_XRM
    what: Extension IEEE 754 Rounding Mode
    location: [ CS, 20..21 ]
    reset: 0
  - ID: CS_XMF
    what: eXtension ModiFied
    location: [ CS, 24 ]
    reset: 0
  - ID: CS_CC
    what: Carry Counter
    location: [ CS, 32..47 ]
    reset: 0
################ AESPC ################
  - ID: AESPC_AESPC
    what: Arithmetic Exception Saved PC
    location: [ AESPC, 0..63 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: AESPC
    reset: 0
################ CSIT ################
  - ID: CSIT_ICIE
    what: Integer Carry Interrupt Enable
    location: [ CSIT, 0 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_IOIE
    what: IEEE 754 Invalid Operation Interrupt Enable
    location: [ CSIT, 1 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_DZIE
    what: IEEE 754 Divide by Zero Interrupt Enable
    location: [ CSIT, 2 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_OVIE
    what: IEEE 754 Overflow Interrupt Enable
    location: [ CSIT, 3 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_UNIE
    what: IEEE 754 Underflow Interrupt Enable
    location: [ CSIT, 4 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_INIE
    what: IEEE 754 Inexact Interrupt Enable
    location: [ CSIT, 5 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XIOIE
    what: Extension IEEE 754 Invalid Operation Interrupt Enable
    location: [ CSIT, 9 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XDZIE
    what: Extension IEEE 754 Divide by Zero Interrupt Enable
    location: [ CSIT, 10 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XOVIE
    what: Extension IEEE 754 Overflow Interrupt Enable
    location: [ CSIT, 11 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XUNIE
    what: Extension IEEE 754 Underflow Interrupt Enable
    location: [ CSIT, 12 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XINIE
    what: Extension IEEE 754 Inexact Interrupt Enable
    location: [ CSIT, 13 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_AEIR
    what: Arithmetic Exception Interrupt Raised
    location: [ CSIT, 16 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_AEC
    what: Arithmetic Exception Code
    location: [ CSIT, 17..19 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_SPCV
    what: SPC Valid
    location: [ CSIT, 20 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ES ################
## Those are common to all ECs
  - ID: ES_EC
    what: Exception Class
    location: [ ES, 0..3 ]
    reset: 4
  - ID: ES_ED
    what: Exception Details
    location: [ ES, 4..63 ]
    reset: 0
  - ID: ES_OAPL
    what: Origin Absolute PL
    location: [ ES, 4..5 ]
    reset: 0
  - ID: ES_ORPL
    what: Origin Relative PL
    location: [ ES, 6..7 ]
    reset: 0
  - ID: ES_PTAPL
    what: Primary Target Absolute PL
    location: [ ES, 8..9 ]
    reset: 0
  - ID: ES_PTRPL
    what: Primary Target Relative PL
    location: [ ES, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_ITN
    what: InTerrupt Number
    location: [ ES, 12..16 ]
    reset: 0
  - ID: ES_ITL
    what: InTerrupt Level
    location: [ ES, 17..18 ]
    reset: 0
  - ID: ES_ITI
    what: InTerrupt Info
    location: [ ES, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_SN
    what: Syscall Number
    location: [ ES, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_HTC
    what: Hardware Trap Cause
    location: [ ES, 12..16 ]
    reset: 0
  - ID: ES_SFRT
    what: SFR Trap
    location: [ ES, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_SFRI
    what: SFR Instruction
    location: [ ES, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_GPRP
    what: GPR Pointer
    location: [ ES, 21..26 ]
    reset: 0
  - ID: ES_SFRP
    what: SFR Pointer
    location: [ ES, 27..35 ]
    reset: 0
  - ID: ES_DHT
    what: Disabled Hardware Trap
    location: [ ES, 36 ]
    reset: 0
  - ID: ES_DRX
    what: Data Register eXtension
    location: [ ES, 37 ]
    reset: 0
  - ID: ES_DAF
    what: Data Access Format
    location: [ ES, 38 ]
    reset: 0
  - ID: ES_RWX
    what: Read Write Execute
    location: [ ES, 39..41 ]
    reset: 0
  - ID: ES_NTA
    what: Non-Trapping Access
    location: [ ES, 42 ]
    reset: 0
  - ID: ES_UCA
    what: Un-Cached Access
    location: [ ES, 43 ]
    reset: 0
  - ID: ES_AS
    what: Access Size
    location: [ ES, 44..49 ]
    reset: 0
  - ID: ES_BS
    what: Bundle Size
    location: [ ES, 50..53 ]
    reset: 0
  - ID: ES_DRI
    what: Data Register Index
    location: [ ES, 54..59 ]
    reset: 0
  - ID: ES_PIC
    what: Privileged Instruction Code
    location: [ ES, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_DCV2
    what: Debug Cause
    location: [ ES, 12..14 ]
    reset: 0
  - ID: ES_WBN
    what: Watchpoint/Breakpoint Number
    location: [ ES, 15..16 ]
    reset: 0
## common with hwtraps => described only once
## - ID: ES_SFRI
## what: SFR Instruction
## location: [ ES, 18..20 ]
## reset: 0
## description: >
## Encoding of the SFR access instruction
## - ID: ES_GPRP
## what: GPR Pointer
## location: [ ES, 21..26 ]
## reset: 0
## - ID: ES_SFRP
## what: SFR Pointer
## location: [ ES, 27..35 ]
## reset: 0
## - ID: ES_DHT
## what: Disabled Hardware Trap
## location: [ ES, 36 ]
## reset: 0
## - ID: ES_RWX
## what: Read Write Execute
## location: [ ES, 39..41 ]
## reset: 0
## - ID: ES_NTA
## what: Non-Trapping Access
## location: [ ES, 42 ]
## reset: 0
## - ID: ES_UCA
## what: Un-Cached Access
## location: [ ES, 43 ]
## reset: 0
## - ID: ES_AS
## what: Access Size
## location: [ ES, 44..49 ]
## reset: 0
## - ID: ES_BS
## what: Bundle Size
## location: [ ES, 50..53 ]
## reset: 0
## - ID: ES_DRI
## what: Data Register Index
## location: [ ES, 54..59 ]
## reset: 0
## - ID: ES_PIC
## what: Privileged Instruction Code
## location: [ ES, 60..63 ]
## reset: 0
################ ES_PL0 ################
## Those are common to all ECs
  - ID: ES_PL0_EC
    what: Exception Class
    location: [ ES_PL0, 0..3 ]
    reset: 4
  - ID: ES_PL0_ED
    what: Exception Details
    location: [ ES_PL0, 4..63 ]
    reset: 0
  - ID: ES_PL0_OAPL
    what: Origin Absolute PL
    location: [ ES_PL0, 4..5 ]
    reset: 0
  - ID: ES_PL0_ORPL
    what: Origin Relative PL
    location: [ ES_PL0, 6..7 ]
    reset: 0
  - ID: ES_PL0_PTAPL
    what: Target Absolute PL
    location: [ ES_PL0, 8..9 ]
    reset: 0
  - ID: ES_PL0_PTRPL
    what: Target Relative PL
    location: [ ES_PL0, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL0_ITN
    what: InTerrupt Number
    location: [ ES_PL0, 12..16 ]
    reset: 0
  - ID: ES_PL0_ITL
    what: InTerrupt Level
    location: [ ES_PL0, 17..18 ]
    reset: 0
  - ID: ES_PL0_ITI
    what: InTerrupt Info
    location: [ ES_PL0, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL0_SN
    what: Syscall Number
    location: [ ES_PL0, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL0_HTC
    what: Hardware Trap Cause
    location: [ ES_PL0, 12..16 ]
    reset: 0
  - ID: ES_PL0_SFRT
    what: SFR Trap
    location: [ ES_PL0, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL0_SFRI
    what: SFR Instruction
    location: [ ES_PL0, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL0_GPRP
    what: GPR Pointer
    location: [ ES_PL0, 21..26 ]
    reset: 0
  - ID: ES_PL0_SFRP
    what: SFR Pointer
    location: [ ES_PL0, 27..35 ]
    reset: 0
  - ID: ES_PL0_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL0, 36 ]
    reset: 0
  - ID: ES_PL0_DRX
    what: Data Register from eXtension
    location: [ ES_PL0, 37 ]
    reset: 0
  - ID: ES_PL0_DAF
    what: Data Access Format
    location: [ ES_PL0, 38 ]
    reset: 0
  - ID: ES_PL0_RWX
    what: Read Write Execute
    location: [ ES_PL0, 39..41 ]
    reset: 0
  - ID: ES_PL0_NTA
    what: Non-Trapping Access
    location: [ ES_PL0, 42 ]
    reset: 0
  - ID: ES_PL0_UCA
    what: Un-Cached Access
    location: [ ES_PL0, 43 ]
    reset: 0
  - ID: ES_PL0_AS
    what: Access Size
    location: [ ES_PL0, 44..49 ]
    reset: 0
  - ID: ES_PL0_BS
    what: Bundle Size
    location: [ ES_PL0, 50..53 ]
    reset: 0
  - ID: ES_PL0_DRI
    what: Data Register Index
    location: [ ES_PL0, 54..59 ]
    reset: 0
  - ID: ES_PL0_PIC
    what: Privileged Instruction Code
    location: [ ES_PL0, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL0_DCV2
    what: Debug Cause
    location: [ ES_PL0, 12..14 ]
    reset: 0
  - ID: ES_PL0_WBN
    what: Watchpoint/Breakpoint Number
    location: [ ES_PL0, 15..16 ]
    reset: 0
################ ES_PL1 ################
## Those are common to all ECs
  - ID: ES_PL1_EC
    what: Exception Class
    location: [ ES_PL1, 0..3 ]
    reset: 4
  - ID: ES_PL1_ED
    what: Exception Details
    location: [ ES_PL1, 4..63 ]
    reset: 0
  - ID: ES_PL1_OAPL
    what: Origin Absolute PL
    location: [ ES_PL1, 4..5 ]
    reset: 0
  - ID: ES_PL1_ORPL
    what: Origin Relative PL
    location: [ ES_PL1, 6..7 ]
    reset: 0
  - ID: ES_PL1_PTAPL
    what: Target Absolute PL
    location: [ ES_PL1, 8..9 ]
    reset: 0
  - ID: ES_PL1_PTRPL
    what: Target Relative PL
    location: [ ES_PL1, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL1_ITN
    what: InTerrupt Number
    location: [ ES_PL1, 12..16 ]
    reset: 0
  - ID: ES_PL1_ITL
    what: InTerrupt Level
    location: [ ES_PL1, 17..18 ]
    reset: 0
  - ID: ES_PL1_ITI
    what: InTerrupt Info
    location: [ ES_PL1, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL1_SN
    what: Syscall Number
    location: [ ES_PL1, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL1_HTC
    what: Hardware Trap Cause
    location: [ ES_PL1, 12..16 ]
    reset: 0
  - ID: ES_PL1_SFRT
    what: SFR Trap
    location: [ ES_PL1, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL1_SFRI
    what: SFR Instruction
    location: [ ES_PL1, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL1_GPRP
    what: GPR Pointer
    location: [ ES_PL1, 21..26 ]
    reset: 0
  - ID: ES_PL1_SFRP
    what: SFR Pointer
    location: [ ES_PL1, 27..35 ]
    reset: 0
  - ID: ES_PL1_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL1, 36 ]
    reset: 0
  - ID: ES_PL1_DRX
    what: Data Register from eXtension
    location: [ ES_PL1, 37 ]
    reset: 0
  - ID: ES_PL1_DAF
    what: Data Access Format
    location: [ ES_PL1, 38 ]
    reset: 0
  - ID: ES_PL1_RWX
    what: Read Write Execute
    location: [ ES_PL1, 39..41 ]
    reset: 0
  - ID: ES_PL1_NTA
    what: Non-Trapping Access
    location: [ ES_PL1, 42 ]
    reset: 0
  - ID: ES_PL1_UCA
    what: Un-Cached Access
    location: [ ES_PL1, 43 ]
    reset: 0
  - ID: ES_PL1_AS
    what: Access Size
    location: [ ES_PL1, 44..49 ]
    reset: 0
  - ID: ES_PL1_BS
    what: Bundle Size
    location: [ ES_PL1, 50..53 ]
    reset: 0
  - ID: ES_PL1_DRI
    what: Data Register Index
    location: [ ES_PL1, 54..59 ]
    reset: 0
  - ID: ES_PL1_PIC
    what: Privileged Instruction Code
    location: [ ES_PL1, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL1_DCV2
    what: Debug Cause
    location: [ ES_PL1, 12..14 ]
    reset: 0
  - ID: ES_PL1_WBN
    what: Watchpoint/Breakpoint Number
    location: [ ES_PL1, 15..16 ]
    reset: 0
################ ES_PL2 ################
## Those are common to all ECs
  - ID: ES_PL2_EC
    what: Exception Class
    location: [ ES_PL2, 0..3 ]
    reset: 4
  - ID: ES_PL2_ED
    what: Exception Details
    location: [ ES_PL2, 4..63 ]
    reset: 0
  - ID: ES_PL2_OAPL
    what: Origin Absolute PL
    location: [ ES_PL2, 4..5 ]
    reset: 0
  - ID: ES_PL2_ORPL
    what: Origin Relative PL
    location: [ ES_PL2, 6..7 ]
    reset: 0
  - ID: ES_PL2_PTAPL
    what: Target Absolute PL
    location: [ ES_PL2, 8..9 ]
    reset: 0
  - ID: ES_PL2_PTRPL
    what: Target Relative PL
    location: [ ES_PL2, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL2_ITN
    what: InTerrupt Number
    location: [ ES_PL2, 12..16 ]
    reset: 0
  - ID: ES_PL2_ITL
    what: InTerrupt Level
    location: [ ES_PL2, 17..18 ]
    reset: 0
  - ID: ES_PL2_ITI
    what: InTerrupt Info
    location: [ ES_PL2, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL2_SN
    what: Syscall Number
    location: [ ES_PL2, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL2_HTC
    what: Hardware Trap Cause
    location: [ ES_PL2, 12..16 ]
    reset: 0
  - ID: ES_PL2_SFRT
    what: SFR Trap
    location: [ ES_PL2, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL2_SFRI
    what: SFR Instruction
    location: [ ES_PL2, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL2_GPRP
    what: GPR Pointer
    location: [ ES_PL2, 21..26 ]
    reset: 0
  - ID: ES_PL2_SFRP
    what: SFR Pointer
    location: [ ES_PL2, 27..35 ]
    reset: 0
  - ID: ES_PL2_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL2, 36 ]
    reset: 0
  - ID: ES_PL2_DRX
    what: Data Register from eXtension
    location: [ ES_PL2, 37 ]
    reset: 0
  - ID: ES_PL2_DAF
    what: Data Access Format
    location: [ ES_PL2, 38 ]
    reset: 0
  - ID: ES_PL2_RWX
    what: Read Write Execute
    location: [ ES_PL2, 39..41 ]
    reset: 0
  - ID: ES_PL2_NTA
    what: Non-Trapping Access
    location: [ ES_PL2, 42 ]
    reset: 0
  - ID: ES_PL2_UCA
    what: Un-Cached Access
    location: [ ES_PL2, 43 ]
    reset: 0
  - ID: ES_PL2_AS
    what: Access Size
    location: [ ES_PL2, 44..49 ]
    reset: 0
  - ID: ES_PL2_BS
    what: Bundle Size
    location: [ ES_PL2, 50..53 ]
    reset: 0
  - ID: ES_PL2_DRI
    what: Data Register Index
    location: [ ES_PL2, 54..59 ]
    reset: 0
  - ID: ES_PL2_PIC
    what: Privileged Instruction Code
    location: [ ES_PL2, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL2_DCV2
    what: Debug Cause
    location: [ ES_PL2, 12..14 ]
    reset: 0
  - ID: ES_PL2_WBN
    what: Watchpoint/Breakpoint Number
    location: [ ES_PL2, 15..16 ]
    reset: 0
################ ES_PL3 ################
## Those are common to all ECs
  - ID: ES_PL3_EC
    what: Exception Class
    location: [ ES_PL3, 0..3 ]
    reset: 4
  - ID: ES_PL3_ED
    what: Exception Details
    location: [ ES_PL3, 4..63 ]
    reset: 0
  - ID: ES_PL3_OAPL
    what: Origin Absolute PL
    location: [ ES_PL3, 4..5 ]
    reset: 0
  - ID: ES_PL3_ORPL
    what: Origin Relative PL
    location: [ ES_PL3, 6..7 ]
    reset: 0
  - ID: ES_PL3_PTAPL
    what: Target Absolute PL
    location: [ ES_PL3, 8..9 ]
    reset: 0
  - ID: ES_PL3_PTRPL
    what: Target Relative PL
    location: [ ES_PL3, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL3_ITN
    what: InTerrupt Number
    location: [ ES_PL3, 12..16 ]
    reset: 0
  - ID: ES_PL3_ITL
    what: InTerrupt Level
    location: [ ES_PL3, 17..18 ]
    reset: 0
  - ID: ES_PL3_ITI
    what: InTerrupt Info
    location: [ ES_PL3, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL3_SN
    what: Syscall Number
    location: [ ES_PL3, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL3_HTC
    what: Hardware Trap Cause
    location: [ ES_PL3, 12..16 ]
    reset: 0
  - ID: ES_PL3_SFRT
    what: SFR Trap
    location: [ ES_PL3, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL3_SFRI
    what: SFR Instruction
    location: [ ES_PL3, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL3_GPRP
    what: GPR Pointer
    location: [ ES_PL3, 21..26 ]
    reset: 0
  - ID: ES_PL3_SFRP
    what: SFR Pointer
    location: [ ES_PL3, 27..35 ]
    reset: 0
  - ID: ES_PL3_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL3, 36 ]
    reset: 0
  - ID: ES_PL3_DRX
    what: Data Register from eXtension
    location: [ ES_PL3, 37 ]
    reset: 0
  - ID: ES_PL3_DAF
    what: Data Access Format
    location: [ ES_PL3, 38 ]
    reset: 0
  - ID: ES_PL3_RWX
    what: Read Write Execute
    location: [ ES_PL3, 39..41 ]
    reset: 0
  - ID: ES_PL3_NTA
    what: Non-Trapping Access
    location: [ ES_PL3, 42 ]
    reset: 0
  - ID: ES_PL3_UCA
    what: Un-Cached Access
    location: [ ES_PL3, 43 ]
    reset: 0
  - ID: ES_PL3_AS
    what: Access Size
    location: [ ES_PL3, 44..49 ]
    reset: 0
  - ID: ES_PL3_BS
    what: Bundle Size
    location: [ ES_PL3, 50..53 ]
    reset: 0
  - ID: ES_PL3_DRI
    what: Data Register Index
    location: [ ES_PL3, 54..59 ]
    reset: 0
  - ID: ES_PL3_PIC
    what: Privileged Instruction Code
    location: [ ES_PL3, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL3_DCV2
    what: Debug Cause
    location: [ ES_PL3, 12..14 ]
    reset: 0
  - ID: ES_PL3_WBN
    what: Watchpoint/Breakpoint Number
    location: [ ES_PL3, 15..16 ]
    reset: 0
################ SID ################
  - ID: SID_SID
    what: Stream ID
    location: [ SID, 0..8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SID
    reset: 0
################ SID_PL0 ################
  - ID: SID_PL0_SID
    what: Stream ID
    location: [ SID_PL0, 0..8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SID_PL0
    reset: 0
################ SID_PL1 ################
  - ID: SID_PL1_SID
    what: Stream ID
    location: [ SID_PL1, 0..8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SID_PL1
    reset: 0
################ SID_PL2 ################
  - ID: SID_PL2_SID
    what: Stream ID
    location: [ SID_PL2, 0..8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SID_PL2
    reset: 0
################ SID_PL3 ################
  - ID: SID_PL3_SID
    what: Stream ID
    location: [ SID_PL3, 0..8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SID_PL3
    reset: 0
################ TCR ################
  - ID: TCR_T0CE
    what: Timer 0 Count Enable
    location: [ TCR, 16 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer count enable.
  - ID: TCR_T1CE
    what: Timer 1 Count Enable
    location: [ TCR, 17 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer count enable.
  - ID: TCR_T0IE
    what: Timer 0 Interrupt Enable
    location: [ TCR, 18 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer interrupt generation enable.
  - ID: TCR_T1IE
    what: Timer 1 Interrupt Enable
    location: [ TCR, 19 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer interrupt generation enable.
  - ID: TCR_T0ST
    what: Timer 0 Status
    location: [ TCR, 20 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer status bit.
  - ID: TCR_T1ST
    what: Timer 1 Status
    location: [ TCR, 21 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer status bit.
  - ID: TCR_T0SI
    what: Stop Timer 0 in Idle
    location: [ TCR, 22 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 Stop in Idle
  - ID: TCR_T1SI
    what: Stop Timer 1 in Idle
    location: [ TCR, 23 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 Stop in Idle
  - ID: TCR_WCE
    what: Watchdog Counting Enable
    location: [ TCR, 24 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Decounting Enable
  - ID: TCR_WIE
    what: Watchdog Interrupt Enable
    location: [ TCR, 25 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Interrupt Enable
  - ID: TCR_WUI
    what: Watchdog Underflow Inform
    location: [ TCR, 26 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Underflow Inform
  - ID: TCR_WUS
    what: Watchdog Underflow Status
    location: [ TCR, 27 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Underflow Status
  - ID: TCR_WSI
    what: Watchdog Stop in Idle
    location: [ TCR, 28 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Stop in Idle
################ PM0 ################
  - ID: PM0_PM0
    what: Performance Monitor 0
    location: [ PM0, 0..63 ]
    owners: [ MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM0
    reset: 0
################ PM1 ################
  - ID: PM1_PM1
    what: Performance Monitor 1
    location: [ PM1, 0..63 ]
    owners: [ MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM1
    reset: 0
################ PM2 ################
  - ID: PM2_PM2
    what: Performance Monitor 2
    location: [ PM2, 0..63 ]
    owners: [ MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM2
    reset: 0
################ PM3 ################
  - ID: PM3_PM3
    what: Performance Monitor 3
    location: [ PM3, 0..63 ]
    owners: [ MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM3
    reset: 0
################ PM4 ################
  - ID: PM4_PM4
    what: Performance Monitor 4
    location: [ PM4, 0..63 ]
    owners: [ MO_PM4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM4
    reset: 0
################ PM5 ################
  - ID: PM5_PM5
    what: Performance Monitor 5
    location: [ PM5, 0..63 ]
    owners: [ MO_PM5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM5
    reset: 0
################ PM6 ################
  - ID: PM6_PM6
    what: Performance Monitor 6
    location: [ PM6, 0..63 ]
    owners: [ MO_PM6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM6
    reset: 0
################ PM7 ################
  - ID: PM7_PM7
    what: Performance Monitor 7
    location: [ PM7, 0..63 ]
    owners: [ MO_PM7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM7
    reset: 0
################ SRHPC ################
  - ID: SRHPC_SRHPC
    what: Sequence rupture helper PC
    location: [ SRHPC, 0..63 ]
    owners: [ MO_SRHPC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PC of the last sequence rupture, when applicable
################ PMSA ################
  - ID: PMSA_PMSA
    what: Performance Monitor Saved Address
    location: [ PMSA, 0..63 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PMSA
    reset: 0
################ T0V ################
  - ID: T0V_T0V
    what: Timer 0 value
    location: [ T0V, 0..63 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T0V
    reset: 0
################ T1V ################
  - ID: T1V_T1V
    what: Timer 1 value
    location: [ T1V, 0..63 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T1V
    reset: 0
################ T0R ################
  - ID: T0R_T0R
    what: Timer 0 reload value
    location: [ T0R, 0..63 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T0R
    reset: 0
################ T1R ################
  - ID: T1R_T1R
    what: Timer 1 reload value
    location: [ T1R, 0..63 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T1R
    reset: 0
################ WDV ################
  - ID: WDV_WDV
    what: Watchdog Value
    location: [ WDV, 0..63 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: WDV
    reset: 0
################ WDR ################
  - ID: WDR_WDR
    what: Watchdog Reload Value
    location: [ WDR, 0..63 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: WDR
    reset: 0
################ PMC ################
  - ID: PMC_PM0C
    what: PM0 Configuration
    location: [ PMC, 0..5 ]
    owners: [ MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 0 Configuration.
  - ID: PMC_PM1C
    what: PM1 Configuration
    location: [ PMC, 7..12 ]
    owners: [ MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 1 configuration.
  - ID: PMC_PM2C
    what: PM2 Configuration
    location: [ PMC, 14..19 ]
    owners: [ MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 2 configuration.
  - ID: PMC_PM3C
    what: PM3 Configuration
    location: [ PMC, 21..26 ]
    owners: [ MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 3 configuration.
  - ID: PMC_SAV
    what: Saved Address Valid
    location: [ PMC, 30 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Saved Address Valid
  - ID: PMC_PM0IE
    what: PM0 Interrupt Enable
    location: [ PMC, 32 ]
    owners: [ MO_PMIT MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM0 Interrupt Enable
  - ID: PMC_PM1IE
    what: PM1 Interrupt Enable
    location: [ PMC, 33 ]
    owners: [ MO_PMIT MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM1 Interrupt Enable
  - ID: PMC_PM2IE
    what: PM2 Interrupt Enable
    location: [ PMC, 34 ]
    owners: [ MO_PMIT MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM2 Interrupt Enable
  - ID: PMC_PM3IE
    what: PM3 Interrupt Enable
    location: [ PMC, 35 ]
    owners: [ MO_PMIT MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM3 Interrupt Enable
  - ID: PMC_SAT
    what: Saved Address Type
    location: [ PMC, 36..37 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Saved Address Type
  - ID: PMC_SAF
    what: Saved Address From
    location: [ PMC, 38..40 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Saved Address From
################ PMC2 ################
  - ID: PMC2_PM4C
    what: PM4 Configuration
    location: [ PMC_2, 0..5 ]
    owners: [ MO_PM4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 4 Configuration.
  - ID: PMC2_PM5C
    what: PM5 Configuration
    location: [ PMC_2, 7..12 ]
    owners: [ MO_PM5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 5 configuration.
  - ID: PMC2_PM6C
    what: PM6 Configuration
    location: [ PMC_2, 14..19 ]
    owners: [ MO_PM6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 6 configuration.
  - ID: PMC2_PM7C
    what: PM7 Configuration
    location: [ PMC_2, 21..26 ]
    owners: [ MO_PM7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 7 configuration.
  - ID: PMC2_PM4IE
    what: PM4 Interrupt Enable
    location: [ PMC_2, 32 ]
    owners: [ MO_PMIT MO_PM4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM4 Interrupt Enable
  - ID: PMC2_PM5IE
    what: PM5 Interrupt Enable
    location: [ PMC_2, 33 ]
    owners: [ MO_PMIT MO_PM5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM5 Interrupt Enable
  - ID: PMC2_PM6IE
    what: PM6 Interrupt Enable
    location: [ PMC_2, 34 ]
    owners: [ MO_PMIT MO_PM6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM6 Interrupt Enable
  - ID: PMC2_PM7IE
    what: PM7 Interrupt Enable
    location: [ PMC_2, 35 ]
    owners: [ MO_PMIT MO_PM7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM7 Interrupt Enable
################ PCR ################
  - ID: PCR_PID
    what: Processing Identifier in cluster
    location: [ PCR, 0..7 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Processing Identification.
  - ID: PCR_CID
    what: Cluster Identifier in system
    location: [ PCR, 8..15 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Cluster Identification.
  - ID: PCR_MID
    what: MPPA Identifier
    location: [ PCR, 16..23 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      MPPA Indetification.
  - ID: PCR_CAR
    what: Core Architecture Revision ID
    location: [ PCR, 24..27 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x1
    description: >
      Core Architecture Revision Identifier.
  - ID: PCR_CMA
    what: Core Micro-Architecture Revision ID
    location: [ PCR, 28..31 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x0
    description: >
      Core Micro-Architecture Revision Identifier.
  - ID: PCR_SV
    what: System-On-Chip Version
    location: [ PCR, 32..39 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      System-On-Chip Version.
  - ID: PCR_ST
    what: System-On-Chip Type
    location: [ PCR, 40..43 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      System-On-Chip Type.
  - ID: PCR_BM
    what: Boot Mode
    location: [ PCR, 44..51 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Boot Mode.
  - ID: PCR_COE
    what: COprocessor Enable
    location: [ PCR, 52 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
    description: >
      Coprocessor enable.
  - ID: PCR_L1CE
    what: L1 cache Coherency Enable
    location: [ PCR, 53 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      L1 cache coherency enable.
  - ID: PCR_DSEM
    what: Data Simple Ecc exception Mode
    location: [ PCR, 54 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Data simple ECC exception mode.
  - ID: PCR_TPCE
    what: Trace PC Enable
    location: [ PCR, 55 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Trace PC Enable.
  - ID: PCR_TPCUM
    what: Trace PC Uninferable Mode
    location: [ PCR, 56 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Report Trace PC inferable jumps (call & goto instructions) as uninferable for callgrind support.
  - ID: PCR_TPCIS
    what: Trace PC Ignore Stall
    location: [ PCR, 57 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
    description: >
      Ignore Trace PC stall.
################ MMC ################
  - ID: MMC_ASN
    what: Address Space Number
    location: [ MMC, 0..8 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Address Space Number.
  - ID: MMC_S
    what: Speculative
    location: [ MMC, 9 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Speculative access.
  - ID: MMC_SNE
    what: Speculative NOMAPPING Enable
    location: [ MMC, 14 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
    description: >
      Enable speculative memory instruction to trigger the NOMAPPING trap.
  - ID: MMC_SPE
    what: Speculative PROTECTION Enable
    location: [ MMC, 15 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Enable speculative memory instruction to trigger the PROTECTION trap.
  - ID: MMC_PTC
    what: Protection Trap Cause
    location: [ MMC, 16..17 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Protection Trap Cause.
  - ID: MMC_SW
    what: Select Way
    location: [ MMC, 18..21 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Way we want to write to / read from.
  - ID: MMC_SS
    what: Select Set
    location: [ MMC, 22..27 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Set we want to read from.
  - ID: MMC_SB
    what: Select Buffer
    location: [ MMC, 28 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Buffer (JTLB or LTLB) we want to write to / read from.
  - ID: MMC_PAR
    what: PARity error flag
    location: [ MMC, 30 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PARity error flag, set by TLBREAD and TLBPROBE when encountering parity errors.
  - ID: MMC_E
    what: Error Flag
    location: [ MMC, 31 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Error Flag.
################ TEL ################
  - ID: TEL_ES
    what: Entry Status
    location: [ TEL, 0..1 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_CP2
    what: Cache Policy on V2
    location: [ TEL, 2..5 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_PA2
    what: Protection Attributes on V2
    location: [ TEL, 6..9 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_PS
    what: Page Size
    location: [ TEL, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_FN
    what: Frame Number
    location: [ TEL, 12..39 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ TEH ################
  - ID: TEH_ASN
    what: Address Space Number
    location: [ TEH, 0..8 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_G
    what: Global page indicator
    location: [ TEH, 9 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_VS
    what: Virtual Space
    location: [ TEH, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_PN
    what: Page Number
    location: [ TEH, 12..40 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ TPCM ################
  - ID: TPCM_0
    what: Trace PC message 0
    location: [ TPCM0, 0..63 ]
    owners: [ MO_TPCM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TPCM_1
    what: Trace PC message 1
    location: [ TPCM1, 0..63 ]
    owners: [ MO_TPCM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TPCM_2
    what: Trace PC message 2
    location: [ TPCM2, 0..63 ]
    owners: [ MO_TPCM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TPCM_PLD
    what: Trace PC message payload size
    location: [ TPCMC, 0..4 ]
    owners: [ MO_TPCM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TPCM_STS
    what: Trace PC message status
    location: [ TPCMC, 5..6 ]
    owners: [ MO_TPCM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ DC ################
################ DC0 ################
  - ID: DC0_BE
    what: Breakpoint 0 Enable
    location: [ DCV2_0, 0 ]
    owners: [ DO_B0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC0_WE
    what: Watchpoint 0 Enable
    location: [ DCV2_0, 1 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC0_WTYP
    what: Watchpoint 0 Type
    location: [ DCV2_0, 2..3 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC0_WSZ
    what: Watchpoint 0 Size
    location: [ DCV2_0, 4..31 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC1_BE
    what: Breakpoint 1 Enable
    location: [ DCV2_1, 0 ]
    owners: [ DO_B1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC1_WE
    what: Watchpoint 1 Enable
    location: [ DCV2_1, 1 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC1_WTYP
    what: Watchpoint 1 Type
    location: [ DCV2_1, 2..3 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC1_WSZ
    what: Watchpoint 1 Size
    location: [ DCV2_1, 4..31 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC2_BE
    what: Breakpoint 2 Enable
    location: [ DCV2_2, 0 ]
    owners: [ DO_B2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC2_WE
    what: Watchpoint 2 Enable
    location: [ DCV2_2, 1 ]
    owners: [ DO_W2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC2_WTYP
    what: Watchpoint 2 Type
    location: [ DCV2_2, 2..3 ]
    owners: [ DO_W2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC2_WSZ
    what: Watchpoint 2 Size
    location: [ DCV2_2, 4..31 ]
    owners: [ DO_W2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC3_BE
    what: Breakpoint 3 Enable
    location: [ DCV2_3, 0 ]
    owners: [ DO_B3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC3_WE
    what: Watchpoint 3 Enable
    location: [ DCV2_3, 1 ]
    owners: [ DO_W3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC3_WTYP
    what: Watchpoint 3 Type
    location: [ DCV2_3, 2..3 ]
    owners: [ DO_W3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC3_WSZ
    what: Watchpoint 3 Size
    location: [ DCV2_3, 4..31 ]
    owners: [ DO_W3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ MES ################
  - ID: MES_PSE
    what: Program Simple Ecc
    location: [ MES, 0 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      SECC detected on memory answer to the instruction cache.
  - ID: MES_PILSY
    what: Program cache Invalidated Line following pSYs error.
    location: [ MES, 1 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_PILDE
    what: Program cache Invalidated Line following pDEcc error.
    location: [ MES, 2 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_PILPA
    what: Program cache Invalidated Line following pPArity error.
    location: [ MES, 3 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DSE
    what: Data Simple Ecc
    location: [ MES, 4 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      SECC detected on memory answer to the data cache.
  - ID: MES_DILSY
    what: Data cache Invalidated Line following dSYs error.
    location: [ MES, 5 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DILDE
    what: Data cache Invalidated Line following dDEcc error.
    location: [ MES, 6 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
  - ID: MES_DILPA
    what: Data cache Invalidated Line following dPArity error.
    location: [ MES, 7 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DDEE
    what: Data DEcc Error.
    location: [ MES, 8 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DSYE
    what: Data dSYs Error.
    location: [ MES, 9 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ WS ################
  - ID: WS_WU0
    what: Wake-Up 0
    location: [ WS, 0 ]
    reset: 1
  - ID: WS_WU1
    what: Wake-Up 1
    location: [ WS, 1 ]
    reset: 1
  - ID: WS_WU2
    what: Wake-Up 2
    location: [ WS, 2 ]
    reset: 1
################ IPE ################
  - ID: IPE_FE
    what: Forward Events
    location: [ IPE, 0..15 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_BE
    what: Backward Events
    location: [ IPE, 16..31 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_FM
    what: Forward Mode
    location: [ IPE, 32..47 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_BM
    what: Backward Modes
    location: [ IPE, 48..63 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ IXC ################
  - ID: IXC_FCB
    what: Forward Channel Busy
    location: [ IXC, 0 ]
    owners: [ MO_COMM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IXC_SFB
    what: Swap Forward and Backward
    location: [ IXC, 8 ]
    owners: [ MO_COMM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IXC_BCB
    what: Backward Channel Busy
    location: [ IXC, 16 ]
    owners: [ MO_COMM ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ TPCC ################
  - ID: TPCC_TPCC
    what: Trace PC Context
    location: [ TPCC, 0..31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: TPCC
    reset: 0
################ TPCC_PL0 ################
  - ID: TPCC_PL0_TPCC
    what: Trace PC Context
    location: [ TPCC_PL0, 0..31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: TPCC_PL0
    reset: 0
################ TPCC_PL1 ################
  - ID: TPCC_PL1_TPCC
    what: Trace PC Context
    location: [ TPCC_PL1, 0..31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: TPCC_PL1
    reset: 0
################ TPCC_PL2 ################
  - ID: TPCC_PL2_TPCC
    what: Trace PC Context
    location: [ TPCC_PL2, 0..31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: TPCC_PL2
    reset: 0
################ TPCC_PL3 ################
  - ID: TPCC_PL3_TPCC
    what: Trace PC Context
    location: [ TPCC_PL3, 0..31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: TPCC_PL3
    reset: 0
RegFile:
  - ID: SFR
    what: System Function Registers
    width: 64
    dwarfIds: 64..255
    registers:
      - { ID: PC, location: [ PC, 0 ], names: [ "$pc", "$s0" ], reset: "Hardwired", raccess: "GET", waccess: "NONE", width: 64, what: "Program Counter"}
      - { ID: PS, location: [ PS, 0..31 ], names: [ "$ps", "$s1" ], raccess: "GET", waccess: "WFX", width: 32, what: "Processor State"}
      - { ID: PCR, location: [ PCR, 0..63 ], names: [ "$pcr", "$s2" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_PCR ], what: "Processing Identification"}
      - { ID: RA, location: [ SRS, 3 ], names: [ "$ra", "$s3" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Return Address"}
      - { ID: CS, location: [ CS, 0..63 ], names: [ "$cs", "$s4" ], raccess: "GET", waccess: "WFX", width: 64, what: "Compute Status"}
      - { ID: CSIT, location: [ CSIT, 0..31 ], names: [ "$csit", "$s5" ], raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_CSIT ], what: "Compute Status arithmetic interrupt"}
      - { ID: AESPC, location: [ AESPC, 0 ], names: [ "$aespc", "$s6" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_CSIT ], what: "Arithmetic Exception Saved PC"}
      - { ID: LS, location: [ SRS, 7 ], names: [ "$ls", "$s7" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Start Address"}
      - { ID: LE, location: [ SRS, 8 ], names: [ "$le", "$s8" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Exit Address"}
      - { ID: LC, location: [ SRS, 9 ], names: [ "$lc", "$s9" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Counter"}
      - { ID: IPE, location: [ IPE, 0..63 ], names: [ "$ipe", "$s10" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_SYNC ], what: "Inter Processor Event"}
      - { ID: MEN, location: [ MEN, 0..15 ], names: [ "$men", "$s11" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MEN ], what: "Misc External Notifications"}
      - { ID: PMC, location: [ PMC, 0..63 ], names: [ "$pmc", "$s12" ], raccess: "GET", waccess: "WFX", width: 64, what: "Performance Monitor Control"}
      - { ID: PM0, location: [ PM0, 0 ], names: [ "$pm0", "$s13" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM0 ], what: "Performance Monitor 0"}
      - { ID: PM1, location: [ PM1, 0 ], names: [ "$pm1", "$s14" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM1 ], what: "Performance Monitor 1"}
      - { ID: PM2, location: [ PM2, 0 ], names: [ "$pm2", "$s15" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM2 ], what: "Performance Monitor 2"}
      - { ID: PM3, location: [ PM3, 0 ], names: [ "$pm3", "$s16" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM3 ], what: "Performance Monitor 3"}
      - { ID: PMSA, location: [ PMSA, 0 ], names: [ "$pmsa", "$s17" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PMIT ], what: "Performance Monitor Saved Address" }
      - { ID: TCR, location: [ TCR, 0..31 ], names: [ "$tcr", "$s18" ], raccess: "GET", waccess: "WFX", width: 32, what: "Timer Control"}
      - { ID: T0V, location: [ T0V, 0 ], names: [ "$t0v", "$s19" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T0 ], what: "Timer 0 value"}
      - { ID: T1V, location: [ T1V, 0 ], names: [ "$t1v", "$s20" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T1 ], what: "Timer 1 value"}
      - { ID: T0R, location: [ T0R, 0 ], names: [ "$t0r", "$s21" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T0 ], what: "Timer 0 reload value"}
      - { ID: T1R, location: [ T1R, 0 ], names: [ "$t1r", "$s22" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T1 ], what: "Timer 1 reload value"}
      - { ID: WDV, location: [ WDV, 0 ], names: [ "$wdv", "$s23" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_WD ], what: "Watchdog Value"}
      - { ID: WDR, location: [ WDR, 0 ], names: [ "$wdr", "$s24" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_WD ], what: "Watchdog Reload"}
      - { ID: ILE, location: [ ILE, 0..31 ], names: [ "$ile", "$s25" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Enable"}
      - { ID: ILL, location: [ ILL, 0..63 ], names: [ "$ill", "$s26" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Level"}
      - { ID: ILR, location: [ ILR, 0..31 ], names: [ "$ilr", "$s27" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Request"}
      - { ID: MMC, location: [ MMC, 0..31 ], names: [ "$mmc", "$s28" ], raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_MSG ], what: "Memory Management Control"}
      - { ID: TEL, location: [ TEL, 0..63 ], names: [ "$tel", "$s29" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MSG ], what: "TLB Entry Low"}
      - { ID: TEH, location: [ TEH, 0..63 ], names: [ "$teh", "$s30" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MSG ], what: "TLB Entry High"}
      - { ID: IXC, location: [ IXC, 0..31 ], names: [ "$ixc", "$s31" ], reset: "0x00000", raccess: "GET", waccess: "WFX", width: 32, what: "Inter-Extension Communications"}
      - { ID: SYO, location: [ SYO, 0..31 ], names: [ "$syo", "$s32" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Syscall Owners"}
      - { ID: HTO, location: [ HTO, 0..31 ], names: [ "$hto", "$s33" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Hardware Trap Owners"}
      - { ID: ITO, location: [ ITO, 0..63 ], names: [ "$ito", "$s34" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "Interrupt Owners"}
      - { ID: DO, location: [ DO, 0..31 ], names: [ "$do", "$s35" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Debug Owners"}
      - { ID: MO, location: [ MO, 0..63 ], names: [ "$mo", "$s36" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "Miscellaneous Owners"}
      - { ID: PSO, location: [ PSO, 0..63 ], names: [ "$pso", "$s37" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "PS register fields Owners"}
      - { ID: TPCM0, location: [ TPCM0, 0 ], names: [ "$tpcm0", "$s38" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_TPCM ], what: "Trace PC message register 0"}
      - { ID: TPCM1, location: [ TPCM1, 0 ], names: [ "$tpcm1", "$s39" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_TPCM ], what: "Trace PC message register 1"}
      - { ID: DC, location: [ DC, 0..63 ], names: [ "$res40", "$s40" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "OCE (Debug) Control for hardware watchpoints and breakpoints 0 and 1"}
      - { ID: DBA0, location: [ DBA0, 0 ], names: [ "$dba0", "$s41" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B0 ], what: "Breakpoint Address 0"}
      - { ID: DBA1, location: [ DBA1, 0 ], names: [ "$dba1", "$s42" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B1 ], what: "Breakpoint Address 1"}
      - { ID: DWA0, location: [ DWA0, 0 ], names: [ "$dwa0", "$s43" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W0 ], what: "Watchpoint Address 0"}
      - { ID: DWA1, location: [ DWA1, 0 ], names: [ "$dwa1", "$s44" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W1 ], what: "Watchpoint Address 1"}
      - { ID: MES, location: [ MES, 0..31 ], names: [ "$mes", "$s45" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_MES ], what: "Memory Error Status"}
      - { ID: WS, location: [ WS, 0..31 ], names: [ "$ws", "$s46" ], reset: "0x00000007", raccess: "GET", waccess: "WFX", width: 32, what: "Wake-Up Status"}
      - { ID: DC0, location: [ DCV2_0, 0..63 ], names: [ "$dc0", "$s47" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "OCE (Debug) Control for hardware watchpoints and breakpoints 0"}
      - { ID: DC1, location: [ DCV2_1, 0..63 ], names: [ "$dc1", "$s48" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "OCE (Debug) Control for hardware watchpoints and breakpoints 1"}
      - { ID: DC2, location: [ DCV2_2, 0..63 ], names: [ "$dc2", "$s49" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "OCE (Debug) Control for hardware watchpoints and breakpoints 2"}
      - { ID: DC3, location: [ DCV2_3, 0..63 ], names: [ "$dc3", "$s50" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "OCE (Debug) Control for hardware watchpoints and breakpoints 3"}
      - { ID: DBA2, location: [ DBA2, 0 ], names: [ "$dba2", "$s51" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B2 ], what: "Breakpoint Address 2"}
      - { ID: DBA3, location: [ DBA3, 0 ], names: [ "$dba3", "$s52" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B3 ], what: "Breakpoint Address 3"}
      - { ID: DWA2, location: [ DWA2, 0 ], names: [ "$dwa2", "$s53" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W2 ], what: "Watchpoint Address 2"}
      - { ID: DWA3, location: [ DWA3, 0 ], names: [ "$dwa3", "$s54" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W3 ], what: "Watchpoint Address 3"}
      - { ID: TPCM2, location: [ TPCM2, 0 ], names: [ "$tpcm2", "$s55" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_TPCM ], what: "Trace PC message register 2"}
      - { ID: TPCMC, location: [ TPCMC, 0..63 ], names: [ "$tpcmc", "$s56" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_TPCM ], what: "Trace PC message control register"}
      - { ID: PM4, location: [ PM4, 0 ], names: [ "$pm4", "$s57" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM4 ], what: "Performance Monitor 4"}
      - { ID: PM5, location: [ PM5, 0 ], names: [ "$pm5", "$s58" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM5 ], what: "Performance Monitor 5"}
      - { ID: PM6, location: [ PM6, 0 ], names: [ "$pm6", "$s59" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM6 ], what: "Performance Monitor 6"}
      - { ID: PM7, location: [ PM7, 0 ], names: [ "$pm7", "$s60" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM7 ], what: "Performance Monitor 7"}
      - { ID: PMC2, location: [ PMC_2, 0..63 ], names: [ "$pmc2", "$s61" ], raccess: "GET", waccess: "WFX", width: 64, what: "Performance Monitor Control 2"}
      - { ID: SRHPC, location: [ SRHPC, 0 ], names: [ "$srhpc", "$s62" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Last sequence rupture helper PC when uninferrable"}
      - { ID: FRCC, location: [ FRCC, 0 ], names: [ "$frcc", "$s63" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Free running cycle counter"}
      - { ID: SPC_PL<r>, location: [ SRS, 64..67 ], names: [ "$spc_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Shadow PC PL <r>"}
      - { ID: SPS_PL0, location: [ SPS_PL0, 0..31 ], names: [ "$sps_pl0", "$s68" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 0"}
      - { ID: SPS_PL1, location: [ SPS_PL1, 0..31 ], names: [ "$sps_pl1", "$s69" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 1"}
      - { ID: SPS_PL2, location: [ SPS_PL2, 0..31 ], names: [ "$sps_pl2", "$s70" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 2"}
      - { ID: SPS_PL3, location: [ SPS_PL3, 0..31 ], names: [ "$sps_pl3", "$s71" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 3"}
      - { ID: EA_PL<r>, location: [ SRS, 72..75 ], names: [ "$ea_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Effective Address PL<r>"}
      - { ID: EV_PL<r>, location: [ SRS, 76..79 ], names: [ "$ev_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Exception Vector PL <r>"}
      - { ID: SR_PL<r>, location: [ SRS, 80..83 ], names: [ "$sr_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register PL <r>"}
      - { ID: ES_PL0, location: [ ES_PL0, 0..63 ], names: [ "$es_pl0", "$s84" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 0"}
      - { ID: ES_PL1, location: [ ES_PL1, 0..63 ], names: [ "$es_pl1", "$s85" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 1"}
      - { ID: ES_PL2, location: [ ES_PL2, 0..63 ], names: [ "$es_pl2", "$s86" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 2"}
      - { ID: ES_PL3, location: [ ES_PL3, 0..63 ], names: [ "$es_pl3", "$s87" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 3"}
      - { ID: SID_PL0, location: [ SID_PL0, 0..31 ], names: [ "$sid_pl0", "$s88" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 32, what: "Stream ID PL 0"}
      - { ID: SID_PL1, location: [ SID_PL1, 0..31 ], names: [ "$sid_pl1", "$s89" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 32, what: "Stream ID PL 1"}
      - { ID: SID_PL2, location: [ SID_PL2, 0..31 ], names: [ "$sid_pl2", "$s90" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 32, what: "Stream ID PL 2"}
      - { ID: SID_PL3, location: [ SID_PL3, 0..31 ], names: [ "$sid_pl3", "$s91" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 32, what: "Stream ID PL 3"}
      - { ID: SR1_PL<r>, location: [ SRS, 92..95 ], names: [ "$sr1_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register 1 PL <r>"}
      - { ID: SYOW, location: [ SYO, 0..31 ], names: [ "$syow", "$s96" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to SYO register"}
      - { ID: HTOW, location: [ HTO, 0..31 ], names: [ "$htow", "$s97" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to HTO register"}
      - { ID: ITOW, location: [ ITO, 0..63 ], names: [ "$itow", "$s98" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to ITO register"}
      - { ID: DOW, location: [ DO, 0..31 ], names: [ "$dow", "$s99" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to DO register"}
      - { ID: MOW, location: [ MO, 0..63 ], names: [ "$mow", "$s100" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to MO register"}
      - { ID: PSOW, location: [ PSO, 0..63 ], names: [ "$psow", "$s101" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to PSO register"}
      - { ID: RES<i>, location: [ SRS, 102..103 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC_PL0, location: [ TPCC_PL0, 0..31 ], names: [ "$tpcc_pl0", "$s104" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "Trace PC Context"}
      - { ID: TPCC_PL1, location: [ TPCC_PL1, 0..31 ], names: [ "$tpcc_pl1", "$s105" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "Trace PC Context"}
      - { ID: TPCC_PL2, location: [ TPCC_PL2, 0..31 ], names: [ "$tpcc_pl2", "$s106" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "Trace PC Context"}
      - { ID: TPCC_PL3, location: [ TPCC_PL3, 0..31 ], names: [ "$tpcc_pl3", "$s107" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "Trace PC Context"}
      - { ID: RES<i>, location: [ SRS, 108..127 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SPC, location: [ SRS, 128 ], names: [ "$spc", "$s128" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Shadow PC alias on SPC_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 129..131 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SPS, location: [ SPS, 0..31 ], names: [ "$sps", "$s132" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS alias on PS_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 133..135 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: EA, location: [ SRS, 136 ], names: [ "$ea", "$s136" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Effective Address alias on EA_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 137..139 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: EV, location: [ SRS, 140 ], names: [ "$ev", "$s140" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Exception Vector alias on EV_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 141..143 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SR, location: [ SRS, 144 ], names: [ "$sr", "$s144" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register alias on SR_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 145..147 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: ES, location: [ ES, 0..63 ], names: [ "$es", "$s148" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome alias on ES_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 149..151 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SID, location: [ SID, 0..31 ], names: [ "$sid", "$s152" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 32, what: "Stream ID alias on SID_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 153..155 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SR1, location: [ SRS, 156 ], names: [ "$sr1", "$s156" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register 1 alias on SR1_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 157..167 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC, location: [ TPCC, 0..31 ], names: [ "$tpcc", "$s168" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "Trace PC Context alias on TPCC_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 169..255 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: VSFR<r>, location: [ SRS, 256..511 ], names: [ "$vsfr<r>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Virtual SFR <r>"}
    nativeTypes: [ Int32, UInt32, Int64, UInt64 ]
    regClass: systemReg
    execution: "SFR[%0]"
  - ID: GPR
    what: General-Purpose Registers
    width: 64
    dwarfIds: 0..63
    registers:
      - { ID: R0, location: [ GRS, 0 ], names: [ "$r0", "$r0r1.lo", "$r0r1r2r3.x", ] }
      - { ID: R1, location: [ GRS, 1 ], names: [ "$r1", "$r0r1.hi", "$r0r1r2r3.y", ] }
      - { ID: R2, location: [ GRS, 2 ], names: [ "$r2", "$r2r3.lo", "$r0r1r2r3.z", ] }
      - { ID: R3, location: [ GRS, 3 ], names: [ "$r3", "$r2r3.hi", "$r0r1r2r3.t", ] }
      - { ID: R4, location: [ GRS, 4 ], names: [ "$r4", "$r4r5.lo", "$r4r5r6r7.x", ] }
      - { ID: R5, location: [ GRS, 5 ], names: [ "$r5", "$r4r5.hi", "$r4r5r6r7.y", ] }
      - { ID: R6, location: [ GRS, 6 ], names: [ "$r6", "$r6r7.lo", "$r4r5r6r7.z", ] }
      - { ID: R7, location: [ GRS, 7 ], names: [ "$r7", "$r6r7.hi", "$r4r5r6r7.t", ] }
      - { ID: R8, location: [ GRS, 8 ], names: [ "$r8", "$r8r9.lo", "$r8r9r10r11.x", ] }
      - { ID: R9, location: [ GRS, 9 ], names: [ "$r9", "$r8r9.hi", "$r8r9r10r11.y", ] }
      - { ID: R10, location: [ GRS, 10 ], names: [ "$r10", "$r10r11.lo", "$r8r9r10r11.z", ] }
      - { ID: R11, location: [ GRS, 11 ], names: [ "$r11", "$r10r11.hi", "$r8r9r10r11.t", ] }
      - { ID: R12, location: [ GRS, 12 ], names: [ "$r12", "$sp" ] }
      - { ID: R13, location: [ GRS, 13 ], names: [ "$r13", "$tp" ] }
      - { ID: R14, location: [ GRS, 14 ], names: [ "$r14", "$fp", "$r14r15.lo" ] }
      - { ID: R15, location: [ GRS, 15 ], names: [ "$r15", "$rp", "$r14r15.hi" ] }
      - { ID: R16, location: [ GRS, 16 ], names: [ "$r16", "$r16r17.lo", "$r16r17r18r19.x", ] }
      - { ID: R17, location: [ GRS, 17 ], names: [ "$r17", "$r16r17.hi", "$r16r17r18r19.y", ] }
      - { ID: R18, location: [ GRS, 18 ], names: [ "$r18", "$r18r19.lo", "$r16r17r18r19.z", ] }
      - { ID: R19, location: [ GRS, 19 ], names: [ "$r19", "$r18r19.hi", "$r16r17r18r19.t", ] }
      - { ID: R20, location: [ GRS, 20 ], names: [ "$r20", "$r20r21.lo", "$r20r21r22r23.x", ] }
      - { ID: R21, location: [ GRS, 21 ], names: [ "$r21", "$r20r21.hi", "$r20r21r22r23.y", ] }
      - { ID: R22, location: [ GRS, 22 ], names: [ "$r22", "$r22r23.lo", "$r20r21r22r23.z", ] }
      - { ID: R23, location: [ GRS, 23 ], names: [ "$r23", "$r22r23.hi", "$r20r21r22r23.t", ] }
      - { ID: R24, location: [ GRS, 24 ], names: [ "$r24", "$r24r25.lo", "$r24r25r26r27.x", ] }
      - { ID: R25, location: [ GRS, 25 ], names: [ "$r25", "$r24r25.hi", "$r24r25r26r27.y", ] }
      - { ID: R26, location: [ GRS, 26 ], names: [ "$r26", "$r26r27.lo", "$r24r25r26r27.z", ] }
      - { ID: R27, location: [ GRS, 27 ], names: [ "$r27", "$r26r27.hi", "$r24r25r26r27.t", ] }
      - { ID: R28, location: [ GRS, 28 ], names: [ "$r28", "$r28r29.lo", "$r28r29r30r31.x", ] }
      - { ID: R29, location: [ GRS, 29 ], names: [ "$r29", "$r28r29.hi", "$r28r29r30r31.y", ] }
      - { ID: R30, location: [ GRS, 30 ], names: [ "$r30", "$r30r31.lo", "$r28r29r30r31.z", ] }
      - { ID: R31, location: [ GRS, 31 ], names: [ "$r31", "$r30r31.hi", "$r28r29r30r31.t", ] }
      - { ID: R32, location: [ GRS, 32 ], names: [ "$r32", "$r32r33.lo", "$r32r33r34r35.x", ] }
      - { ID: R33, location: [ GRS, 33 ], names: [ "$r33", "$r32r33.hi", "$r32r33r34r35.y", ] }
      - { ID: R34, location: [ GRS, 34 ], names: [ "$r34", "$r34r35.lo", "$r32r33r34r35.z", ] }
      - { ID: R35, location: [ GRS, 35 ], names: [ "$r35", "$r34r35.hi", "$r32r33r34r35.t", ] }
      - { ID: R36, location: [ GRS, 36 ], names: [ "$r36", "$r36r37.lo", "$r36r37r38r39.x", ] }
      - { ID: R37, location: [ GRS, 37 ], names: [ "$r37", "$r36r37.hi", "$r36r37r38r39.y", ] }
      - { ID: R38, location: [ GRS, 38 ], names: [ "$r38", "$r38r39.lo", "$r36r37r38r39.z", ] }
      - { ID: R39, location: [ GRS, 39 ], names: [ "$r39", "$r38r39.hi", "$r36r37r38r39.t", ] }
      - { ID: R40, location: [ GRS, 40 ], names: [ "$r40", "$r40r41.lo", "$r40r41r42r43.x", ] }
      - { ID: R41, location: [ GRS, 41 ], names: [ "$r41", "$r40r41.hi", "$r40r41r42r43.y", ] }
      - { ID: R42, location: [ GRS, 42 ], names: [ "$r42", "$r42r43.lo", "$r40r41r42r43.z", ] }
      - { ID: R43, location: [ GRS, 43 ], names: [ "$r43", "$r42r43.hi", "$r40r41r42r43.t", ] }
      - { ID: R44, location: [ GRS, 44 ], names: [ "$r44", "$r44r45.lo", "$r44r45r46r47.x", ] }
      - { ID: R45, location: [ GRS, 45 ], names: [ "$r45", "$r44r45.hi", "$r44r45r46r47.y", ] }
      - { ID: R46, location: [ GRS, 46 ], names: [ "$r46", "$r46r47.lo", "$r44r45r46r47.z", ] }
      - { ID: R47, location: [ GRS, 47 ], names: [ "$r47", "$r46r47.hi", "$r44r45r46r47.t", ] }
      - { ID: R48, location: [ GRS, 48 ], names: [ "$r48", "$r48r49.lo", "$r48r49r50r51.x", ] }
      - { ID: R49, location: [ GRS, 49 ], names: [ "$r49", "$r48r49.hi", "$r48r49r50r51.y", ] }
      - { ID: R50, location: [ GRS, 50 ], names: [ "$r50", "$r50r51.lo", "$r48r49r50r51.z", ] }
      - { ID: R51, location: [ GRS, 51 ], names: [ "$r51", "$r50r51.hi", "$r48r49r50r51.t", ] }
      - { ID: R52, location: [ GRS, 52 ], names: [ "$r52", "$r52r53.lo", "$r52r53r54r55.x", ] }
      - { ID: R53, location: [ GRS, 53 ], names: [ "$r53", "$r52r53.hi", "$r52r53r54r55.y", ] }
      - { ID: R54, location: [ GRS, 54 ], names: [ "$r54", "$r54r55.lo", "$r52r53r54r55.z", ] }
      - { ID: R55, location: [ GRS, 55 ], names: [ "$r55", "$r54r55.hi", "$r52r53r54r55.t", ] }
      - { ID: R56, location: [ GRS, 56 ], names: [ "$r56", "$r56r57.lo", "$r56r57r58r59.x", ] }
      - { ID: R57, location: [ GRS, 57 ], names: [ "$r57", "$r56r57.hi", "$r56r57r58r59.y", ] }
      - { ID: R58, location: [ GRS, 58 ], names: [ "$r58", "$r58r59.lo", "$r56r57r58r59.z", ] }
      - { ID: R59, location: [ GRS, 59 ], names: [ "$r59", "$r58r59.hi", "$r56r57r58r59.t", ] }
      - { ID: R60, location: [ GRS, 60 ], names: [ "$r60", "$r60r61.lo", "$r60r61r62r63.x", ] }
      - { ID: R61, location: [ GRS, 61 ], names: [ "$r61", "$r60r61.hi", "$r60r61r62r63.y", ] }
      - { ID: R62, location: [ GRS, 62 ], names: [ "$r62", "$r62r63.lo", "$r60r61r62r63.z", ] }
      - { ID: R63, location: [ GRS, 63 ], names: [ "$r63", "$r62r63.hi", "$r60r61r62r63.t", ] }
    nativeTypes: [ Int32, UInt32, Float32, Int64, UInt64, Float64 ]
    regClass: singleReg
    shortName: r
    execution: "GPR[%0]"
  - ID: PGR
    what: Paired General Registers
    width: 128
    registers:
      - { ID: P0, location: [ GRS, 0, 1 ], names: [ "$r0r1", "$r0r1r2r3.lo" ] }
      - { ID: P2, location: [ GRS, 2, 3 ], names: [ "$r2r3", "$r0r1r2r3.hi" ] }
      - { ID: P4, location: [ GRS, 4, 5 ], names: [ "$r4r5", "$r4r5r6r7.lo" ] }
      - { ID: P6, location: [ GRS, 6, 7 ], names: [ "$r6r7", "$r4r5r6r7.hi" ] }
      - { ID: P8, location: [ GRS, 8, 9 ], names: [ "$r8r9", "$r8r9r10r11.lo" ] }
      - { ID: P10, location: [ GRS, 10, 11 ], names: [ "$r10r11", "$r8r9r10r11.hi" ] }
      - { ID: P12, location: [ GRS, 12, 13 ], names: [ "$r12r13", "$r12r13r14r15.lo" ] }
      - { ID: P14, location: [ GRS, 14, 15 ], names: [ "$r14r15", "$r12r13r14r15.hi" ] }
      - { ID: P16, location: [ GRS, 16, 17 ], names: [ "$r16r17", "$r16r17r18r19.lo" ] }
      - { ID: P18, location: [ GRS, 18, 19 ], names: [ "$r18r19", "$r16r17r18r19.hi" ] }
      - { ID: P20, location: [ GRS, 20, 21 ], names: [ "$r20r21", "$r20r21r22r23.lo" ] }
      - { ID: P22, location: [ GRS, 22, 23 ], names: [ "$r22r23", "$r20r21r22r23.hi" ] }
      - { ID: P24, location: [ GRS, 24, 25 ], names: [ "$r24r25", "$r24r25r26r27.lo" ] }
      - { ID: P26, location: [ GRS, 26, 27 ], names: [ "$r26r27", "$r24r25r26r27.hi" ] }
      - { ID: P28, location: [ GRS, 28, 29 ], names: [ "$r28r29", "$r28r29r30r31.lo" ] }
      - { ID: P30, location: [ GRS, 30, 31 ], names: [ "$r30r31", "$r28r29r30r31.hi" ] }
      - { ID: P32, location: [ GRS, 32, 33 ], names: [ "$r32r33", "$r32r33r34r35.lo" ] }
      - { ID: P34, location: [ GRS, 34, 35 ], names: [ "$r34r35", "$r32r33r34r35.hi" ] }
      - { ID: P36, location: [ GRS, 36, 37 ], names: [ "$r36r37", "$r36r37r38r39.lo" ] }
      - { ID: P38, location: [ GRS, 38, 39 ], names: [ "$r38r39", "$r36r37r38r39.hi" ] }
      - { ID: P40, location: [ GRS, 40, 41 ], names: [ "$r40r41", "$r40r41r42r43.lo" ] }
      - { ID: P42, location: [ GRS, 42, 43 ], names: [ "$r42r43", "$r40r41r42r43.hi" ] }
      - { ID: P44, location: [ GRS, 44, 45 ], names: [ "$r44r45", "$r44r45r46r47.lo" ] }
      - { ID: P46, location: [ GRS, 46, 47 ], names: [ "$r46r47", "$r44r45r46r47.hi" ] }
      - { ID: P48, location: [ GRS, 48, 49 ], names: [ "$r48r49", "$r48r49r50r51.lo" ] }
      - { ID: P50, location: [ GRS, 50, 51 ], names: [ "$r50r51", "$r48r49r50r51.hi" ] }
      - { ID: P52, location: [ GRS, 52, 53 ], names: [ "$r52r53", "$r52r53r54r55.lo" ] }
      - { ID: P54, location: [ GRS, 54, 55 ], names: [ "$r54r55", "$r52r53r54r55.hi" ] }
      - { ID: P56, location: [ GRS, 56, 57 ], names: [ "$r56r57", "$r56r57r58r59.lo" ] }
      - { ID: P58, location: [ GRS, 58, 59 ], names: [ "$r58r59", "$r56r57r58r59.hi" ] }
      - { ID: P60, location: [ GRS, 60, 61 ], names: [ "$r60r61", "$r60r61r62r63.lo" ] }
      - { ID: P62, location: [ GRS, 62, 63 ], names: [ "$r62r63", "$r60r61r62r63.hi" ] }
    nativeTypes: [ Int128, UInt128, Float128 ]
    regClass: pairedReg
    shortName: p
    execution: "PGR[%0]"
    multi: [ singleReg, singleReg ]
  - ID: QGR
    what: Quadruple General Registers
    width: 256
    registers:
      - { ID: Q0, location: [ GRS, 0, 1, 2, 3 ], names: [ "$r0r1r2r3" ] }
      - { ID: Q4, location: [ GRS, 4, 5, 6, 7 ], names: [ "$r4r5r6r7" ] }
      - { ID: Q8, location: [ GRS, 8, 9, 10, 11 ], names: [ "$r8r9r10r11" ] }
      - { ID: Q12, location: [ GRS, 12, 13, 14, 15 ], names: [ "$r12r13r14r15" ] }
      - { ID: Q16, location: [ GRS, 16, 17, 18, 19 ], names: [ "$r16r17r18r19" ] }
      - { ID: Q20, location: [ GRS, 20, 21, 22, 23 ], names: [ "$r20r21r22r23" ] }
      - { ID: Q24, location: [ GRS, 24, 25, 26, 27 ], names: [ "$r24r25r26r27" ] }
      - { ID: Q28, location: [ GRS, 28, 29, 30, 31 ], names: [ "$r28r29r30r31" ] }
      - { ID: Q32, location: [ GRS, 32, 33, 34, 35 ], names: [ "$r32r33r34r35" ] }
      - { ID: Q36, location: [ GRS, 36, 37, 38, 39 ], names: [ "$r36r37r38r39" ] }
      - { ID: Q40, location: [ GRS, 40, 41, 42, 43 ], names: [ "$r40r41r42r43" ] }
      - { ID: Q44, location: [ GRS, 44, 45, 46, 47 ], names: [ "$r44r45r46r47" ] }
      - { ID: Q48, location: [ GRS, 48, 49, 50, 51 ], names: [ "$r48r49r50r51" ] }
      - { ID: Q52, location: [ GRS, 52, 53, 54, 55 ], names: [ "$r52r53r54r55" ] }
      - { ID: Q56, location: [ GRS, 56, 57, 58, 59 ], names: [ "$r56r57r58r59" ] }
      - { ID: Q60, location: [ GRS, 60, 61, 62, 63 ], names: [ "$r60r61r62r63" ] }
    nativeTypes: [ Int128x2, UInt128x2 ]
    regClass: quadReg
    shortName: q
    execution: "QGR[%0]"
    multi: [ singleReg, singleReg, singleReg, singleReg ]
  - ID: XCR
    what: Extension Coprocessor Registers
    width: 64
    dwarfIds: 256..511
    registers:
      - { ID: C0, location: [ XRS, 0 ], names: [ "$a0_x", "$a0.x" ] }
      - { ID: C1, location: [ XRS, 1 ], names: [ "$a0_y", "$a0.y" ] }
      - { ID: C2, location: [ XRS, 2 ], names: [ "$a0_z", "$a0.z" ] }
      - { ID: C3, location: [ XRS, 3 ], names: [ "$a0_t", "$a0.t" ] }
      - { ID: C4, location: [ XRS, 4 ], names: [ "$a1_x", "$a1.x" ] }
      - { ID: C5, location: [ XRS, 5 ], names: [ "$a1_y", "$a1.y" ] }
      - { ID: C6, location: [ XRS, 6 ], names: [ "$a1_z", "$a1.z" ] }
      - { ID: C7, location: [ XRS, 7 ], names: [ "$a1_t", "$a1.t" ] }
      - { ID: C8, location: [ XRS, 8 ], names: [ "$a2_x", "$a2.x" ] }
      - { ID: C9, location: [ XRS, 9 ], names: [ "$a2_y", "$a2.y" ] }
      - { ID: C10, location: [ XRS, 10 ], names: [ "$a2_z", "$a2.z" ] }
      - { ID: C11, location: [ XRS, 11 ], names: [ "$a2_t", "$a2.t" ] }
      - { ID: C12, location: [ XRS, 12 ], names: [ "$a3_x", "$a3.x" ] }
      - { ID: C13, location: [ XRS, 13 ], names: [ "$a3_y", "$a3.y" ] }
      - { ID: C14, location: [ XRS, 14 ], names: [ "$a3_z", "$a3.z" ] }
      - { ID: C15, location: [ XRS, 15 ], names: [ "$a3_t", "$a3.t" ] }
      - { ID: C16, location: [ XRS, 16 ], names: [ "$a4_x", "$a4.x" ] }
      - { ID: C17, location: [ XRS, 17 ], names: [ "$a4_y", "$a4.y" ] }
      - { ID: C18, location: [ XRS, 18 ], names: [ "$a4_z", "$a4.z" ] }
      - { ID: C19, location: [ XRS, 19 ], names: [ "$a4_t", "$a4.t" ] }
      - { ID: C20, location: [ XRS, 20 ], names: [ "$a5_x", "$a5.x" ] }
      - { ID: C21, location: [ XRS, 21 ], names: [ "$a5_y", "$a5.y" ] }
      - { ID: C22, location: [ XRS, 22 ], names: [ "$a5_z", "$a5.z" ] }
      - { ID: C23, location: [ XRS, 23 ], names: [ "$a5_t", "$a5.t" ] }
      - { ID: C24, location: [ XRS, 24 ], names: [ "$a6_x", "$a6.x" ] }
      - { ID: C25, location: [ XRS, 25 ], names: [ "$a6_y", "$a6.y" ] }
      - { ID: C26, location: [ XRS, 26 ], names: [ "$a6_z", "$a6.z" ] }
      - { ID: C27, location: [ XRS, 27 ], names: [ "$a6_t", "$a6.t" ] }
      - { ID: C28, location: [ XRS, 28 ], names: [ "$a7_x", "$a7.x" ] }
      - { ID: C29, location: [ XRS, 29 ], names: [ "$a7_y", "$a7.y" ] }
      - { ID: C30, location: [ XRS, 30 ], names: [ "$a7_z", "$a7.z" ] }
      - { ID: C31, location: [ XRS, 31 ], names: [ "$a7_t", "$a7.t" ] }
      - { ID: C32, location: [ XRS, 32 ], names: [ "$a8_x", "$a8.x" ] }
      - { ID: C33, location: [ XRS, 33 ], names: [ "$a8_y", "$a8.y" ] }
      - { ID: C34, location: [ XRS, 34 ], names: [ "$a8_z", "$a8.z" ] }
      - { ID: C35, location: [ XRS, 35 ], names: [ "$a8_t", "$a8.t" ] }
      - { ID: C36, location: [ XRS, 36 ], names: [ "$a9_x", "$a9.x" ] }
      - { ID: C37, location: [ XRS, 37 ], names: [ "$a9_y", "$a9.y" ] }
      - { ID: C38, location: [ XRS, 38 ], names: [ "$a9_z", "$a9.z" ] }
      - { ID: C39, location: [ XRS, 39 ], names: [ "$a9_t", "$a9.t" ] }
      - { ID: C40, location: [ XRS, 40 ], names: [ "$a10_x", "$a10.x" ] }
      - { ID: C41, location: [ XRS, 41 ], names: [ "$a10_y", "$a10.y" ] }
      - { ID: C42, location: [ XRS, 42 ], names: [ "$a10_z", "$a10.z" ] }
      - { ID: C43, location: [ XRS, 43 ], names: [ "$a10_t", "$a10.t" ] }
      - { ID: C44, location: [ XRS, 44 ], names: [ "$a11_x", "$a11.x" ] }
      - { ID: C45, location: [ XRS, 45 ], names: [ "$a11_y", "$a11.y" ] }
      - { ID: C46, location: [ XRS, 46 ], names: [ "$a11_z", "$a11.z" ] }
      - { ID: C47, location: [ XRS, 47 ], names: [ "$a11_t", "$a11.t" ] }
      - { ID: C48, location: [ XRS, 48 ], names: [ "$a12_x", "$a12.x" ] }
      - { ID: C49, location: [ XRS, 49 ], names: [ "$a12_y", "$a12.y" ] }
      - { ID: C50, location: [ XRS, 50 ], names: [ "$a12_z", "$a12.z" ] }
      - { ID: C51, location: [ XRS, 51 ], names: [ "$a12_t", "$a12.t" ] }
      - { ID: C52, location: [ XRS, 52 ], names: [ "$a13_x", "$a13.x" ] }
      - { ID: C53, location: [ XRS, 53 ], names: [ "$a13_y", "$a13.y" ] }
      - { ID: C54, location: [ XRS, 54 ], names: [ "$a13_z", "$a13.z" ] }
      - { ID: C55, location: [ XRS, 55 ], names: [ "$a13_t", "$a13.t" ] }
      - { ID: C56, location: [ XRS, 56 ], names: [ "$a14_x", "$a14.x" ] }
      - { ID: C57, location: [ XRS, 57 ], names: [ "$a14_y", "$a14.y" ] }
      - { ID: C58, location: [ XRS, 58 ], names: [ "$a14_z", "$a14.z" ] }
      - { ID: C59, location: [ XRS, 59 ], names: [ "$a14_t", "$a14.t" ] }
      - { ID: C60, location: [ XRS, 60 ], names: [ "$a15_x", "$a15.x" ] }
      - { ID: C61, location: [ XRS, 61 ], names: [ "$a15_y", "$a15.y" ] }
      - { ID: C62, location: [ XRS, 62 ], names: [ "$a15_z", "$a15.z" ] }
      - { ID: C63, location: [ XRS, 63 ], names: [ "$a15_t", "$a15.t" ] }
      - { ID: C64, location: [ XRS, 64 ], names: [ "$a16_x", "$a16.x" ] }
      - { ID: C65, location: [ XRS, 65 ], names: [ "$a16_y", "$a16.y" ] }
      - { ID: C66, location: [ XRS, 66 ], names: [ "$a16_z", "$a16.z" ] }
      - { ID: C67, location: [ XRS, 67 ], names: [ "$a16_t", "$a16.t" ] }
      - { ID: C68, location: [ XRS, 68 ], names: [ "$a17_x", "$a17.x" ] }
      - { ID: C69, location: [ XRS, 69 ], names: [ "$a17_y", "$a17.y" ] }
      - { ID: C70, location: [ XRS, 70 ], names: [ "$a17_z", "$a17.z" ] }
      - { ID: C71, location: [ XRS, 71 ], names: [ "$a17_t", "$a17.t" ] }
      - { ID: C72, location: [ XRS, 72 ], names: [ "$a18_x", "$a18.x" ] }
      - { ID: C73, location: [ XRS, 73 ], names: [ "$a18_y", "$a18.y" ] }
      - { ID: C74, location: [ XRS, 74 ], names: [ "$a18_z", "$a18.z" ] }
      - { ID: C75, location: [ XRS, 75 ], names: [ "$a18_t", "$a18.t" ] }
      - { ID: C76, location: [ XRS, 76 ], names: [ "$a19_x", "$a19.x" ] }
      - { ID: C77, location: [ XRS, 77 ], names: [ "$a19_y", "$a19.y" ] }
      - { ID: C78, location: [ XRS, 78 ], names: [ "$a19_z", "$a19.z" ] }
      - { ID: C79, location: [ XRS, 79 ], names: [ "$a19_t", "$a19.t" ] }
      - { ID: C80, location: [ XRS, 80 ], names: [ "$a20_x", "$a20.x" ] }
      - { ID: C81, location: [ XRS, 81 ], names: [ "$a20_y", "$a20.y" ] }
      - { ID: C82, location: [ XRS, 82 ], names: [ "$a20_z", "$a20.z" ] }
      - { ID: C83, location: [ XRS, 83 ], names: [ "$a20_t", "$a20.t" ] }
      - { ID: C84, location: [ XRS, 84 ], names: [ "$a21_x", "$a21.x" ] }
      - { ID: C85, location: [ XRS, 85 ], names: [ "$a21_y", "$a21.y" ] }
      - { ID: C86, location: [ XRS, 86 ], names: [ "$a21_z", "$a21.z" ] }
      - { ID: C87, location: [ XRS, 87 ], names: [ "$a21_t", "$a21.t" ] }
      - { ID: C88, location: [ XRS, 88 ], names: [ "$a22_x", "$a22.x" ] }
      - { ID: C89, location: [ XRS, 89 ], names: [ "$a22_y", "$a22.y" ] }
      - { ID: C90, location: [ XRS, 90 ], names: [ "$a22_z", "$a22.z" ] }
      - { ID: C91, location: [ XRS, 91 ], names: [ "$a22_t", "$a22.t" ] }
      - { ID: C92, location: [ XRS, 92 ], names: [ "$a23_x", "$a23.x" ] }
      - { ID: C93, location: [ XRS, 93 ], names: [ "$a23_y", "$a23.y" ] }
      - { ID: C94, location: [ XRS, 94 ], names: [ "$a23_z", "$a23.z" ] }
      - { ID: C95, location: [ XRS, 95 ], names: [ "$a23_t", "$a23.t" ] }
      - { ID: C96, location: [ XRS, 96 ], names: [ "$a24_x", "$a24.x" ] }
      - { ID: C97, location: [ XRS, 97 ], names: [ "$a24_y", "$a24.y" ] }
      - { ID: C98, location: [ XRS, 98 ], names: [ "$a24_z", "$a24.z" ] }
      - { ID: C99, location: [ XRS, 99 ], names: [ "$a24_t", "$a24.t" ] }
      - { ID: C100, location: [ XRS, 100 ], names: [ "$a25_x", "$a25.x" ] }
      - { ID: C101, location: [ XRS, 101 ], names: [ "$a25_y", "$a25.y" ] }
      - { ID: C102, location: [ XRS, 102 ], names: [ "$a25_z", "$a25.z" ] }
      - { ID: C103, location: [ XRS, 103 ], names: [ "$a25_t", "$a25.t" ] }
      - { ID: C104, location: [ XRS, 104 ], names: [ "$a26_x", "$a26.x" ] }
      - { ID: C105, location: [ XRS, 105 ], names: [ "$a26_y", "$a26.y" ] }
      - { ID: C106, location: [ XRS, 106 ], names: [ "$a26_z", "$a26.z" ] }
      - { ID: C107, location: [ XRS, 107 ], names: [ "$a26_t", "$a26.t" ] }
      - { ID: C108, location: [ XRS, 108 ], names: [ "$a27_x", "$a27.x" ] }
      - { ID: C109, location: [ XRS, 109 ], names: [ "$a27_y", "$a27.y" ] }
      - { ID: C110, location: [ XRS, 110 ], names: [ "$a27_z", "$a27.z" ] }
      - { ID: C111, location: [ XRS, 111 ], names: [ "$a27_t", "$a27.t" ] }
      - { ID: C112, location: [ XRS, 112 ], names: [ "$a28_x", "$a28.x" ] }
      - { ID: C113, location: [ XRS, 113 ], names: [ "$a28_y", "$a28.y" ] }
      - { ID: C114, location: [ XRS, 114 ], names: [ "$a28_z", "$a28.z" ] }
      - { ID: C115, location: [ XRS, 115 ], names: [ "$a28_t", "$a28.t" ] }
      - { ID: C116, location: [ XRS, 116 ], names: [ "$a29_x", "$a29.x" ] }
      - { ID: C117, location: [ XRS, 117 ], names: [ "$a29_y", "$a29.y" ] }
      - { ID: C118, location: [ XRS, 118 ], names: [ "$a29_z", "$a29.z" ] }
      - { ID: C119, location: [ XRS, 119 ], names: [ "$a29_t", "$a29.t" ] }
      - { ID: C120, location: [ XRS, 120 ], names: [ "$a30_x", "$a30.x" ] }
      - { ID: C121, location: [ XRS, 121 ], names: [ "$a30_y", "$a30.y" ] }
      - { ID: C122, location: [ XRS, 122 ], names: [ "$a30_z", "$a30.z" ] }
      - { ID: C123, location: [ XRS, 123 ], names: [ "$a30_t", "$a30.t" ] }
      - { ID: C124, location: [ XRS, 124 ], names: [ "$a31_x", "$a31.x" ] }
      - { ID: C125, location: [ XRS, 125 ], names: [ "$a31_y", "$a31.y" ] }
      - { ID: C126, location: [ XRS, 126 ], names: [ "$a31_z", "$a31.z" ] }
      - { ID: C127, location: [ XRS, 127 ], names: [ "$a31_t", "$a31.t" ] }
      - { ID: C128, location: [ XRS, 128 ], names: [ "$a32_x", "$a32.x" ] }
      - { ID: C129, location: [ XRS, 129 ], names: [ "$a32_y", "$a32.y" ] }
      - { ID: C130, location: [ XRS, 130 ], names: [ "$a32_z", "$a32.z" ] }
      - { ID: C131, location: [ XRS, 131 ], names: [ "$a32_t", "$a32.t" ] }
      - { ID: C132, location: [ XRS, 132 ], names: [ "$a33_x", "$a33.x" ] }
      - { ID: C133, location: [ XRS, 133 ], names: [ "$a33_y", "$a33.y" ] }
      - { ID: C134, location: [ XRS, 134 ], names: [ "$a33_z", "$a33.z" ] }
      - { ID: C135, location: [ XRS, 135 ], names: [ "$a33_t", "$a33.t" ] }
      - { ID: C136, location: [ XRS, 136 ], names: [ "$a34_x", "$a34.x" ] }
      - { ID: C137, location: [ XRS, 137 ], names: [ "$a34_y", "$a34.y" ] }
      - { ID: C138, location: [ XRS, 138 ], names: [ "$a34_z", "$a34.z" ] }
      - { ID: C139, location: [ XRS, 139 ], names: [ "$a34_t", "$a34.t" ] }
      - { ID: C140, location: [ XRS, 140 ], names: [ "$a35_x", "$a35.x" ] }
      - { ID: C141, location: [ XRS, 141 ], names: [ "$a35_y", "$a35.y" ] }
      - { ID: C142, location: [ XRS, 142 ], names: [ "$a35_z", "$a35.z" ] }
      - { ID: C143, location: [ XRS, 143 ], names: [ "$a35_t", "$a35.t" ] }
      - { ID: C144, location: [ XRS, 144 ], names: [ "$a36_x", "$a36.x" ] }
      - { ID: C145, location: [ XRS, 145 ], names: [ "$a36_y", "$a36.y" ] }
      - { ID: C146, location: [ XRS, 146 ], names: [ "$a36_z", "$a36.z" ] }
      - { ID: C147, location: [ XRS, 147 ], names: [ "$a36_t", "$a36.t" ] }
      - { ID: C148, location: [ XRS, 148 ], names: [ "$a37_x", "$a37.x" ] }
      - { ID: C149, location: [ XRS, 149 ], names: [ "$a37_y", "$a37.y" ] }
      - { ID: C150, location: [ XRS, 150 ], names: [ "$a37_z", "$a37.z" ] }
      - { ID: C151, location: [ XRS, 151 ], names: [ "$a37_t", "$a37.t" ] }
      - { ID: C152, location: [ XRS, 152 ], names: [ "$a38_x", "$a38.x" ] }
      - { ID: C153, location: [ XRS, 153 ], names: [ "$a38_y", "$a38.y" ] }
      - { ID: C154, location: [ XRS, 154 ], names: [ "$a38_z", "$a38.z" ] }
      - { ID: C155, location: [ XRS, 155 ], names: [ "$a38_t", "$a38.t" ] }
      - { ID: C156, location: [ XRS, 156 ], names: [ "$a39_x", "$a39.x" ] }
      - { ID: C157, location: [ XRS, 157 ], names: [ "$a39_y", "$a39.y" ] }
      - { ID: C158, location: [ XRS, 158 ], names: [ "$a39_z", "$a39.z" ] }
      - { ID: C159, location: [ XRS, 159 ], names: [ "$a39_t", "$a39.t" ] }
      - { ID: C160, location: [ XRS, 160 ], names: [ "$a40_x", "$a40.x" ] }
      - { ID: C161, location: [ XRS, 161 ], names: [ "$a40_y", "$a40.y" ] }
      - { ID: C162, location: [ XRS, 162 ], names: [ "$a40_z", "$a40.z" ] }
      - { ID: C163, location: [ XRS, 163 ], names: [ "$a40_t", "$a40.t" ] }
      - { ID: C164, location: [ XRS, 164 ], names: [ "$a41_x", "$a41.x" ] }
      - { ID: C165, location: [ XRS, 165 ], names: [ "$a41_y", "$a41.y" ] }
      - { ID: C166, location: [ XRS, 166 ], names: [ "$a41_z", "$a41.z" ] }
      - { ID: C167, location: [ XRS, 167 ], names: [ "$a41_t", "$a41.t" ] }
      - { ID: C168, location: [ XRS, 168 ], names: [ "$a42_x", "$a42.x" ] }
      - { ID: C169, location: [ XRS, 169 ], names: [ "$a42_y", "$a42.y" ] }
      - { ID: C170, location: [ XRS, 170 ], names: [ "$a42_z", "$a42.z" ] }
      - { ID: C171, location: [ XRS, 171 ], names: [ "$a42_t", "$a42.t" ] }
      - { ID: C172, location: [ XRS, 172 ], names: [ "$a43_x", "$a43.x" ] }
      - { ID: C173, location: [ XRS, 173 ], names: [ "$a43_y", "$a43.y" ] }
      - { ID: C174, location: [ XRS, 174 ], names: [ "$a43_z", "$a43.z" ] }
      - { ID: C175, location: [ XRS, 175 ], names: [ "$a43_t", "$a43.t" ] }
      - { ID: C176, location: [ XRS, 176 ], names: [ "$a44_x", "$a44.x" ] }
      - { ID: C177, location: [ XRS, 177 ], names: [ "$a44_y", "$a44.y" ] }
      - { ID: C178, location: [ XRS, 178 ], names: [ "$a44_z", "$a44.z" ] }
      - { ID: C179, location: [ XRS, 179 ], names: [ "$a44_t", "$a44.t" ] }
      - { ID: C180, location: [ XRS, 180 ], names: [ "$a45_x", "$a45.x" ] }
      - { ID: C181, location: [ XRS, 181 ], names: [ "$a45_y", "$a45.y" ] }
      - { ID: C182, location: [ XRS, 182 ], names: [ "$a45_z", "$a45.z" ] }
      - { ID: C183, location: [ XRS, 183 ], names: [ "$a45_t", "$a45.t" ] }
      - { ID: C184, location: [ XRS, 184 ], names: [ "$a46_x", "$a46.x" ] }
      - { ID: C185, location: [ XRS, 185 ], names: [ "$a46_y", "$a46.y" ] }
      - { ID: C186, location: [ XRS, 186 ], names: [ "$a46_z", "$a46.z" ] }
      - { ID: C187, location: [ XRS, 187 ], names: [ "$a46_t", "$a46.t" ] }
      - { ID: C188, location: [ XRS, 188 ], names: [ "$a47_x", "$a47.x" ] }
      - { ID: C189, location: [ XRS, 189 ], names: [ "$a47_y", "$a47.y" ] }
      - { ID: C190, location: [ XRS, 190 ], names: [ "$a47_z", "$a47.z" ] }
      - { ID: C191, location: [ XRS, 191 ], names: [ "$a47_t", "$a47.t" ] }
      - { ID: C192, location: [ XRS, 192 ], names: [ "$a48_x", "$a48.x" ] }
      - { ID: C193, location: [ XRS, 193 ], names: [ "$a48_y", "$a48.y" ] }
      - { ID: C194, location: [ XRS, 194 ], names: [ "$a48_z", "$a48.z" ] }
      - { ID: C195, location: [ XRS, 195 ], names: [ "$a48_t", "$a48.t" ] }
      - { ID: C196, location: [ XRS, 196 ], names: [ "$a49_x", "$a49.x" ] }
      - { ID: C197, location: [ XRS, 197 ], names: [ "$a49_y", "$a49.y" ] }
      - { ID: C198, location: [ XRS, 198 ], names: [ "$a49_z", "$a49.z" ] }
      - { ID: C199, location: [ XRS, 199 ], names: [ "$a49_t", "$a49.t" ] }
      - { ID: C200, location: [ XRS, 200 ], names: [ "$a50_x", "$a50.x" ] }
      - { ID: C201, location: [ XRS, 201 ], names: [ "$a50_y", "$a50.y" ] }
      - { ID: C202, location: [ XRS, 202 ], names: [ "$a50_z", "$a50.z" ] }
      - { ID: C203, location: [ XRS, 203 ], names: [ "$a50_t", "$a50.t" ] }
      - { ID: C204, location: [ XRS, 204 ], names: [ "$a51_x", "$a51.x" ] }
      - { ID: C205, location: [ XRS, 205 ], names: [ "$a51_y", "$a51.y" ] }
      - { ID: C206, location: [ XRS, 206 ], names: [ "$a51_z", "$a51.z" ] }
      - { ID: C207, location: [ XRS, 207 ], names: [ "$a51_t", "$a51.t" ] }
      - { ID: C208, location: [ XRS, 208 ], names: [ "$a52_x", "$a52.x" ] }
      - { ID: C209, location: [ XRS, 209 ], names: [ "$a52_y", "$a52.y" ] }
      - { ID: C210, location: [ XRS, 210 ], names: [ "$a52_z", "$a52.z" ] }
      - { ID: C211, location: [ XRS, 211 ], names: [ "$a52_t", "$a52.t" ] }
      - { ID: C212, location: [ XRS, 212 ], names: [ "$a53_x", "$a53.x" ] }
      - { ID: C213, location: [ XRS, 213 ], names: [ "$a53_y", "$a53.y" ] }
      - { ID: C214, location: [ XRS, 214 ], names: [ "$a53_z", "$a53.z" ] }
      - { ID: C215, location: [ XRS, 215 ], names: [ "$a53_t", "$a53.t" ] }
      - { ID: C216, location: [ XRS, 216 ], names: [ "$a54_x", "$a54.x" ] }
      - { ID: C217, location: [ XRS, 217 ], names: [ "$a54_y", "$a54.y" ] }
      - { ID: C218, location: [ XRS, 218 ], names: [ "$a54_z", "$a54.z" ] }
      - { ID: C219, location: [ XRS, 219 ], names: [ "$a54_t", "$a54.t" ] }
      - { ID: C220, location: [ XRS, 220 ], names: [ "$a55_x", "$a55.x" ] }
      - { ID: C221, location: [ XRS, 221 ], names: [ "$a55_y", "$a55.y" ] }
      - { ID: C222, location: [ XRS, 222 ], names: [ "$a55_z", "$a55.z" ] }
      - { ID: C223, location: [ XRS, 223 ], names: [ "$a55_t", "$a55.t" ] }
      - { ID: C224, location: [ XRS, 224 ], names: [ "$a56_x", "$a56.x" ] }
      - { ID: C225, location: [ XRS, 225 ], names: [ "$a56_y", "$a56.y" ] }
      - { ID: C226, location: [ XRS, 226 ], names: [ "$a56_z", "$a56.z" ] }
      - { ID: C227, location: [ XRS, 227 ], names: [ "$a56_t", "$a56.t" ] }
      - { ID: C228, location: [ XRS, 228 ], names: [ "$a57_x", "$a57.x" ] }
      - { ID: C229, location: [ XRS, 229 ], names: [ "$a57_y", "$a57.y" ] }
      - { ID: C230, location: [ XRS, 230 ], names: [ "$a57_z", "$a57.z" ] }
      - { ID: C231, location: [ XRS, 231 ], names: [ "$a57_t", "$a57.t" ] }
      - { ID: C232, location: [ XRS, 232 ], names: [ "$a58_x", "$a58.x" ] }
      - { ID: C233, location: [ XRS, 233 ], names: [ "$a58_y", "$a58.y" ] }
      - { ID: C234, location: [ XRS, 234 ], names: [ "$a58_z", "$a58.z" ] }
      - { ID: C235, location: [ XRS, 235 ], names: [ "$a58_t", "$a58.t" ] }
      - { ID: C236, location: [ XRS, 236 ], names: [ "$a59_x", "$a59.x" ] }
      - { ID: C237, location: [ XRS, 237 ], names: [ "$a59_y", "$a59.y" ] }
      - { ID: C238, location: [ XRS, 238 ], names: [ "$a59_z", "$a59.z" ] }
      - { ID: C239, location: [ XRS, 239 ], names: [ "$a59_t", "$a59.t" ] }
      - { ID: C240, location: [ XRS, 240 ], names: [ "$a60_x", "$a60.x" ] }
      - { ID: C241, location: [ XRS, 241 ], names: [ "$a60_y", "$a60.y" ] }
      - { ID: C242, location: [ XRS, 242 ], names: [ "$a60_z", "$a60.z" ] }
      - { ID: C243, location: [ XRS, 243 ], names: [ "$a60_t", "$a60.t" ] }
      - { ID: C244, location: [ XRS, 244 ], names: [ "$a61_x", "$a61.x" ] }
      - { ID: C245, location: [ XRS, 245 ], names: [ "$a61_y", "$a61.y" ] }
      - { ID: C246, location: [ XRS, 246 ], names: [ "$a61_z", "$a61.z" ] }
      - { ID: C247, location: [ XRS, 247 ], names: [ "$a61_t", "$a61.t" ] }
      - { ID: C248, location: [ XRS, 248 ], names: [ "$a62_x", "$a62.x" ] }
      - { ID: C249, location: [ XRS, 249 ], names: [ "$a62_y", "$a62.y" ] }
      - { ID: C250, location: [ XRS, 250 ], names: [ "$a62_z", "$a62.z" ] }
      - { ID: C251, location: [ XRS, 251 ], names: [ "$a62_t", "$a62.t" ] }
      - { ID: C252, location: [ XRS, 252 ], names: [ "$a63_x", "$a63.x" ] }
      - { ID: C253, location: [ XRS, 253 ], names: [ "$a63_y", "$a63.y" ] }
      - { ID: C254, location: [ XRS, 254 ], names: [ "$a63_z", "$a63.z" ] }
      - { ID: C255, location: [ XRS, 255 ], names: [ "$a63_t", "$a63.t" ] }
    nativeTypes: [ Int64, UInt64 ]
  - ID: XBR
    what: Extension Block Registers
    width: 128
    registers:
      - { ID: B0, location: [ XRS, 0, 1 ], names: [ "$a0_lo", "$a0.lo" ] }
      - { ID: B1, location: [ XRS, 2, 3 ], names: [ "$a0_hi", "$a0.hi" ] }
      - { ID: B2, location: [ XRS, 4, 5 ], names: [ "$a1_lo", "$a1.lo" ] }
      - { ID: B3, location: [ XRS, 6, 7 ], names: [ "$a1_hi", "$a1.hi" ] }
      - { ID: B4, location: [ XRS, 8, 9 ], names: [ "$a2_lo", "$a2.lo" ] }
      - { ID: B5, location: [ XRS, 10, 11 ], names: [ "$a2_hi", "$a2.hi" ] }
      - { ID: B6, location: [ XRS, 12, 13 ], names: [ "$a3_lo", "$a3.lo" ] }
      - { ID: B7, location: [ XRS, 14, 15 ], names: [ "$a3_hi", "$a3.hi" ] }
      - { ID: B8, location: [ XRS, 16, 17 ], names: [ "$a4_lo", "$a4.lo" ] }
      - { ID: B9, location: [ XRS, 18, 19 ], names: [ "$a4_hi", "$a4.hi" ] }
      - { ID: B10, location: [ XRS, 20, 21 ], names: [ "$a5_lo", "$a5.lo" ] }
      - { ID: B11, location: [ XRS, 22, 23 ], names: [ "$a5_hi", "$a5.hi" ] }
      - { ID: B12, location: [ XRS, 24, 25 ], names: [ "$a6_lo", "$a6.lo" ] }
      - { ID: B13, location: [ XRS, 26, 27 ], names: [ "$a6_hi", "$a6.hi" ] }
      - { ID: B14, location: [ XRS, 28, 29 ], names: [ "$a7_lo", "$a7.lo" ] }
      - { ID: B15, location: [ XRS, 30, 31 ], names: [ "$a7_hi", "$a7.hi" ] }
      - { ID: B16, location: [ XRS, 32, 33 ], names: [ "$a8_lo", "$a8.lo" ] }
      - { ID: B17, location: [ XRS, 34, 35 ], names: [ "$a8_hi", "$a8.hi" ] }
      - { ID: B18, location: [ XRS, 36, 37 ], names: [ "$a9_lo", "$a9.lo" ] }
      - { ID: B19, location: [ XRS, 38, 39 ], names: [ "$a9_hi", "$a9.hi" ] }
      - { ID: B20, location: [ XRS, 40, 41 ], names: [ "$a10_lo", "$a10.lo" ] }
      - { ID: B21, location: [ XRS, 42, 43 ], names: [ "$a10_hi", "$a10.hi" ] }
      - { ID: B22, location: [ XRS, 44, 45 ], names: [ "$a11_lo", "$a11.lo" ] }
      - { ID: B23, location: [ XRS, 46, 47 ], names: [ "$a11_hi", "$a11.hi" ] }
      - { ID: B24, location: [ XRS, 48, 49 ], names: [ "$a12_lo", "$a12.lo" ] }
      - { ID: B25, location: [ XRS, 50, 51 ], names: [ "$a12_hi", "$a12.hi" ] }
      - { ID: B26, location: [ XRS, 52, 53 ], names: [ "$a13_lo", "$a13.lo" ] }
      - { ID: B27, location: [ XRS, 54, 55 ], names: [ "$a13_hi", "$a13.hi" ] }
      - { ID: B28, location: [ XRS, 56, 57 ], names: [ "$a14_lo", "$a14.lo" ] }
      - { ID: B29, location: [ XRS, 58, 59 ], names: [ "$a14_hi", "$a14.hi" ] }
      - { ID: B30, location: [ XRS, 60, 61 ], names: [ "$a15_lo", "$a15.lo" ] }
      - { ID: B31, location: [ XRS, 62, 63 ], names: [ "$a15_hi", "$a15.hi" ] }
      - { ID: B32, location: [ XRS, 64, 65 ], names: [ "$a16_lo", "$a16.lo" ] }
      - { ID: B33, location: [ XRS, 66, 67 ], names: [ "$a16_hi", "$a16.hi" ] }
      - { ID: B34, location: [ XRS, 68, 69 ], names: [ "$a17_lo", "$a17.lo" ] }
      - { ID: B35, location: [ XRS, 70, 71 ], names: [ "$a17_hi", "$a17.hi" ] }
      - { ID: B36, location: [ XRS, 72, 73 ], names: [ "$a18_lo", "$a18.lo" ] }
      - { ID: B37, location: [ XRS, 74, 75 ], names: [ "$a18_hi", "$a18.hi" ] }
      - { ID: B38, location: [ XRS, 76, 77 ], names: [ "$a19_lo", "$a19.lo" ] }
      - { ID: B39, location: [ XRS, 78, 79 ], names: [ "$a19_hi", "$a19.hi" ] }
      - { ID: B40, location: [ XRS, 80, 81 ], names: [ "$a20_lo", "$a20.lo" ] }
      - { ID: B41, location: [ XRS, 82, 83 ], names: [ "$a20_hi", "$a20.hi" ] }
      - { ID: B42, location: [ XRS, 84, 85 ], names: [ "$a21_lo", "$a21.lo" ] }
      - { ID: B43, location: [ XRS, 86, 87 ], names: [ "$a21_hi", "$a21.hi" ] }
      - { ID: B44, location: [ XRS, 88, 89 ], names: [ "$a22_lo", "$a22.lo" ] }
      - { ID: B45, location: [ XRS, 90, 91 ], names: [ "$a22_hi", "$a22.hi" ] }
      - { ID: B46, location: [ XRS, 92, 93 ], names: [ "$a23_lo", "$a23.lo" ] }
      - { ID: B47, location: [ XRS, 94, 95 ], names: [ "$a23_hi", "$a23.hi" ] }
      - { ID: B48, location: [ XRS, 96, 97 ], names: [ "$a24_lo", "$a24.lo" ] }
      - { ID: B49, location: [ XRS, 98, 99 ], names: [ "$a24_hi", "$a24.hi" ] }
      - { ID: B50, location: [ XRS, 100, 101 ], names: [ "$a25_lo", "$a25.lo" ] }
      - { ID: B51, location: [ XRS, 102, 103 ], names: [ "$a25_hi", "$a25.hi" ] }
      - { ID: B52, location: [ XRS, 104, 105 ], names: [ "$a26_lo", "$a26.lo" ] }
      - { ID: B53, location: [ XRS, 106, 107 ], names: [ "$a26_hi", "$a26.hi" ] }
      - { ID: B54, location: [ XRS, 108, 109 ], names: [ "$a27_lo", "$a27.lo" ] }
      - { ID: B55, location: [ XRS, 110, 111 ], names: [ "$a27_hi", "$a27.hi" ] }
      - { ID: B56, location: [ XRS, 112, 113 ], names: [ "$a28_lo", "$a28.lo" ] }
      - { ID: B57, location: [ XRS, 114, 115 ], names: [ "$a28_hi", "$a28.hi" ] }
      - { ID: B58, location: [ XRS, 116, 117 ], names: [ "$a29_lo", "$a29.lo" ] }
      - { ID: B59, location: [ XRS, 118, 119 ], names: [ "$a29_hi", "$a29.hi" ] }
      - { ID: B60, location: [ XRS, 120, 121 ], names: [ "$a30_lo", "$a30.lo" ] }
      - { ID: B61, location: [ XRS, 122, 123 ], names: [ "$a30_hi", "$a30.hi" ] }
      - { ID: B62, location: [ XRS, 124, 125 ], names: [ "$a31_lo", "$a31.lo" ] }
      - { ID: B63, location: [ XRS, 126, 127 ], names: [ "$a31_hi", "$a31.hi" ] }
      - { ID: B64, location: [ XRS, 128, 129 ], names: [ "$a32_lo", "$a32.lo" ] }
      - { ID: B65, location: [ XRS, 130, 131 ], names: [ "$a32_hi", "$a32.hi" ] }
      - { ID: B66, location: [ XRS, 132, 133 ], names: [ "$a33_lo", "$a33.lo" ] }
      - { ID: B67, location: [ XRS, 134, 135 ], names: [ "$a33_hi", "$a33.hi" ] }
      - { ID: B68, location: [ XRS, 136, 137 ], names: [ "$a34_lo", "$a34.lo" ] }
      - { ID: B69, location: [ XRS, 138, 139 ], names: [ "$a34_hi", "$a34.hi" ] }
      - { ID: B70, location: [ XRS, 140, 141 ], names: [ "$a35_lo", "$a35.lo" ] }
      - { ID: B71, location: [ XRS, 142, 143 ], names: [ "$a35_hi", "$a35.hi" ] }
      - { ID: B72, location: [ XRS, 144, 145 ], names: [ "$a36_lo", "$a36.lo" ] }
      - { ID: B73, location: [ XRS, 146, 147 ], names: [ "$a36_hi", "$a36.hi" ] }
      - { ID: B74, location: [ XRS, 148, 149 ], names: [ "$a37_lo", "$a37.lo" ] }
      - { ID: B75, location: [ XRS, 150, 151 ], names: [ "$a37_hi", "$a37.hi" ] }
      - { ID: B76, location: [ XRS, 152, 153 ], names: [ "$a38_lo", "$a38.lo" ] }
      - { ID: B77, location: [ XRS, 154, 155 ], names: [ "$a38_hi", "$a38.hi" ] }
      - { ID: B78, location: [ XRS, 156, 157 ], names: [ "$a39_lo", "$a39.lo" ] }
      - { ID: B79, location: [ XRS, 158, 159 ], names: [ "$a39_hi", "$a39.hi" ] }
      - { ID: B80, location: [ XRS, 160, 161 ], names: [ "$a40_lo", "$a40.lo" ] }
      - { ID: B81, location: [ XRS, 162, 163 ], names: [ "$a40_hi", "$a40.hi" ] }
      - { ID: B82, location: [ XRS, 164, 165 ], names: [ "$a41_lo", "$a41.lo" ] }
      - { ID: B83, location: [ XRS, 166, 167 ], names: [ "$a41_hi", "$a41.hi" ] }
      - { ID: B84, location: [ XRS, 168, 169 ], names: [ "$a42_lo", "$a42.lo" ] }
      - { ID: B85, location: [ XRS, 170, 171 ], names: [ "$a42_hi", "$a42.hi" ] }
      - { ID: B86, location: [ XRS, 172, 173 ], names: [ "$a43_lo", "$a43.lo" ] }
      - { ID: B87, location: [ XRS, 174, 175 ], names: [ "$a43_hi", "$a43.hi" ] }
      - { ID: B88, location: [ XRS, 176, 177 ], names: [ "$a44_lo", "$a44.lo" ] }
      - { ID: B89, location: [ XRS, 178, 179 ], names: [ "$a44_hi", "$a44.hi" ] }
      - { ID: B90, location: [ XRS, 180, 181 ], names: [ "$a45_lo", "$a45.lo" ] }
      - { ID: B91, location: [ XRS, 182, 183 ], names: [ "$a45_hi", "$a45.hi" ] }
      - { ID: B92, location: [ XRS, 184, 185 ], names: [ "$a46_lo", "$a46.lo" ] }
      - { ID: B93, location: [ XRS, 186, 187 ], names: [ "$a46_hi", "$a46.hi" ] }
      - { ID: B94, location: [ XRS, 188, 189 ], names: [ "$a47_lo", "$a47.lo" ] }
      - { ID: B95, location: [ XRS, 190, 191 ], names: [ "$a47_hi", "$a47.hi" ] }
      - { ID: B96, location: [ XRS, 192, 193 ], names: [ "$a48_lo", "$a48.lo" ] }
      - { ID: B97, location: [ XRS, 194, 195 ], names: [ "$a48_hi", "$a48.hi" ] }
      - { ID: B98, location: [ XRS, 196, 197 ], names: [ "$a49_lo", "$a49.lo" ] }
      - { ID: B99, location: [ XRS, 198, 199 ], names: [ "$a49_hi", "$a49.hi" ] }
      - { ID: B100, location: [ XRS, 200, 201 ], names: [ "$a50_lo", "$a50.lo" ] }
      - { ID: B101, location: [ XRS, 202, 203 ], names: [ "$a50_hi", "$a50.hi" ] }
      - { ID: B102, location: [ XRS, 204, 205 ], names: [ "$a51_lo", "$a51.lo" ] }
      - { ID: B103, location: [ XRS, 206, 207 ], names: [ "$a51_hi", "$a51.hi" ] }
      - { ID: B104, location: [ XRS, 208, 209 ], names: [ "$a52_lo", "$a52.lo" ] }
      - { ID: B105, location: [ XRS, 210, 211 ], names: [ "$a52_hi", "$a52.hi" ] }
      - { ID: B106, location: [ XRS, 212, 213 ], names: [ "$a53_lo", "$a53.lo" ] }
      - { ID: B107, location: [ XRS, 214, 215 ], names: [ "$a53_hi", "$a53.hi" ] }
      - { ID: B108, location: [ XRS, 216, 217 ], names: [ "$a54_lo", "$a54.lo" ] }
      - { ID: B109, location: [ XRS, 218, 219 ], names: [ "$a54_hi", "$a54.hi" ] }
      - { ID: B110, location: [ XRS, 220, 221 ], names: [ "$a55_lo", "$a55.lo" ] }
      - { ID: B111, location: [ XRS, 222, 223 ], names: [ "$a55_hi", "$a55.hi" ] }
      - { ID: B112, location: [ XRS, 224, 225 ], names: [ "$a56_lo", "$a56.lo" ] }
      - { ID: B113, location: [ XRS, 226, 227 ], names: [ "$a56_hi", "$a56.hi" ] }
      - { ID: B114, location: [ XRS, 228, 229 ], names: [ "$a57_lo", "$a57.lo" ] }
      - { ID: B115, location: [ XRS, 230, 231 ], names: [ "$a57_hi", "$a57.hi" ] }
      - { ID: B116, location: [ XRS, 232, 233 ], names: [ "$a58_lo", "$a58.lo" ] }
      - { ID: B117, location: [ XRS, 234, 235 ], names: [ "$a58_hi", "$a58.hi" ] }
      - { ID: B118, location: [ XRS, 236, 237 ], names: [ "$a59_lo", "$a59.lo" ] }
      - { ID: B119, location: [ XRS, 238, 239 ], names: [ "$a59_hi", "$a59.hi" ] }
      - { ID: B120, location: [ XRS, 240, 241 ], names: [ "$a60_lo", "$a60.lo" ] }
      - { ID: B121, location: [ XRS, 242, 243 ], names: [ "$a60_hi", "$a60.hi" ] }
      - { ID: B122, location: [ XRS, 244, 245 ], names: [ "$a61_lo", "$a61.lo" ] }
      - { ID: B123, location: [ XRS, 246, 247 ], names: [ "$a61_hi", "$a61.hi" ] }
      - { ID: B124, location: [ XRS, 248, 249 ], names: [ "$a62_lo", "$a62.lo" ] }
      - { ID: B125, location: [ XRS, 250, 251 ], names: [ "$a62_hi", "$a62.hi" ] }
      - { ID: B126, location: [ XRS, 252, 253 ], names: [ "$a63_lo", "$a63.lo" ] }
      - { ID: B127, location: [ XRS, 254, 255 ], names: [ "$a63_hi", "$a63.hi" ] }
    nativeTypes: [ Int128, UInt128 ]
  - ID: XVR
    what: Extension Vector Registers
    width: 256
    registers:
      - { ID: A0, location: [ XRS, 0, 1, 2, 3 ], names: [ "$a0", "$a0a1.lo", "$a0a1a2a3.x" ] }
      - { ID: A1, location: [ XRS, 4, 5, 6, 7 ], names: [ "$a1", "$a0a1.hi", "$a0a1a2a3.y" ] }
      - { ID: A2, location: [ XRS, 8, 9, 10, 11 ], names: [ "$a2", "$a2a3.lo", "$a0a1a2a3.z" ] }
      - { ID: A3, location: [ XRS, 12, 13, 14, 15 ], names: [ "$a3", "$a2a3.hi", "$a0a1a2a3.t" ] }
      - { ID: A4, location: [ XRS, 16, 17, 18, 19 ], names: [ "$a4", "$a4a5.lo", "$a4a5a6a7.x" ] }
      - { ID: A5, location: [ XRS, 20, 21, 22, 23 ], names: [ "$a5", "$a4a5.hi", "$a4a5a6a7.y" ] }
      - { ID: A6, location: [ XRS, 24, 25, 26, 27 ], names: [ "$a6", "$a6a7.lo", "$a4a5a6a7.z" ] }
      - { ID: A7, location: [ XRS, 28, 29, 30, 31 ], names: [ "$a7", "$a6a7.hi", "$a4a5a6a7.t" ] }
      - { ID: A8, location: [ XRS, 32, 33, 34, 35 ], names: [ "$a8", "$a8a9.lo", "$a8a9a10a11.x" ] }
      - { ID: A9, location: [ XRS, 36, 37, 38, 39 ], names: [ "$a9", "$a8a9.hi", "$a8a9a10a11.y" ] }
      - { ID: A10, location: [ XRS, 40, 41, 42, 43 ], names: [ "$a10", "$a10a11.lo", "$a8a9a10a11.z" ] }
      - { ID: A11, location: [ XRS, 44, 45, 46, 47 ], names: [ "$a11", "$a10a11.hi", "$a8a9a10a11.t" ] }
      - { ID: A12, location: [ XRS, 48, 49, 50, 51 ], names: [ "$a12", "$a12a13.lo", "$a12a13a14a15.x" ] }
      - { ID: A13, location: [ XRS, 52, 53, 54, 55 ], names: [ "$a13", "$a12a13.hi", "$a12a13a14a15.y" ] }
      - { ID: A14, location: [ XRS, 56, 57, 58, 59 ], names: [ "$a14", "$a14a15.lo", "$a12a13a14a15.z" ] }
      - { ID: A15, location: [ XRS, 60, 61, 62, 63 ], names: [ "$a15", "$a14a15.hi", "$a12a13a14a15.t" ] }
      - { ID: A16, location: [ XRS, 64, 65, 66, 67 ], names: [ "$a16", "$a16a17.lo", "$a16a17a18a19.x" ] }
      - { ID: A17, location: [ XRS, 68, 69, 70, 71 ], names: [ "$a17", "$a16a17.hi", "$a16a17a18a19.y" ] }
      - { ID: A18, location: [ XRS, 72, 73, 74, 75 ], names: [ "$a18", "$a18a19.lo", "$a16a17a18a19.z" ] }
      - { ID: A19, location: [ XRS, 76, 77, 78, 79 ], names: [ "$a19", "$a18a19.hi", "$a16a17a18a19.t" ] }
      - { ID: A20, location: [ XRS, 80, 81, 82, 83 ], names: [ "$a20", "$a20a21.lo", "$a20a21a22a23.x" ] }
      - { ID: A21, location: [ XRS, 84, 85, 86, 87 ], names: [ "$a21", "$a20a21.hi", "$a20a21a22a23.y" ] }
      - { ID: A22, location: [ XRS, 88, 89, 90, 91 ], names: [ "$a22", "$a22a23.lo", "$a20a21a22a23.z" ] }
      - { ID: A23, location: [ XRS, 92, 93, 94, 95 ], names: [ "$a23", "$a22a23.hi", "$a20a21a22a23.t" ] }
      - { ID: A24, location: [ XRS, 96, 97, 98, 99 ], names: [ "$a24", "$a24a25.lo", "$a24a25a26a27.x" ] }
      - { ID: A25, location: [ XRS, 100, 101, 102, 103 ], names: [ "$a25", "$a24a25.hi", "$a24a25a26a27.y" ] }
      - { ID: A26, location: [ XRS, 104, 105, 106, 107 ], names: [ "$a26", "$a26a27.lo", "$a24a25a26a27.z" ] }
      - { ID: A27, location: [ XRS, 108, 109, 110, 111 ], names: [ "$a27", "$a26a27.hi", "$a24a25a26a27.t" ] }
      - { ID: A28, location: [ XRS, 112, 113, 114, 115 ], names: [ "$a28", "$a28a29.lo", "$a28a29a30a31.x" ] }
      - { ID: A29, location: [ XRS, 116, 117, 118, 119 ], names: [ "$a29", "$a28a29.hi", "$a28a29a30a31.y" ] }
      - { ID: A30, location: [ XRS, 120, 121, 122, 123 ], names: [ "$a30", "$a30a31.lo", "$a28a29a30a31.z" ] }
      - { ID: A31, location: [ XRS, 124, 125, 126, 127 ], names: [ "$a31", "$a30a31.hi", "$a28a29a30a31.t" ] }
      - { ID: A32, location: [ XRS, 128, 129, 130, 131 ], names: [ "$a32", "$a32a33.lo", "$a32a33a34a35.x" ] }
      - { ID: A33, location: [ XRS, 132, 133, 134, 135 ], names: [ "$a33", "$a32a33.hi", "$a32a33a34a35.y" ] }
      - { ID: A34, location: [ XRS, 136, 137, 138, 139 ], names: [ "$a34", "$a34a35.lo", "$a32a33a34a35.z" ] }
      - { ID: A35, location: [ XRS, 140, 141, 142, 143 ], names: [ "$a35", "$a34a35.hi", "$a32a33a34a35.t" ] }
      - { ID: A36, location: [ XRS, 144, 145, 146, 147 ], names: [ "$a36", "$a36a37.lo", "$a36a37a38a39.x" ] }
      - { ID: A37, location: [ XRS, 148, 149, 150, 151 ], names: [ "$a37", "$a36a37.hi", "$a36a37a38a39.y" ] }
      - { ID: A38, location: [ XRS, 152, 153, 154, 155 ], names: [ "$a38", "$a38a39.lo", "$a36a37a38a39.z" ] }
      - { ID: A39, location: [ XRS, 156, 157, 158, 159 ], names: [ "$a39", "$a38a39.hi", "$a36a37a38a39.t" ] }
      - { ID: A40, location: [ XRS, 160, 161, 162, 163 ], names: [ "$a40", "$a40a41.lo", "$a40a41a42a43.x" ] }
      - { ID: A41, location: [ XRS, 164, 165, 166, 167 ], names: [ "$a41", "$a40a41.hi", "$a40a41a42a43.y" ] }
      - { ID: A42, location: [ XRS, 168, 169, 170, 171 ], names: [ "$a42", "$a42a43.lo", "$a40a41a42a43.z" ] }
      - { ID: A43, location: [ XRS, 172, 173, 174, 175 ], names: [ "$a43", "$a42a43.hi", "$a40a41a42a43.t" ] }
      - { ID: A44, location: [ XRS, 176, 177, 178, 179 ], names: [ "$a44", "$a44a45.lo", "$a44a45a46a47.x" ] }
      - { ID: A45, location: [ XRS, 180, 181, 182, 183 ], names: [ "$a45", "$a44a45.hi", "$a44a45a46a47.y" ] }
      - { ID: A46, location: [ XRS, 184, 185, 186, 187 ], names: [ "$a46", "$a46a47.lo", "$a44a45a46a47.z" ] }
      - { ID: A47, location: [ XRS, 188, 189, 190, 191 ], names: [ "$a47", "$a46a47.hi", "$a44a45a46a47.t" ] }
      - { ID: A48, location: [ XRS, 192, 193, 194, 195 ], names: [ "$a48", "$a48a49.lo", "$a48a49a50a51.x" ] }
      - { ID: A49, location: [ XRS, 196, 197, 198, 199 ], names: [ "$a49", "$a48a49.hi", "$a48a49a50a51.y" ] }
      - { ID: A50, location: [ XRS, 200, 201, 202, 203 ], names: [ "$a50", "$a50a51.lo", "$a48a49a50a51.z" ] }
      - { ID: A51, location: [ XRS, 204, 205, 206, 207 ], names: [ "$a51", "$a50a51.hi", "$a48a49a50a51.t" ] }
      - { ID: A52, location: [ XRS, 208, 209, 210, 211 ], names: [ "$a52", "$a52a53.lo", "$a52a53a54a55.x" ] }
      - { ID: A53, location: [ XRS, 212, 213, 214, 215 ], names: [ "$a53", "$a52a53.hi", "$a52a53a54a55.y" ] }
      - { ID: A54, location: [ XRS, 216, 217, 218, 219 ], names: [ "$a54", "$a54a55.lo", "$a52a53a54a55.z" ] }
      - { ID: A55, location: [ XRS, 220, 221, 222, 223 ], names: [ "$a55", "$a54a55.hi", "$a52a53a54a55.t" ] }
      - { ID: A56, location: [ XRS, 224, 225, 226, 227 ], names: [ "$a56", "$a56a57.lo", "$a56a57a58a59.x" ] }
      - { ID: A57, location: [ XRS, 228, 229, 230, 231 ], names: [ "$a57", "$a56a57.hi", "$a56a57a58a59.y" ] }
      - { ID: A58, location: [ XRS, 232, 233, 234, 235 ], names: [ "$a58", "$a58a59.lo", "$a56a57a58a59.z" ] }
      - { ID: A59, location: [ XRS, 236, 237, 238, 239 ], names: [ "$a59", "$a58a59.hi", "$a56a57a58a59.t" ] }
      - { ID: A60, location: [ XRS, 240, 241, 242, 243 ], names: [ "$a60", "$a60a61.lo", "$a60a61a62a63.x" ] }
      - { ID: A61, location: [ XRS, 244, 245, 246, 247 ], names: [ "$a61", "$a60a61.hi", "$a60a61a62a63.y" ] }
      - { ID: A62, location: [ XRS, 248, 249, 250, 251 ], names: [ "$a62", "$a62a63.lo", "$a60a61a62a63.z" ] }
      - { ID: A63, location: [ XRS, 252, 253, 254, 255 ], names: [ "$a63", "$a62a63.hi", "$a60a61a62a63.t" ] }
    nativeTypes: [ Int128x2, UInt128x2 ]
  - ID: XTR
    what: Extension Tile Registers
    width: 512
    registers:
      - { ID: T0, location: [ XRS, 0, 1, 2, 3, 4, 5, 6, 7 ], names: [ "$a0a1", "$a0a1a2a3.lo" ] }
      - { ID: T1, location: [ XRS, 8, 9, 10, 11, 12, 13, 14, 15 ], names: [ "$a2a3", "$a0a1a2a3.hi" ] }
      - { ID: T2, location: [ XRS, 16, 17, 18, 19, 20, 21, 22, 23 ], names: [ "$a4a5", "$a4a5a6a7.lo" ] }
      - { ID: T3, location: [ XRS, 24, 25, 26, 27, 28, 29, 30, 31 ], names: [ "$a6a7", "$a4a5a6a7.hi" ] }
      - { ID: T4, location: [ XRS, 32, 33, 34, 35, 36, 37, 38, 39 ], names: [ "$a8a9", "$a8a9a10a11.lo" ] }
      - { ID: T5, location: [ XRS, 40, 41, 42, 43, 44, 45, 46, 47 ], names: [ "$a10a11", "$a8a9a10a11.hi" ] }
      - { ID: T6, location: [ XRS, 48, 49, 50, 51, 52, 53, 54, 55 ], names: [ "$a12a13", "$a12a13a14a15.lo" ] }
      - { ID: T7, location: [ XRS, 56, 57, 58, 59, 60, 61, 62, 63 ], names: [ "$a14a15", "$a12a13a14a15.hi" ] }
      - { ID: T8, location: [ XRS, 64, 65, 66, 67, 68, 69, 70, 71 ], names: [ "$a16a17", "$a16a17a18a19.lo" ] }
      - { ID: T9, location: [ XRS, 72, 73, 74, 75, 76, 77, 78, 79 ], names: [ "$a18a19", "$a16a17a18a19.hi" ] }
      - { ID: T10, location: [ XRS, 80, 81, 82, 83, 84, 85, 86, 87 ], names: [ "$a20a21", "$a20a21a22a23.lo" ] }
      - { ID: T11, location: [ XRS, 88, 89, 90, 91, 92, 93, 94, 95 ], names: [ "$a22a23", "$a20a21a22a23.hi" ] }
      - { ID: T12, location: [ XRS, 96, 97, 98, 99, 100, 101, 102, 103 ], names: [ "$a24a25", "$a24a25a26a27.lo" ] }
      - { ID: T13, location: [ XRS, 104, 105, 106, 107, 108, 109, 110, 111 ], names: [ "$a26a27", "$a24a25a26a27.hi" ] }
      - { ID: T14, location: [ XRS, 112, 113, 114, 115, 116, 117, 118, 119 ], names: [ "$a28a29", "$a28a29a30a31.lo" ] }
      - { ID: T15, location: [ XRS, 120, 121, 122, 123, 124, 125, 126, 127 ], names: [ "$a30a31", "$a28a29a30a31.hi" ] }
      - { ID: T16, location: [ XRS, 128, 129, 130, 131, 132, 133, 134, 135 ], names: [ "$a32a33", "$a32a33a34a35.lo" ] }
      - { ID: T17, location: [ XRS, 136, 137, 138, 139, 140, 141, 142, 143 ], names: [ "$a34a35", "$a32a33a34a35.hi" ] }
      - { ID: T18, location: [ XRS, 144, 145, 146, 147, 148, 149, 150, 151 ], names: [ "$a36a37", "$a36a37a38a39.lo" ] }
      - { ID: T19, location: [ XRS, 152, 153, 154, 155, 156, 157, 158, 159 ], names: [ "$a38a39", "$a36a37a38a39.hi" ] }
      - { ID: T20, location: [ XRS, 160, 161, 162, 163, 164, 165, 166, 167 ], names: [ "$a40a41", "$a40a41a42a43.lo" ] }
      - { ID: T21, location: [ XRS, 168, 169, 170, 171, 172, 173, 174, 175 ], names: [ "$a42a43", "$a40a41a42a43.hi" ] }
      - { ID: T22, location: [ XRS, 176, 177, 178, 179, 180, 181, 182, 183 ], names: [ "$a44a45", "$a44a45a46a47.lo" ] }
      - { ID: T23, location: [ XRS, 184, 185, 186, 187, 188, 189, 190, 191 ], names: [ "$a46a47", "$a44a45a46a47.hi" ] }
      - { ID: T24, location: [ XRS, 192, 193, 194, 195, 196, 197, 198, 199 ], names: [ "$a48a49", "$a48a49a50a51.lo" ] }
      - { ID: T25, location: [ XRS, 200, 201, 202, 203, 204, 205, 206, 207 ], names: [ "$a50a51", "$a48a49a50a51.hi" ] }
      - { ID: T26, location: [ XRS, 208, 209, 210, 211, 212, 213, 214, 215 ], names: [ "$a52a53", "$a52a53a54a55.lo" ] }
      - { ID: T27, location: [ XRS, 216, 217, 218, 219, 220, 221, 222, 223 ], names: [ "$a54a55", "$a52a53a54a55.hi" ] }
      - { ID: T28, location: [ XRS, 224, 225, 226, 227, 228, 229, 230, 231 ], names: [ "$a56a57", "$a56a57a58a59.lo" ] }
      - { ID: T29, location: [ XRS, 232, 233, 234, 235, 236, 237, 238, 239 ], names: [ "$a58a59", "$a56a57a58a59.hi" ] }
      - { ID: T30, location: [ XRS, 240, 241, 242, 243, 244, 245, 246, 247 ], names: [ "$a60a61", "$a60a61a62a63.lo" ] }
      - { ID: T31, location: [ XRS, 248, 249, 250, 251, 252, 253, 254, 255 ], names: [ "$a62a63", "$a60a61a62a63.hi" ] }
    nativeTypes: [ Int128x4, UInt128x4 ]
  - ID: XMR
    what: Extension Matrix Registers
    width: 1024
    registers:
      - { ID: M0, location: [ XRS, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ], names: [ "$a0a1a2a3" ] }
      - { ID: M1, location: [ XRS, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ], names: [ "$a4a5a6a7" ] }
      - { ID: M2, location: [ XRS, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 ], names: [ "$a8a9a10a11" ] }
      - { ID: M3, location: [ XRS, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 ], names: [ "$a12a13a14a15" ] }
      - { ID: M4, location: [ XRS, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 ], names: [ "$a16a17a18a19" ] }
      - { ID: M5, location: [ XRS, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95 ], names: [ "$a20a21a22a23" ] }
      - { ID: M6, location: [ XRS, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111 ], names: [ "$a24a25a26a27" ] }
      - { ID: M7, location: [ XRS, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127 ], names: [ "$a28a29a30a31" ] }
      - { ID: M8, location: [ XRS, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143 ], names: [ "$a32a33a34a35" ] }
      - { ID: M9, location: [ XRS, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159 ], names: [ "$a36a37a38a39" ] }
      - { ID: M10, location: [ XRS, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175 ], names: [ "$a40a41a42a43" ] }
      - { ID: M11, location: [ XRS, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191 ], names: [ "$a44a45a46a47" ] }
      - { ID: M12, location: [ XRS, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207 ], names: [ "$a48a49a50a51" ] }
      - { ID: M13, location: [ XRS, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223 ], names: [ "$a52a53a54a55" ] }
      - { ID: M14, location: [ XRS, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239 ], names: [ "$a56a57a58a59" ] }
      - { ID: M15, location: [ XRS, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 ], names: [ "$a60a61a62a63" ] }
    nativeTypes: [ Int128x8, UInt128x8 ]
  - ID: X2R
    what: Extension 2-Register Buffer
    width: 0
    registers:
      - { ID: G0, location: [ XRS, 0 ], names: [ "$a0..a1" ] }
      - { ID: G1, location: [ XRS, 8 ], names: [ "$a2..a3" ] }
      - { ID: G2, location: [ XRS, 16 ], names: [ "$a4..a5" ] }
      - { ID: G3, location: [ XRS, 24 ], names: [ "$a6..a7" ] }
      - { ID: G4, location: [ XRS, 32 ], names: [ "$a8..a9" ] }
      - { ID: G5, location: [ XRS, 40 ], names: [ "$a10..a11" ] }
      - { ID: G6, location: [ XRS, 48 ], names: [ "$a12..a13" ] }
      - { ID: G7, location: [ XRS, 56 ], names: [ "$a14..a15" ] }
      - { ID: G8, location: [ XRS, 64 ], names: [ "$a16..a17" ] }
      - { ID: G9, location: [ XRS, 72 ], names: [ "$a18..a19" ] }
      - { ID: G10, location: [ XRS, 80 ], names: [ "$a20..a21" ] }
      - { ID: G11, location: [ XRS, 88 ], names: [ "$a22..a23" ] }
      - { ID: G12, location: [ XRS, 96 ], names: [ "$a24..a25" ] }
      - { ID: G13, location: [ XRS, 104 ], names: [ "$a26..a27" ] }
      - { ID: G14, location: [ XRS, 112 ], names: [ "$a28..a29" ] }
      - { ID: G15, location: [ XRS, 120 ], names: [ "$a30..a31" ] }
      - { ID: G16, location: [ XRS, 128 ], names: [ "$a32..a33" ] }
      - { ID: G17, location: [ XRS, 136 ], names: [ "$a34..a35" ] }
      - { ID: G18, location: [ XRS, 144 ], names: [ "$a36..a37" ] }
      - { ID: G19, location: [ XRS, 152 ], names: [ "$a38..a39" ] }
      - { ID: G20, location: [ XRS, 160 ], names: [ "$a40..a41" ] }
      - { ID: G21, location: [ XRS, 168 ], names: [ "$a42..a43" ] }
      - { ID: G22, location: [ XRS, 176 ], names: [ "$a44..a45" ] }
      - { ID: G23, location: [ XRS, 184 ], names: [ "$a46..a47" ] }
      - { ID: G24, location: [ XRS, 192 ], names: [ "$a48..a49" ] }
      - { ID: G25, location: [ XRS, 200 ], names: [ "$a50..a51" ] }
      - { ID: G26, location: [ XRS, 208 ], names: [ "$a52..a53" ] }
      - { ID: G27, location: [ XRS, 216 ], names: [ "$a54..a55" ] }
      - { ID: G28, location: [ XRS, 224 ], names: [ "$a56..a57" ] }
      - { ID: G29, location: [ XRS, 232 ], names: [ "$a58..a59" ] }
      - { ID: G30, location: [ XRS, 240 ], names: [ "$a60..a61" ] }
      - { ID: G31, location: [ XRS, 248 ], names: [ "$a62..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer2Reg
    shortName: g
    execution: "X2R[%0]"
  - ID: X4R
    what: Extension 4-Register Buffer
    width: 0
    registers:
      - { ID: H0, location: [ XRS, 0 ], names: [ "$a0..a3" ] }
      - { ID: H1, location: [ XRS, 16 ], names: [ "$a4..a7" ] }
      - { ID: H2, location: [ XRS, 32 ], names: [ "$a8..a11" ] }
      - { ID: H3, location: [ XRS, 48 ], names: [ "$a12..a15" ] }
      - { ID: H4, location: [ XRS, 64 ], names: [ "$a16..a19" ] }
      - { ID: H5, location: [ XRS, 80 ], names: [ "$a20..a23" ] }
      - { ID: H6, location: [ XRS, 96 ], names: [ "$a24..a27" ] }
      - { ID: H7, location: [ XRS, 112 ], names: [ "$a28..a31" ] }
      - { ID: H8, location: [ XRS, 128 ], names: [ "$a32..a35" ] }
      - { ID: H9, location: [ XRS, 144 ], names: [ "$a36..a39" ] }
      - { ID: H10, location: [ XRS, 160 ], names: [ "$a40..a43" ] }
      - { ID: H11, location: [ XRS, 176 ], names: [ "$a44..a47" ] }
      - { ID: H12, location: [ XRS, 192 ], names: [ "$a48..a51" ] }
      - { ID: H13, location: [ XRS, 208 ], names: [ "$a52..a55" ] }
      - { ID: H14, location: [ XRS, 224 ], names: [ "$a56..a59" ] }
      - { ID: H15, location: [ XRS, 240 ], names: [ "$a60..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer4Reg
    shortName: h
    execution: "X4R[%0]"
  - ID: X8R
    what: Extension 8-Register Buffer
    width: 0
    registers:
      - { ID: I0, location: [ XRS, 0 ], names: [ "$a0..a7" ] }
      - { ID: I1, location: [ XRS, 32 ], names: [ "$a8..a15" ] }
      - { ID: I2, location: [ XRS, 64 ], names: [ "$a16..a23" ] }
      - { ID: I3, location: [ XRS, 96 ], names: [ "$a24..a31" ] }
      - { ID: I4, location: [ XRS, 128 ], names: [ "$a32..a39" ] }
      - { ID: I5, location: [ XRS, 160 ], names: [ "$a40..a47" ] }
      - { ID: I6, location: [ XRS, 192 ], names: [ "$a48..a55" ] }
      - { ID: I7, location: [ XRS, 224 ], names: [ "$a56..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer8Reg
    shortName: i
    execution: "X8R[%0]"
  - ID: X16R
    what: Extension 16-Register Buffer
    width: 0
    registers:
      - { ID: J0, location: [ XRS, 0 ], names: [ "$a0..a15" ] }
      - { ID: J1, location: [ XRS, 64 ], names: [ "$a16..a31" ] }
      - { ID: J2, location: [ XRS, 128 ], names: [ "$a32..a47" ] }
      - { ID: J3, location: [ XRS, 192 ], names: [ "$a48..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer16Reg
    shortName: j
    execution: "X16R[%0]"
  - ID: X32R
    what: Extension 32-Register Buffer
    width: 0
    registers:
      - { ID: K0, location: [ XRS, 0 ], names: [ "$a0..a31" ] }
      - { ID: K1, location: [ XRS, 128 ], names: [ "$a32..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer32Reg
    shortName: k
    execution: "X32R[%0]"
  - ID: X64R
    what: Extension 64-Register Buffer
    width: 0
    registers:
      - { ID: L0, location: [ XRS, 0 ], names: [ "$a0..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer64Reg
    shortName: l
    execution: "X64R[%0]"
Relocation:
  - ID: rel16
    what: 16 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_16 ]
    elfIds: [ 1 ]
    fields: [ HALF ]
  - ID: rel32
    what: 32 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_32 ]
    elfIds: [ 2 ]
    fields: [ WORD ]
  - ID: rel64
    what: 64 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_64 ]
    elfIds: [ 3 ]
    fields: [ DOUBLE ]
  - ID: pcrel_signed16
    what: extended 16 bits PC relative address
    overflow: Signed
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S16_PCREL ]
    elfIds: [ 4 ]
    fields: [ signed16 ]
    operands: [ signed16 ]
  - ID: pcrel17
    what: extended 17 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL17 ]
    elfIds: [ 5 ]
    fields: [ pcrel17 ]
    operands: [ pcrel17 ]
  - ID: pcrel27
    what: extended 27 bits relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL27 ]
    elfIds: [ 6 ]
    fields: [ pcrel27 ]
    operands: [ pcrel27 ]
  - ID: pcrel32
    what: 32 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_32_PCREL ]
    elfIds: [ 7 ]
    fields: [ WORD ]
  - ID: pcrel_signed37
    what: extended 37 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S37_PCREL_UP27, R_KVX_S37_PCREL_LO10 ]
    elfIds: [ 9, 8 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: pcrel_signed43
    what: extended 43 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S43_PCREL_EX6, R_KVX_S43_PCREL_UP27, R_KVX_S43_PCREL_LO10 ]
    elfIds: [ 12, 11, 10 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: pcrel_signed64
    what: 64 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S64_PCREL_EX27, R_KVX_S64_PCREL_UP27, R_KVX_S64_PCREL_LO10 ]
    elfIds: [ 15, 14, 13 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: pcrel64
    what: 64 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_64_PCREL ]
    elfIds: [ 16 ]
    fields: [ DOUBLE ]
  - ID: signed16
    what: extended 16 bits relocation on symbol + addend
    overflow: Signed
    type: Rel_s_a
    linker: [ R_KVX_S16 ]
    elfIds: [ 17 ]
    fields: [ signed16 ]
    operands: [ signed16 ]
  - ID: signed32
    what: extended 32 bits relocation on symbol + addend
    syntax: '@signed32'
    type: Rel_s_a
    linker: [ R_KVX_S32_UP27, R_KVX_S32_LO5 ]
    elfIds: [ 19, 18 ]
    fields: [ upper27, lower5 ]
    operands: [ upper27_lower5 ]
  - ID: signed37
    what: extended 37 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S37_UP27, R_KVX_S37_LO10 ]
    elfIds: [ 21, 20 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotoff_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_GOTOFF_UP27, R_KVX_S37_GOTOFF_LO10 ]
    elfIds: [ 23, 22 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotoff_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_GOTOFF_EX6, R_KVX_S43_GOTOFF_UP27, R_KVX_S43_GOTOFF_LO10 ]
    elfIds: [ 26, 25, 24 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: gotoff_32
    what: 32 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_32_GOTOFF ]
    elfIds: [ 27 ]
    fields: [ WORD ]
  - ID: gotoff_64
    what: 64 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_64_GOTOFF ]
    elfIds: [ 28 ]
    fields: [ DOUBLE ]
  - ID: got_32
    what: 32 bits GOT relative relocation on symbol + addend
    overflow: Unsigned
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_32_GOT ]
    elfIds: [ 29 ]
    fields: [ WORD ]
  - ID: got_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_GOT_UP27, R_KVX_S37_GOT_LO10 ]
    elfIds: [ 31, 30 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: got_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_GOT_EX6, R_KVX_S43_GOT_UP27, R_KVX_S43_GOT_LO10 ]
    elfIds: [ 34, 33, 32 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: got_64
    what: 64 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_64_GOT ]
    elfIds: [ 35 ]
    fields: [ DOUBLE ]
  - ID: glob_dat
    what: pointer sized GOT entry
    underflow: 1
    type: Rel_s
    relative: GOT
    linker: [ R_KVX_GLOB_DAT ]
    elfIds: [ 36 ]
    fields: [ WORD ]
  - ID: copy
    what: Copy relocation
    type: Rel_s_a
    linker: [ R_KVX_COPY ]
    elfIds: [ 37 ]
    fields: [ WORD ]
  - ID: jump_slot
    what: Pointer-sized jump slot relocation
    type: Rel_s_a
    linker: [ R_KVX_JMP_SLOT ]
    elfIds: [ 38 ]
    fields: [ WORD ]
  - ID: relative
    what: Pointer-sized relative relocation on base + addend
    relative: BASE
    type: Rel_s_a
    linker: [ R_KVX_RELATIVE ]
    elfIds: [ 39 ]
    fields: [ WORD ]
  - ID: signed43
    what: extended 43 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S43_EX6, R_KVX_S43_UP27, R_KVX_S43_LO10 ]
    elfIds: [ 42, 41, 40 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: signed64
    what: 64 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S64_EX27, R_KVX_S64_UP27, R_KVX_S64_LO10 ]
    elfIds: [ 45, 44, 43 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: gotaddr_signed37
    what: extended 37 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S37_GOTADDR_UP27, R_KVX_S37_GOTADDR_LO10 ]
    elfIds: [ 47, 46 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotaddr_signed43
    what: extended 43 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S43_GOTADDR_EX6, R_KVX_S43_GOTADDR_UP27, R_KVX_S43_GOTADDR_LO10 ]
    elfIds: [ 50, 49, 48 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: gotaddr_signed64
    what: 64 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S64_GOTADDR_EX27, R_KVX_S64_GOTADDR_UP27, R_KVX_S64_GOTADDR_LO10 ]
    elfIds: [ 53, 52, 51 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: dtpmod64
    what: 64 bits relocation for dynamic module identifier
    type: Rel_s_a
    linker: [ R_KVX_64_DTPMOD ]
    elfIds: [ 54 ]
    fields: [ DOUBLE ]
  - ID: dtpoff64
    what: 64 bits relocation for offset of symbol + addend relative to dynamic TLS block
    type: Rel_s_a
    linker: [ R_KVX_64_DTPOFF ]
    elfIds: [ 55 ]
    fields: [ DOUBLE ]
  - ID: dtpoff_signed37
    what: extended 37 bits relocation for offset on symbol + addend relative to dynamic TLS block
    syntax: '@dtpoff'
    type: Rel_s_a
    linker: [ R_KVX_S37_TLS_DTPOFF_UP27, R_KVX_S37_TLS_DTPOFF_LO10 ]
    elfIds: [ 57, 56 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: dtpoff_signed43
    what: extended 43 bits relocation for offset on symbol + addend relative to dynamic TLS block
    syntax: '@tlsgd'
    type: Rel_s_a
    linker: [ R_KVX_S43_TLS_DTPOFF_EX6, R_KVX_S43_TLS_DTPOFF_UP27, R_KVX_S43_TLS_DTPOFF_LO10 ]
    elfIds: [ 60, 59, 58 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsgd_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS GD descriptor
    syntax: '@tlsgd'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_GD_UP27, R_KVX_S37_TLS_GD_LO10 ]
    elfIds: [ 62, 61 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsgd_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS GD descriptor
    syntax: '@tlsgd'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_GD_EX6, R_KVX_S43_TLS_GD_UP27, R_KVX_S43_TLS_GD_LO10 ]
    elfIds: [ 65, 64, 63 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsld_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS LD descriptor
    syntax: '@tlsld'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_LD_UP27, R_KVX_S37_TLS_LD_LO10 ]
    elfIds: [ 67, 66 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsld_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS LD descriptor
    syntax: '@tlsld'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_LD_EX6, R_KVX_S43_TLS_LD_UP27, R_KVX_S43_TLS_LD_LO10 ]
    elfIds: [ 70, 69, 68 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tpoff64
    what: 64 bits relocation for offset of symbol + addend in static TLS block for TLS IE
    relative: TP
    type: Rel_s_a
    linker: [ R_KVX_64_TPOFF ]
    elfIds: [ 71 ]
    fields: [ DOUBLE ]
  - ID: tlsie_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS IE descriptor
    syntax: '@tlsie'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_IE_UP27, R_KVX_S37_TLS_IE_LO10 ]
    elfIds: [ 73, 72 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsie_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS IE descriptor
    syntax: '@tlsie'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_IE_EX6, R_KVX_S43_TLS_IE_UP27, R_KVX_S43_TLS_IE_LO10 ]
    elfIds: [ 76, 75, 74 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsle_signed37
    what: extended 37 bits TP relative relocation on symbol + addend for TLS LE
    syntax: '@tlsle'
    type: Rel_s_a
    relative: TP
    linker: [ R_KVX_S37_TLS_LE_UP27, R_KVX_S37_TLS_LE_LO10 ]
    elfIds: [ 78, 77 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsle_signed43
    what: extended 43 bits TP relative relocation on symbol + addend for TLS LE
    syntax: '@tlsle'
    type: Rel_s_a
    relative: TP
    linker: [ R_KVX_S43_TLS_LE_EX6, R_KVX_S43_TLS_LE_UP27, R_KVX_S43_TLS_LE_LO10 ]
    elfIds: [ 81, 80, 79 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
## Adding basic relocation here to avoid to change all relocation elf ids
  - ID: rel8
    what: 8 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_8 ]
    elfIds: [ 82 ]
    fields: [ BYTE ]
  - ID: pcrel11
    what: extended 11 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL11 ]
    elfIds: [ 83 ]
    fields: [ pcrel11 ]
    operands: [ pcrel11 ]
  - ID: pcrel38
    what: extended 38 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_S38_PCREL_UP27, R_KVX_S38_PCREL_LO11 ]
    elfIds: [ 85, 84 ]
    fields: [ upper27, lower11 ]
    operands: [ upper27_lower11 ]
Reservation:
  - ID: ALL
    what: Instruction must be alone in instruction bundle.
    requirements: [ 8 ]
    resources: [ ISSUE ]
  - ID: ALU_TINY
    what: Instruction must issue on one of the four TINY units.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY.X
    what: Instruction with one immediate extension, must issue on one of the four TINY units.
    requirements: [ 2, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY.Y
    what: Instruction with two immediate extensions, must issue on one of the four TINY units.
    requirements: [ 3, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY_CRRP
    what: Instruction must issue on one of the four TINY units and uses the coprocessor read ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR12 ]
  - ID: ALU_TINY_CRWL_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRWL_CRWH.X
    what: Instruction with one immediate extension, must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRWL_CRWH.Y
    what: Instruction with two immediate extensions, must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRRP_CRWL_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR12, SR13, SR14 ]
  - ID: ALU_TINY_CRWL
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13 ]
  - ID: ALU_TINY_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR14 ]
  - ID: ALU_NOP
    what: Instruction is a no-operation.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, SR15 ]
  - ID: ALU_LITE
    what: Instruction must issue on one of the two LITE units.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE.X
    what: Instruction with one immediate extension, must issue on one of the two LITE units.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE.Y
    what: Instruction with two immediate extensions, must issue on one of the two LITE units.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE_CRWL
    what: Instruction must issue on one of the two LITE units and writes to low part of coprocessor register.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY, SR13 ]
  - ID: ALU_LITE_CRWH
    what: Instruction must issue on one of the two LITE units and writes to high part of coprocessor register.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY, SR14 ]
  - ID: ALU_FULL
    what: Instruction must issue on the ALU0.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: ALU_FULL.X
    what: Instruction with one immediate extension, must issue on the ALU0.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: ALU_FULL.Y
    what: Instruction with two immediate extensions, must issue on the ALU0.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: BCU
    what: Instruction must issue on the BCU.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, BCU ]
  - ID: BCU_XFER
    what: Instruction must issue on the BCU and unconditionally transfers control.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, BCU, XFER ]
  - ID: BCU_CRRP_CRWL_CRWH
    what: Instruction must issue on the BCU and uses the coprocessor read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, BCU, SR12, SR13, SR14 ]
  - ID: BCU_TINY_AUXW_CRRP
    what: Instruction must issue on the BCU, uses the auxiliary write port and uses the coprocessor read ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, BCU, TINY, AUXW, SR12 ]
  - ID: BCU_TINY_TINY_MAU_XNOP
    what: Instruction must issue on the BCU and uses the MAU write port, exclude NOPs.
    requirements: [ 1, 1, 2, 1, 4 ]
    resources: [ ISSUE, BCU, TINY, MAU, SR15 ]
  - ID: EXT
    what: Instruction must issue on the EXT.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, EXT ]
  - ID: LSU
    what: Instruction must issue on the LSU.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU.X
    what: Instruction with one immediate extension, must issue on the LSU.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU.Y
    what: Instruction with two immediate extensions, must issue on the LSU.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU_CRRP
    what: Instruction must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_CRRP.X
    what: Instruction with one immediate extension, must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_CRRP.Y
    what: Instruction with two immediate extensions, must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_AUXR
    what: Instruction must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXR.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXR.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXW
    what: Instruction must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXW.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXW.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXR_AUXW
    what: Instruction must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: LSU_AUXR_AUXW.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 2, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: LSU_AUXR_AUXW.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 3, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: MAU
    what: Instruction must issue on the MAU.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU.X
    what: Instruction with one immediate extension, must issue on the MAU.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU.Y
    what: Instruction with two immediate extensions, must issue on the MAU.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU_AUXR
    what: Instruction must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
  - ID: MAU_AUXR.X
    what: Instruction with one immediate extension, must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
  - ID: MAU_AUXR.Y
    what: Instruction with two immediate extensions, must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
Resource:
  - ID: ISSUE
    what: Issue slots counted in 32-bit syllables.
    availability: 8
  - ID: TINY
    what: Tiny ALU function units.
    availability: 4
  - ID: LITE
    what: Lite ALU function units.
    availability: 2
  - ID: FULL
    what: Full ALU function units.
    availability: 1
  - ID: LSU
    what: Load/Store function unit.
    availability: 1
  - ID: MAU
    what: Multiply and FP function unit (MAU).
    availability: 1
  - ID: BCU
    what: Branch and control unit.
    availability: 1
  - ID: EXT
    what: Extension coprocessor units.
    availability: 1
  - ID: AUXR
    what: Auxiliary core register read port shared with LSU (256 bits).
    availability: 1
  - ID: AUXW
    what: Auxiliary core register write port shared with LSU (256 bits).
    availability: 1
  - ID: XFER
    what: Unconditional control-flow transfer (XFER).
    availability: 1
  - ID: MEMW
    what: Memory write or memory read-modify-write resource (MEMW).
    availability: 1
  - ID: SR12
    what: Coprocessor 256-bit register read pair port (CRRP).
    availability: 1
  - ID: SR13
    what: Coprocessor 128-bit register write low half port (CRWL).
    availability: 1
  - ID: SR14
    what: Coprocessor 128-bit register write high half port (CRWH).
    availability: 1
  - ID: SR15
    what: No-operation (NOP).
    availability: 4
Scheduling:
  - ID: ALL
    bundling: ALL
    reservation: ALL
  - ID: BCU
    bundling: BCU
    reservation: BCU
  - ID: BCU_XFER
    bundling: BCU
    reservation: BCU_XFER
  - ID: BCU_TINY_TINY_MAU_XNOP
    bundling: BCU
    reservation: BCU_TINY_TINY_MAU_XNOP
  - ID: BCU_CRRP_CRWL_CRWH
    bundling: BCU
    reservation: BCU_CRRP_CRWL_CRWH
  - ID: BCU_TINY_AUXW_CRRP
    bundling: BCU
    reservation: BCU_TINY_AUXW_CRRP
  - ID: ALU_NOP
    bundling: NOP
    reservation: ALU_NOP
  - ID: EXT
    bundling: EXT
    reservation: EXT
  - ID: ALU_TINY
    bundling: TINY
    reservation: ALU_TINY
  - ID: ALU_TINY.X
    bundling: TINY.X
    reservation: ALU_TINY.X
  - ID: ALU_TINY.Y
    bundling: TINY.Y
    reservation: ALU_TINY.Y
  - ID: ALU_TINY_CRRP
    bundling: TINY
    reservation: ALU_TINY_CRRP
  - ID: ALU_TINY_CRWL_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRWL_CRWH
  - ID: ALU_TINY_CRWL_CRWH.X
    bundling: TINY.X
    reservation: ALU_TINY_CRWL_CRWH.X
  - ID: ALU_TINY_CRWL_CRWH.Y
    bundling: TINY.Y
    reservation: ALU_TINY_CRWL_CRWH.Y
  - ID: ALU_TINY_CRRP_CRWL_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRRP_CRWL_CRWH
  - ID: ALU_TINY_CRWL
    bundling: TINY
    reservation: ALU_TINY_CRWL
  - ID: ALU_TINY_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRWH
  - ID: ALU_LITE
    bundling: LITE
    reservation: ALU_LITE
  - ID: ALU_LITE.X
    bundling: LITE.X
    reservation: ALU_LITE.X
  - ID: ALU_LITE.Y
    bundling: LITE.Y
    reservation: ALU_LITE.Y
  - ID: ALU_LITE_CRWL
    bundling: LITE
    reservation: ALU_LITE_CRWL
  - ID: ALU_LITE_CRWH
    bundling: LITE
    reservation: ALU_LITE_CRWH
  - ID: ALU_FULL
    bundling: FULL
    reservation: ALU_FULL
  - ID: ALU_FULL.X
    bundling: FULL.X
    reservation: ALU_FULL.X
  - ID: ALU_FULL.Y
    bundling: FULL.Y
    reservation: ALU_FULL.Y
  - ID: MAU
    bundling: MAU
    reservation: MAU
  - ID: MAU.X
    bundling: MAU.X
    reservation: MAU.X
  - ID: MAU.Y
    bundling: MAU.Y
    reservation: MAU.Y
  - ID: MAU_AUXR
    bundling: MAU
    reservation: MAU_AUXR
  - ID: MAU_AUXR.X
    bundling: MAU.X
    reservation: MAU_AUXR.X
  - ID: MAU_AUXR.Y
    bundling: MAU.Y
    reservation: MAU_AUXR.Y
  - ID: LSU
    bundling: LSU
    reservation: LSU
  - ID: LSU.X
    bundling: LSU.X
    reservation: LSU.X
  - ID: LSU.Y
    bundling: LSU.Y
    reservation: LSU.Y
  - ID: LSU_CRRP
    bundling: LSU
    reservation: LSU_CRRP
  - ID: LSU_CRRP.X
    bundling: LSU.X
    reservation: LSU_CRRP.X
  - ID: LSU_CRRP.Y
    bundling: LSU.Y
    reservation: LSU_CRRP.Y
  - ID: LSU_AUXR
    bundling: LSU
    reservation: LSU_AUXR
  - ID: LSU_AUXR.X
    bundling: LSU.X
    reservation: LSU_AUXR.X
  - ID: LSU_AUXR.Y
    bundling: LSU.Y
    reservation: LSU_AUXR.Y
  - ID: LSU_AUXW
    bundling: LSU
    reservation: LSU_AUXW
  - ID: LSU_AUXW.X
    bundling: LSU.X
    reservation: LSU_AUXW.X
  - ID: LSU_AUXW.Y
    bundling: LSU.Y
    reservation: LSU_AUXW.Y
  - ID: LSU_AUXR_AUXW
    bundling: LSU
    reservation: LSU_AUXR_AUXW
  - ID: LSU_AUXR_AUXW.X
    bundling: LSU.X
    reservation: LSU_AUXR_AUXW.X
  - ID: LSU_AUXR_AUXW.Y
    bundling: LSU.Y
    reservation: LSU_AUXR_AUXW.Y
Simulated:
  - ID: ADJUST
    what: Adjust Stack Pointer
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2, %3"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: singleReg
        usage: Left
        proxy: "%2"
        stages: 1
      - action: "Read"
        method:
          Immediate: signed10
        usage: Right
        proxy: "%3"
        stages: 0
  - ID: GETPC
    what: Get Program Counter
    scheduling: BCU
    syntax: "%0 %1"
    parameters:
      - action: Write
        method:
          Register: PC
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          Immediate: pcrel27
        proxy: "%2"
        stages: 0
  - ID: SET_GOTP
    what: Get System Register in PIC Mode
    scheduling: ALL
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
      - action: Read
        method:
          RegClass: systemReg
        proxy: "%2"
        stages: 1
      - action: Read
        method:
          Immediate: wrapped32
        proxy: "%4"
        stages: 1
  - ID: GNUASM
    what: GNU ASM Statement.
    scheduling: ALL
    syntax: "%0"
    parameters:
      - action: WriteList
        method:
          RegClass: ""
        stages: 2
      - action: ReadList
        method:
          RegClass: ""
        stages: 1
  - ID: GNUASM_CFG
    what: GNU ASM Statement.
    scheduling: ALL
    syntax: "%0"
    properties: "Conditional Control"
    parameters:
      - action: WriteList
        method:
          RegClass: ""
        stages: 2
      - action: Read
        method:
          Immediate: pcrel27
        usage: Target
        stages: 1
      - action: ReadList
        method:
          RegClass: ""
        stages: 1
  - ID: MOVP
    what: Move of paired registers
    scheduling: ALU_LITE
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: pairedReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%2"
        stages: 1
  - ID: COMPOSEP
    what: Pair register composition
    scheduling: ALU_FULL
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: pairedReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: singleReg
        usage: Left
        proxy: "%2"
        stages: 1
      - action: "Read"
        method:
          RegClass: singleReg
        usage: Right
        proxy: "%3"
        stages: 1
  - ID: EXTRACTP
    what: Pair register extraction
    scheduling: ALU_LITE
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 1
  - ID: MOVC
    what: Predicated move on true predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
  - ID: MOVPC
    what: Predicated paired move on true predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: pairedReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 2
  - ID: MOVCF
    what: Predicated move on false predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
  - ID: MOVPCF
    what: Predicated paired move on false predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: pairedReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 2
  - ID: SYSCALL
    what: Simulated System Call with result operand
    scheduling: ALL
    syntax: "%0 %1 = %2"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
Storage:
  - ID: AESPC
    what: Arithmetic Exception Saved PC
    kind: Special
    width: 64
    count: 1
  - ID: PM0
    what: Performance Monitor 0
    kind: Special
    width: 64
    count: 1
  - ID: PM1
    what: Performance Monitor 1
    kind: Special
    width: 64
    count: 1
  - ID: PM2
    what: Performance Monitor 2
    kind: Special
    width: 64
    count: 1
  - ID: PM3
    what: Performance Monitor 3
    kind: Special
    width: 64
    count: 1
  - ID: PM4
    what: Performance Monitor 4
    kind: Special
    width: 64
    count: 1
  - ID: PM5
    what: Performance Monitor 5
    kind: Special
    width: 64
    count: 1
  - ID: PM6
    what: Performance Monitor 6
    kind: Special
    width: 64
    count: 1
  - ID: PM7
    what: Performance Monitor 7
    kind: Special
    width: 64
    count: 1
  - ID: PMSA
    what: Performance Monitor Saved Address
    kind: Special
    width: 64
    count: 1
  - ID: T0V
    what: Timer 0 value
    kind: Special
    width: 64
    count: 1
  - ID: T1V
    what: Timer 1 value
    kind: Special
    width: 64
    count: 1
  - ID: T0R
    what: Timer 0 reload value
    kind: Special
    width: 64
    count: 1
  - ID: T1R
    what: Timer 1 reload value
    kind: Special
    width: 64
    count: 1
  - ID: WDV
    what: Watchdog Value
    kind: Special
    width: 64
    count: 1
  - ID: WDR
    what: Watchdog Reload Value
    kind: Special
    width: 64
    count: 1
  - ID: MEN
    what: Miscellaneous External Notifications
    kind: Special
    width: 1
    count: 16
  - ID: PC
    what: Program Counter
    kind: Control
    width: 64
    count: 1
  - ID: PS
    what: Processing Status
    kind: Special
    width: 1
    count: 64
  - ID: SPS
    what: Shadow Processing Status
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL0
    what: Shadow Processing Status for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL1
    what: Shadow Processing Status for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL2
    what: Shadow Processing Status for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL3
    what: Shadow Processing Status for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: CS
    what: Compute Status
    kind: Special
    width: 1
    count: 64
  - ID: DBA0
    what: Debug Breakpoint Address 0
    kind: Special
    width: 64
    count: 1
  - ID: DBA1
    what: Debug Breakpoint Address 1
    kind: Special
    width: 64
    count: 1
  - ID: DBA2
    what: Debug Breakpoint Address 2
    kind: Special
    width: 64
    count: 1
  - ID: DBA3
    what: Debug Breakpoint Address 3
    kind: Special
    width: 64
    count: 1
  - ID: DWA0
    what: Debug Watchpoint address 0
    kind: Special
    width: 64
    count: 1
  - ID: DWA1
    what: Debug Watchpoint address 1
    kind: Special
    width: 64
    count: 1
  - ID: DWA2
    what: Debug Watchpoint address 2
    kind: Special
    width: 64
    count: 1
  - ID: DWA3
    what: Debug Watchpoint address 3
    kind: Special
    width: 64
    count: 1
  - ID: CSIT
    what: Compute Status arithmetic Interrupt
    kind: Special
    width: 1
    count: 32
  - ID: ES
    what: Exception Syndrome
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL0
    what: Exception Syndrome for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL1
    what: Exception Syndrome for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL2
    what: Exception Syndrome for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL3
    what: Exception Syndrome for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: SID
    what: Coolidge V2, Stream ID
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL0
    what: Coolidge V2, Stream ID for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL1
    what: Coolidge V2, Stream ID for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL2
    what: Coolidge V2, Stream ID for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL3
    what: Coolidge V2, Stream ID for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: IXC
    what: Coolidge V2, Inter-Extension Communications
    kind: Special
    width: 1
    count: 64
  - ID: TEL
    what: TLB Entry Low
    kind: Special
    width: 1
    count: 64
  - ID: TEH
    what: TLB Entry High
    kind: Special
    width: 1
    count: 64
  - ID: TPCM0
    what: Trace PC Message 0
    kind: Special
    width: 64
    count: 1
  - ID: TPCM1
    what: Trace PC Message 1
    kind: Special
    width: 64
    count: 1
  - ID: TPCM2
    what: Trace PC Message 2
    kind: Special
    width: 1
    count: 64
  - ID: TPCMC
    what: Trace PC Message Control
    kind: Special
    width: 1
    count: 64
  - ID: DC
    what: Debug Control
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_0
    what: Debug Control watchpoint/breakpoint 0
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_1
    what: Debug Control watchpoint/breakpoint 1
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_2
    what: Debug Control watchpoint/breakpoint 2
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_3
    what: Debug Control watchpoint/breakpoint 3
    kind: Special
    width: 1
    count: 64
  - ID: SRS
    what: System Register Storage
    kind: Special
    width: 64
    count: 512
  - ID: GRS
    what: General Register Storage
    kind: Register
    width: 64
    count: 64
  - ID: XRS
    what: Extension Register Storage
    kind: Register
    width: 64
    count: 256
  - ID: MEM
    what: Data Memory
    kind: Memory
    width: 8
  - ID: NPC
    what: Program Counter of Next Bundle
    kind: Control
    width: 64
    count: 1
  - ID: TCR
    what: Timer Control Register
    kind: Special
    width: 1
    count: 64
  - ID: PMC
    what: Performance Monitor Control Register
    kind: Special
    width: 1
    count: 64
  - ID: PMC_2
    what: Performance Monitor Control Register 2
    kind: Special
    width: 1
    count: 64
  - ID: SRHPC
    what: Last sequence rupture helper PC when uninferrable
    kind: Special
    width: 64
    count: 1
  - ID: FRCC
    what: Free running cycle counter
    kind: Special
    width: 64
    count: 1
  - ID: PCR
    what: Processing Identification Register
    kind: Special
    width: 1
    count: 64
  - ID: SYO
    what: SYscalls Owners
    kind: Special
    width: 1
    count: 32
  - ID: HTO
    what: Hardware Trap Owners
    kind: Special
    width: 1
    count: 32
  - ID: ITO
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 64
  - ID: ILE
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 32
  - ID: ILL
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 64
  - ID: ILR
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 32
  - ID: IPE
    what: Inter Process Event
    kind: Special
    width: 1
    count: 64
  - ID: DO
    what: Debug Owners
    kind: Special
    width: 1
    count: 32
  - ID: MO
    what: Miscellaneous Owners
    kind: Special
    width: 1
    count: 64
  - ID: PSO
    what: Processor Status register Owners
    kind: Special
    width: 1
    count: 64
  - ID: MMC
    what: Memory Management Control
    kind: Special
    width: 1
    count: 64
  - ID: MES
    what: Memory Error Status
    kind: Special
    width: 1
    count: 64
  - ID: WS
    what: Wake-up Status
    kind: Special
    width: 1
    count: 64
  - ID: TPCC
    what: Coolidge V2, Trace PC Context
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL0
    what: Coolidge V2, Trace PC Context for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL1
    what: Coolidge V2, Trace PC Context for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL2
    what: Coolidge V2, Trace PC Context for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL3
    what: Coolidge V2, Trace PC Context for Privilege Level 3
    kind: Special
    width: 1
    count: 64
Synthetic:
  - ID: COPYD
    what: Copy Double Word
    formats: [ ALU_DWRI ]
    instruction: IORD
    specialize: { "%3": 0 }
    syntax: "%0 %1 = %2"
  - ID: NOTD
    what: Complement Double Word
    formats: [ ALU_DWRI ]
    instruction: EORD
    specialize: { "%3": "-1" }
    properties: { '%0': Bitwise }
    syntax: "%0 %1 = %2"
  - ID: NEGD
    what: Negate Double Word
    formats: [ ALU_DWRI ]
    instruction: SBFD
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: SBMM8
    what: Swapped Bit Matrix Multiplication 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    instruction: SBMM8D
  - ID: SBMMT8
    what: Swapped Bit Matrix Multiplication Transposed 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    instruction: SBMMT8D
  - ID: ORD
    what: Legacy form of IORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: IORD
  - ID: NORD
    what: Legacy form of NIORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: NIORD
  - ID: ORND
    what: Legacy form of IORND
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: IORND
  - ID: XORD
    what: Alias of EORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: EORD
  - ID: NXORD
    what: Alias of NEORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: NEORD
  - ID: ORW
    what: Legacy form of IORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: IORW
  - ID: NORW
    what: Legacy form of NIORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: NIORW
  - ID: ORNW
    what: Legacy form of IORNW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: IORNW
  - ID: XORW
    what: Alias of EORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: EORW
  - ID: NXORW
    what: Alias of NEORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: NEORW
  - ID: ABSD
    what: Absolute Value of Double Word
    formats: [ ALU_DWRI ]
    instruction: ABDD
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGSD
    what: Negate Saturated Double Word
    formats: [ ALU_DWRR.M ]
    instruction: SBFSD
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSSD
    what: Absolute Value Saturated of Double Word
    formats: [ ALU_DWRR.M ]
    instruction: ABDSD
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ZXBD
    what: Zero Extend Byte to Double Word
    formats: [ ALU_WRIW ]
    instruction: ANDW
    specialize: { "%3": "0xFF" }
    syntax: "%0 %1 = %2"
  - ID: SXBD
    what: Sign Extend Byte to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b000111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: ZXHD
    what: Zero Extend Half Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFZ
    specialize: { "%3": "0b001111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: SXHD
    what: Sign Extend Half Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b001111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: ZXWD
    what: Zero Extend Word to Double Word
    formats: [ ALU_WRIW ]
    instruction: ANDW
    specialize: { "%3": "-1" }
    syntax: "%0 %1 = %2"
  - ID: SXWD
    what: Sign Extend Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b011111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: COPYW
    what: Copy Word
    formats: [ ALU_WRIW ]
    instruction: IORW
    specialize: { "%3": 0 }
    syntax: "%0 %1 = %2"
  - ID: NOTW
    what: Complement Word
    formats: [ ALU_WRIW ]
    instruction: EORW
    specialize: { "%3": "-1" }
    properties: { '%0': Bitwise }
    syntax: "%0 %1 = %2"
  - ID: NEGW
    what: Negate Word
    formats: [ ALU_WRIW ]
    instruction: SBFW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGSW
    what: Negate Saturated Word
    formats: [ ALU_WWRR1.W ]
    instruction: SBFSW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSW
    what: Absolute Value of Word
    formats: [ ALU_WRIW ]
    instruction: ABDW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSSW
    what: Absolute Value Saturated of Word
    formats: [ ALU_WWRR0.W ]
    instruction: ABDSW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGWP
    what: Negate Word Pair
    formats: [ ALU_WPWRR0.M ]
    instruction: SBFWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: FSBFWC
    what: Floating-Point Subtract From Word Complex
    class: FPU
    formats: [ MAU_FDDD1 ]
    instruction: FSBFWP
  - ID: FSBFWCP
    what: Floating-Point Subtract From Word Complex Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    instruction: FSBFWQ
  - ID: FSBFDC
    what: Floating-Point Subtract Double Word Complex
    class: FPU
    formats: [ MAU_FQQQ0 ]
    instruction: FSBFDP
  - ID: FADDWC
    what: Floating-Point Add From Word Complex
    class: FPU
    formats: [ MAU_FDDD1 ]
    instruction: FADDWP
  - ID: FADDWCP
    what: Floating-Point Add Word Complex Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    instruction: FADDWQ
  - ID: FADDDC
    what: Floating-Point Add From Double Word Complex
    class: FPU
    formats: [ MAU_FQQQ0 ]
    instruction: FADDDP
  - ID: NEGSWP
    what: Negate Saturated Word Pair
    formats: [ ALU_WPWRR1.M ]
    instruction: SBFSWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSWP
    what: Absolute Value of Word Pair
    formats: [ ALU_WPWRR0.M ]
    instruction: ABDWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSSWP
    what: Absolute Value Saturated of Word Pair
    formats: [ ALU_WPWRR0.M ]
    instruction: ABDSWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGHQ
    what: Negate Word Half Word Quadruple
    formats: [ ALU_HQWRR0.M ]
    instruction: SBFHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGSHQ
    what: Negate Word Half Word Quadruple
    formats: [ ALU_HQWRR1.M ]
    instruction: SBFSHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSHQ
    what: Absolute Value of Half Word Quadruple
    formats: [ ALU_HQWRR0.M ]
    instruction: ABDHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSSHQ
    what: Absolute Value Saturated of Half Quadruple
    formats: [ ALU_HQWRR0.M ]
    instruction: ABDSHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGBO
    what: Negate Word Byte Octuple
    formats: [ ALU_BOWRR0.M ]
    instruction: SBFBO
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGSBO
    what: Negate Word Saturated Byte Octuple
    formats: [ ALU_BOWRR1.M ]
    instruction: SBFSBO
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSBO
    what: Absolute Value of Byte Octuple
    formats: [ ALU_BOWRR0.M ]
    instruction: ABDBO
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSSBO
    what: Absolute Value Saturated of Byte Octuple
    formats: [ ALU_BOWRR0.M ]
    instruction: ABDSBO
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: XMT44D
    what: Extension Matrix Transpose 4x4 Double Words
    formats: [ EXT_XCOPYV ]
    instruction: XCOPYV
    specialize: { "%3" : "1" }
    syntax: "%0 %1 = %2"
  - ID: LORD
    what: Alias of LIORD
    formats: [ ALU_DSWRR ]
    instruction: LIORD
  - ID: LNORD
    what: Alias of LNIORD
    formats: [ ALU_DSWRR ]
    instruction: LNIORD
  - ID: LORW
    what: Alias of LIORW
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    instruction: LIORW
  - ID: LNORW
    what: Alias of LNIORW
    formats: [ ALU_WSWRR, ALU_WSWRR.W ]
    instruction: LNIORW
  - ID: ORRWPD
    what: Legacy form of IORRWPD
    formats: [ ALU_WPRWRR ]
    instruction: IORRWPD
  - ID: ORRHQD
    what: Legacy form of IORRHQD
    formats: [ ALU_HQRWRR ]
    instruction: IORRHQD
  - ID: ORRBOD
    what: Legacy form of IORRBOD
    formats: [ ALU_BORWRR ]
    instruction: IORRBOD
  - ID: XORRWPD
    what: Alias of EORRWPD
    formats: [ ALU_WPRWRR ]
    instruction: EORRWPD
  - ID: XORRHQD
    what: Alias of EORRHQD
    formats: [ ALU_HQRWRR ]
    instruction: EORRHQD
  - ID: XORRBOD
    what: Alias of EORRBOD
    formats: [ ALU_BORWRR ]
    instruction: EORRBOD
  - ID: XORO
    what: Legacy form of XIORO
    formats: [ EXT_XBWO ]
    instruction: XIORO
  - ID: XNORO
    what: Alias of XNIORO
    formats: [ EXT_XBWO ]
    instruction: XNIORO
  - ID: XXORO
    what: Alias of XEORO
    formats: [ EXT_XBWO ]
    instruction: XEORO
  - ID: XNXORO
    what: Alias of XNEORO
    formats: [ EXT_XBWO ]
    instruction: XNEORO
  - ID: XORNO
    what: Alias of XIORNO
    formats: [ EXT_XBWO ]
    instruction: XIORNO
