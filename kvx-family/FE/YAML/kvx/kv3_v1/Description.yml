## Description.yml
Builtin:
## State for Builtins
  - ID: kvx__cs
    declaration: |
      typedef struct {
        unsigned ic: 1;
        unsigned io: 1;
        unsigned dz: 1;
        unsigned ov: 1;
        unsigned un: 1;
        unsigned in: 1;
        unsigned u1: 2;
        unsigned rm: 2;
        unsigned fs: 1;
        unsigned ne: 4;
        unsigned wu: 1;
        unsigned cc: 16;
      } __builtin_kvx_cs_t;
      extern __builtin_kvx_cs_t *__builtin_kvx__cs;
    definition: |
      __builtin_kvx_cs_t *__builtin_kvx__cs = 0;
## ALU Builtins
  - ID: kvx_insf
    prototype: >
      uint64_t __builtin_kvx_insf(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:INSF
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4, stopbit = operand3, bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t operand1 = ((operand2 << startbit) & mask) | (operand1 & ~mask);
      return operand1;
  - ID: kvx_extfz
    prototype: >
      uint64_t __builtin_kvx_extfz(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:EXTFZ
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4, stopbit = operand3, bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t masked = operand2 & mask;
      uint64_t operand1 = masked >> startbit;
      return operand1;
  - ID: kvx_extfs
    prototype: >
      int64_t __builtin_kvx_extfs(uint64_t operand2, unsigned operand3, unsigned operand4);
    instruction: ALU:EXTFS
    operands: [ operand1, operand2, operand3, operand4 ]
    emulation: |
      unsigned startbit = operand4 & 0x1F;
      unsigned stopbit = operand3 & 0x1F;
      unsigned bias = startbit <= stopbit;
      uint64_t mask = (2<<stopbit) - (2-bias<<startbit) + bias - 1;
      uint64_t masked1 = operand2 & mask;
      uint64_t masked2 = operand2 | ~mask;
      uint64_t condition = (mask & ~(mask>>1)) & operand2;
      uint64_t masked = (condition == 0)? masked1: masked2;
      int64_t operand1 = masked >> startbit;
      return operand1;
Convention:
  - ID: regular
    argument: [ R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11 ]
    callee: [ R14, R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31 ]
    caller: [ R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R15, R16, R17, R32, R33, R34, R35, R36, R37, R38, R39, R40, R41, R42, R43, R44, R45, R46, R47, R48, R49, R50, R51, R52, R53, R54, R55, R56, R57, R58, R59, R60, R61, R62, R63 ]
    handler: [ ]
    veneer: [ R16, R17 ]
    frame: [ R14 ]
    global: [ ]
    local: [ R13 ]
    reserved: [ R12, R13 ]
    result: [ R0, R1, R2, R3 ]
    program: [ PC ]
    return: [ RA ]
    stack: [ R12 ]
    static: [ ]
    struct: [ R15 ]
Macro:
  - ID: BCV
    execution: &executionBCV |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBCV |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA2
    execution: &executionBIA2 |
      stage RR:
      new mask = 1;
      new buffer = @2 << 1;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA2 |
      (SEQ
        (WRITE.mask (CONST.1))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.1)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA4
    execution: &executionBIA4 |
      stage RR:
      new mask = 3;
      new buffer = @2 << 2;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA4 |
      (SEQ
        (WRITE.mask (CONST.3))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.2)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA8
    execution: &executionBIA8 |
      stage RR:
      new mask = 7;
      new buffer = @2 << 3;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA8 |
      (SEQ
        (WRITE.mask (CONST.7))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.3)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA16
    execution: &executionBIA16 |
      stage RR:
      new mask = 15;
      new buffer = @2 << 4;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA16 |
      (SEQ
        (WRITE.mask (CONST.15))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.4)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA32
    execution: &executionBIA32 |
      stage RR:
      new mask = 31;
      new buffer = @2 << 5;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA32 |
      (SEQ
        (WRITE.mask (CONST.31))
        (WRITE.buffer
          (SHL (METHOD.%2) (CONST.5)))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BIA64
    execution: &executionBIA64 |
      stage RR:
      new mask = 63;
      new buffer = @2;
      new address = %3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorBIA64 |
      (SEQ
        (WRITE.mask (CONST.63))
        (WRITE.buffer (METHOD.%2))
        (WRITE.address (ACCESS.RR.%3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: RVV
    execution: &executionRVV |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorRVV |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: SET
    execution: &executionSET |
      stage ID:
      new argument2 = %2;
      @Instruction
    behavior: &behaviorSET |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (MACRO.Instruction))
  - ID: GET
    execution: &executionGET |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorGET |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: RSWAP
    execution: &executionRSWAP |
      stage RR:
      new argument2 = %2;
      new argument1 = %1;
      @Instruction
      stage E1:
      %1 = result1;
      %2 = result2;
    behavior: &behaviorRSWAP |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (MACRO.Instruction))
  - ID: DWI
    execution: &executionDWI |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWI |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWR
    execution: &executionDWR |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWR |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWRR
    execution: &executionDWRR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWRR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DWRRM
    execution: &executionDWRRM |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorDWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: DW2RR
    execution: &executionDW2RR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRM
    execution: &executionDW2RRM |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRR1
    execution: &executionDW2RRR1 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRR1 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: DW2RRR1M
    execution: &executionDW2RRR1M |
      stage ID:
      new splat32 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: &behaviorDW2RRR1M |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: CWRR
    execution: &executionCWRR |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorCWRR |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: CWRRM
    execution: &executionCWRRM |
      stage ID:
      new splat32 = %5;
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: &behaviorCWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: CMWRR
    execution: &executionCMWRR |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
    behavior: &behaviorCMWRR |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction))
  - ID: CMWRRM
    execution: &executionCMWRRM |
      stage ID:
      new splat32 = %5;
      new argument4 = %4;
      stage RR:
      new argument3 = splat32? %3<<32|_ZX_32(%3): _SX32(%3);
      new argument2 = %2;
      @Instruction
    behavior: &behaviorCMWRRM |
      (SEQ
        (WRITE.splat32 (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3
          (SELECT
            (I2B (READ.splat32))
            (IOR
              (SHL (ACCESS.RR.%3) (CONST.32))
              (ZX.32 (ACCESS.RR.%3)))
            (SX.32 (ACCESS.RR.%3))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction))
  - ID: XWI
    execution: &executionXWI |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      %1 = result1;
    behavior: &behaviorXWI |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: WZWR
    execution: &executionWZWR |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZWR |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1
          (ZX.32 (READ.result1))))
  - ID: WZWRR
    execution: &executionWZWRR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZWRR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1
          (ZX.32 (READ.result1))))
  - ID: WZW2RR
    execution: &executionWZW2RR |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZW2RR |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1
          (ZX.32 (READ.result1))))
  - ID: WZW2RRR1
    execution: &executionWZW2RRR1 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      stage E1:
      new argument1 = %1;
      @Instruction
      stage E2:
      %1 = _ZX32_(result1);
    behavior: &behaviorWZW2RRR1 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.E1.%1))
        (MACRO.Instruction)
        (COMMIT.E2.%1
          (ZX.32 (READ.result1))))
  - ID: WRSRD
    execution: &executionWRSRD |
      stage ID:
      new silent = %3;
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
      }
      %1 = result1;
    behavior: &behaviorWRSRD |
      (SEQ
        (WRITE.silent (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: WRSF
    execution: &executionWRSF |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage SF:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorWRSF |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.SF.%1
          (READ.result1)))
  - ID: WRE1
    execution: &executionWRE1 |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.DZ |= fdivbyzero();
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorWRE1 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_dz
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1)))))
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_DZ) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.fdivbyzero)
                  (READ.CS_dz))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_ov)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: MOVETD
    execution: &executionMOVETD |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
      CS.XMF = 1;
    behavior: &behaviorMOVETD |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: MOVETQ
    execution: &executionMOVETQ |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
      CS.XMF = 1;
    behavior: &behaviorMOVETQ |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E1.%1 (READ.result1)))
  - ID: FDDE4
    execution: &executionFDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      new argument3 = %3;
      stage RR:
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
      }
      %1 = result1;
    behavior: &behaviorFDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                (READ.CS_io)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDDDDE4
    execution: &executionFDDDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDDDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDDDE4
    execution: &executionFDDDE4 |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFDDDE4 |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FSSS
    execution: &executionFSSS |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFSSS |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FQQDD
    execution: &executionFQQDD |
      stage ID:
      new silent = %5;
      new rounding = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = rounding==7? CS.RM: rounding;
      @Instruction
      stage E4:
      if (silent == 0) {
        CS.IN |= finexact();
        CS.IO |= finvalid();
        CS.OV |= foverflow();
        CS.UN |= funderflow();
      }
      %1 = result1;
    behavior: &behaviorFQQDD |
      (SEQ
        (WRITE.silent (ACCESS.ID.%5))
        (WRITE.rounding (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_in
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (WRITE.CS_ov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
            (WRITE.CS_un
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_in))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io))))
            (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                  (READ.CS_ov))))
            (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_un)))))
          (SKIP))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: LBO
    execution: &executionLBO |
      stage ID:
      new variant = %4;
      new offset = %2;
      stage RR:
      new base = %3;
      new address = base + offset;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLBO |
      (SEQ
        (WRITE.variant (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: FBO
    execution: &executionFBO |
      stage ID:
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
    behavior: &behaviorFBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset))))
  - ID: SBO
    execution: &executionSBO |
      stage ID:
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: ZBO
    execution: &executionZBO |
      stage ID:
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
    behavior: &behaviorZBO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset))))
  - ID: SBOV
    execution: &executionSBOV |
      stage ID:
      new offset = %1;
      new dri = @3;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
    behavior: &behaviorSBOV |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.dri (METHOD.%3))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1))))
  - ID: LBOA
    execution: &executionLBOA |
      stage ID:
      new offset = %2;
      stage RR:
      new base = %3;
      new address = base + offset;
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLBOA |
      (SEQ
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: AABO
    properties: &propertiesAABO { '%0': MemoryEffect, '%1': Offset, '%2': Base, '%3': Stored }
    execution: &executionAABO |
      stage ID:
      new offset = %1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      @Instruction
      stage SR:
      %3 = result3;
    behavior: &behaviorAABO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%3 (READ.result3)))
  - ID: ABO
    execution: &executionABO |
      stage ID:
      new offset = %1;
      new boolcas = 1;
      stage RR:
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      @Instruction
      stage SR:
      %3 = result3;
    behavior: &behaviorABO |
      (SEQ
        (WRITE.offset (ACCESS.ID.%1))
        (WRITE.boolcas (CONST.1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%3 (READ.result3)))
  - ID: LPB
    execution: &executionLPB |
      stage ID:
      new variant = %5;
      new argument4 = %4;
      stage RR:
      new argument2 = %2;
      new address = %3;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLPB |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address (ACCESS.RR.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LPBO
    execution: &executionLPBO |
      stage ID:
      new variant = %6;
      new offset = %5;
      new argument4 = %4;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLPBO |
      (SEQ
        (WRITE.variant (ACCESS.ID.%6))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: FPB
    execution: &executionFPB |
      stage ID:
      new argument3 = %3;
      stage RR:
      new argument1 = %1;
      new address = %2;
      if (scalarcond(argument3, argument1)) {
        @Instruction
      }
    behavior: &behaviorFPB |
      (SEQ
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (IF
          (TEST.scalarcond (READ.argument3) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: FPBO
    execution: &executionFPBO |
      stage ID:
      new argument3 = %3;
      new offset = %4;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      if (scalarcond(argument3, argument1)) {
        @Instruction
      }
    behavior: &behaviorFPBO |
      (SEQ
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.offset (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument3) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: LBOV
    execution: &executionLBOV |
      stage ID:
      new speculate = %4;
      new offset = %2;
      new dri = @1;
      stage RR:
      new base = %3;
      new variant = 0x2 | speculate;
      new address = base + offset;
      stage E1:
      CS.XMF = 1;
      @Instruction
      stage SR:
      %1 = result1;
    behavior: &behaviorLBOV |
      (SEQ
        (WRITE.speculate (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.SR.%1 (READ.result1)))
  - ID: LVSBO
    execution: &executionLVSBO |
      stage ID:
      new qindex = %5;
      new speculate = %4;
      new offset = %2;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new variant = 0x2 | speculate;
      new address = base + offset;
      stage E1:
      CS.XMF = 1;
      @Instruction
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      stage SR:
      %1:0 = insert_64(%1:0, result1_0, qindex);
      %1:1 = insert_64(%1:1, result1_1, qindex);
      %1:2 = insert_64(%1:2, result1_2, qindex);
      %1:3 = insert_64(%1:3, result1_3, qindex);
    behavior: &behaviorLVSBO |
      (SEQ
        (WRITE.qindex (ACCESS.ID.%5))
        (WRITE.speculate (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%2))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.offset)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.SR.%1:0 (APPLY.insert_64 (ACCESS.E3.%1:0) (READ.result1_0) (READ.qindex)))
        (COMMIT.SR.%1:1 (APPLY.insert_64 (ACCESS.E3.%1:1) (READ.result1_1) (READ.qindex)))
        (COMMIT.SR.%1:2 (APPLY.insert_64 (ACCESS.E3.%1:2) (READ.result1_2) (READ.qindex)))
        (COMMIT.SR.%1:3 (APPLY.insert_64 (ACCESS.E3.%1:3) (READ.result1_3) (READ.qindex))))
  - ID: LPBV
    execution: &executionLPBV |
      stage ID:
      new speculate = %5;
      new argument4 = %4;
      new dri = @1;
      stage RR:
      new argument2 = %2;
      new address = %3;
      new variant = 0x2 | speculate;
      stage E1:
      CS.XMF = 1;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage SR:
        %1 = result1;
      }
    behavior: &behaviorLPBV |
      (SEQ
        (WRITE.speculate (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address (ACCESS.RR.%3))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LPBOV
    execution: &executionLPBOV |
      stage ID:
      new speculate = %6;
      new offset = %5;
      new argument4 = %4;
      new dri = @1;
      stage RR:
      new base = %3;
      new variant = 0x2 | speculate;
      new argument2 = %2;
      new address = base + offset;
      stage E1:
      CS.XMF = 1;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage SR:
        %1 = result1;
      }
    behavior: &behaviorLPBOV |
      (SEQ
        (WRITE.speculate (ACCESS.ID.%6))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LPBT
    execution: &executionLPBT |
      stage ID:
      new qindex = %6;
      new speculate = %5;
      new argument4 = %4;
      new dri = @1 << 2;
      stage RR:
      new argument2 = %2;
      new variant = 0x2 | speculate;
      new address = %3;
      stage E1:
      CS.XMF = 1;
      if (scalarcond(argument4, argument2)) {
        @Instruction
        new result1_0 = _ZX_64(result1);
        new result1_1 = result1 >> 64;
        new result1_2 = result1 >> 128;
        new result1_3 = result1 >> 192;
      stage SR:
        %1:0 = insert_64(%1:0, result1_0, qindex);
        %1:1 = insert_64(%1:1, result1_1, qindex);
        %1:2 = insert_64(%1:2, result1_2, qindex);
        %1:3 = insert_64(%1:3, result1_3, qindex);
      }
    behavior: &behaviorLPBT |
      (SEQ
        (WRITE.qindex (ACCESS.ID.%6))
        (WRITE.speculate (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.address (ACCESS.RR.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (WRITE.result1_0 (ZX.64 (READ.result1)))
            (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
            (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
            (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
            (COMMIT.SR.%1:0 (APPLY.insert_64 (ACCESS.E3.%1:0) (READ.result1_0) (READ.qindex)))
            (COMMIT.SR.%1:1 (APPLY.insert_64 (ACCESS.E3.%1:1) (READ.result1_1) (READ.qindex)))
            (COMMIT.SR.%1:2 (APPLY.insert_64 (ACCESS.E3.%1:2) (READ.result1_2) (READ.qindex)))
            (COMMIT.SR.%1:3 (APPLY.insert_64 (ACCESS.E3.%1:3) (READ.result1_3) (READ.qindex))))
          (CANCEL)))
  - ID: LPBOT
    execution: &executionLPBOT |
      stage ID:
      new qindex = %7;
      new speculate = %6;
      new offset = %5;
      new argument4 = %4;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new variant = 0x2 | speculate;
      new address = base + offset;
      stage E1:
      CS.XMF = 1;
      if (scalarcond(argument4, argument2)) {
        @Instruction
        new result1_0 = _ZX_64(result1);
        new result1_1 = result1 >> 64;
        new result1_2 = result1 >> 128;
        new result1_3 = result1 >> 192;
      stage SR:
        %1:0 = insert_64(%1:0, result1_0, qindex);
        %1:1 = insert_64(%1:1, result1_1, qindex);
        %1:2 = insert_64(%1:2, result1_2, qindex);
        %1:3 = insert_64(%1:3, result1_3, qindex);
      }
    behavior: &behaviorLPBOT |
      (SEQ
        (WRITE.qindex (ACCESS.ID.%7))
        (WRITE.speculate (ACCESS.ID.%6))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (WRITE.result1_0 (ZX.64 (READ.result1)))
            (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
            (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
            (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
            (COMMIT.SR.%1:0 (APPLY.insert_64 (ACCESS.E3.%1:0) (READ.result1_0) (READ.qindex)))
            (COMMIT.SR.%1:1 (APPLY.insert_64 (ACCESS.E3.%1:1) (READ.result1_1) (READ.qindex)))
            (COMMIT.SR.%1:2 (APPLY.insert_64 (ACCESS.E3.%1:2) (READ.result1_2) (READ.qindex)))
            (COMMIT.SR.%1:3 (APPLY.insert_64 (ACCESS.E3.%1:3) (READ.result1_3) (READ.qindex))))
          (CANCEL)))
  - ID: LBIV
    execution: &executionLBIV |
      stage ID:
      new speculate = %5;
      new doscale = %4;
      new dri = @1;
      stage RR:
      new base = %3;
      new index = %2;
      new variant = 0x2 | speculate;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      CS.XMF = 1;
      @Instruction
      stage SR:
      %1 = result1;
    behavior: &behaviorLBIV |
      (SEQ
        (WRITE.speculate (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%1))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (COMMIT.SR.%1 (READ.result1)))
  - ID: LVSBI
    execution: &executionLVSBI |
      stage ID:
      new qindex = %6;
      new speculate = %5;
      new doscale = %4;
      new dri = @1 << 2;
      stage RR:
      new base = %3;
      new index = %2;
      new variant = 0x2 | speculate;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      CS.XMF = 1;
      @Instruction
      new result1_0 = _ZX_64(result1);
      new result1_1 = result1 >> 64;
      new result1_2 = result1 >> 128;
      new result1_3 = result1 >> 192;
      stage SR:
      %1:0 = insert_64(%1:0, result1_0, qindex);
      %1:1 = insert_64(%1:1, result1_1, qindex);
      %1:2 = insert_64(%1:2, result1_2, qindex);
      %1:3 = insert_64(%1:3, result1_3, qindex);
    behavior: &behaviorLVSBI |
      (SEQ
        (WRITE.qindex (ACCESS.ID.%6))
        (WRITE.speculate (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (SHL (METHOD.%1) (CONST.2)))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.variant
          (IOR
            (CONST.0x2)
            (READ.speculate)))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (MACRO.Instruction)
        (WRITE.result1_0 (ZX.64 (READ.result1)))
        (WRITE.result1_1 (SHR (READ.result1) (CONST.64)))
        (WRITE.result1_2 (SHR (READ.result1) (CONST.128)))
        (WRITE.result1_3 (SHR (READ.result1) (CONST.192)))
        (COMMIT.SR.%1:0 (APPLY.insert_64 (ACCESS.E3.%1:0) (READ.result1_0) (READ.qindex)))
        (COMMIT.SR.%1:1 (APPLY.insert_64 (ACCESS.E3.%1:1) (READ.result1_1) (READ.qindex)))
        (COMMIT.SR.%1:2 (APPLY.insert_64 (ACCESS.E3.%1:2) (READ.result1_2) (READ.qindex)))
        (COMMIT.SR.%1:3 (APPLY.insert_64 (ACCESS.E3.%1:3) (READ.result1_3) (READ.qindex))))
  - ID: SPB
    execution: &executionSPB |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSPB |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SPBO
    execution: &executionSPBO |
      stage ID:
      new argument4 = %4;
      new offset = %5;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSPBO |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: ZPB
    execution: &executionZPB |
      stage ID:
      new argument3 = %3;
      stage RR:
      new argument1 = %1;
      new address = %2;
      if (scalarcond(argument3, argument1)) {
        @Instruction
      }
    behavior: &behaviorZPB |
      (SEQ
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (IF
          (TEST.scalarcond (READ.argument3) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: ZPBO
    execution: &executionZPBO |
      stage ID:
      new argument3 = %3;
      new offset = %4;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      if (scalarcond(argument3, argument1)) {
        @Instruction
      }
    behavior: &behaviorZPBO |
      (SEQ
        (WRITE.argument3 (ACCESS.ID.%3))
        (WRITE.offset (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument3) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SPBV
    execution: &executionSPBV |
      stage ID:
      new argument4 = %4;
      new dri = @3;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSPBV |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%3))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: SPBOV
    execution: &executionSPBOV |
      stage ID:
      new argument4 = %4;
      new offset = %5;
      new dri = @3;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
      if (scalarcond(argument4, argument1)) {
        @Instruction
      }
    behavior: &behaviorSPBOV |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.dri (METHOD.%3))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (MACRO.Instruction)
          (CANCEL)))
  - ID: LPBA
    execution: &executionLPBA |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument2 = %2;
      new address = %3;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLPBA |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address (ACCESS.RR.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: LPBOA
    execution: &executionLPBOA |
      stage ID:
      new offset = %5;
      new argument4 = %4;
      stage RR:
      new base = %3;
      new argument2 = %2;
      new address = base + offset;
      if (scalarcond(argument4, argument2)) {
        @Instruction
      stage CR:
        %1 = result1;
      }
    behavior: &behaviorLPBOA |
      (SEQ
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument2))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.CR.%1 (READ.result1)))
          (CANCEL)))
  - ID: AAPB
    execution: &executionAAPB |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
      stage SR:
        @Instruction
        %3 = result3;
      }
    behavior: &behaviorAAPB |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%3 (READ.result3)))
          (CANCEL)))
  - ID: AAPBO
    execution: &executionAAPBO |
      stage ID:
      new argument4 = %4;
      new offset = %5;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
      stage SR:
        @Instruction
        %3 = result3;
      }
    behavior: &behaviorAAPBO |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%3 (READ.result3)))
          (CANCEL)))
  - ID: APB
    execution: &executionAPB |
      stage ID:
      new argument4 = %4;
      new boolcas = 1;
      stage RR:
      new argument1 = %1;
      new address = %2;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
      stage SR:
        @Instruction
        %3 = result3;
      }
    behavior: &behaviorAPB |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.boolcas (CONST.1))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.address (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%3 (READ.result3)))
          (CANCEL)))
  - ID: APBO
    execution: &executionAPBO |
      stage ID:
      new argument4 = %4;
      new offset = %5;
      new boolcas = 1;
      stage RR:
      new argument1 = %1;
      new base = %2;
      new address = base + offset;
      stage E1:
      new argument3 = %3;
      if (scalarcond(argument4, argument1)) {
      stage SR:
        @Instruction
        %3 = result3;
      }
    behavior: &behaviorAPBO |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.offset (ACCESS.ID.%5))
        (WRITE.boolcas (CONST.1))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.argument3 (ACCESS.E1.%3))
        (WRITE.address
          (ADD (READ.base) (READ.offset)))
        (IF
          (TEST.scalarcond (READ.argument4) (READ.argument1))
          (SEQ
            (MACRO.Instruction)
            (COMMIT.SR.%3 (READ.result3)))
          (CANCEL)))
  - ID: LBI
    execution: &executionLBI |
      stage ID:
      new variant = %5;
      new doscale = %4;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLBI |
      (SEQ
        (WRITE.variant (ACCESS.ID.%5))
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: FBI
    execution: &executionFBI |
      stage ID:
      new index = %1;
      stage RR:
      new base = %2;
      new address = base + index;
    behavior: &behaviorFBI |
      (SEQ
        (WRITE.index (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.index))))
  - ID: SBI
    execution: &executionSBI |
      stage ID:
      new doscale = %4;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
    behavior: &behaviorSBI |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3)))
  - ID: ZBI
    execution: &executionZBI |
      stage ID:
      new index = %1;
      stage RR:
      new base = %2;
      new address = base + index;
    behavior: &behaviorZBI |
      (SEQ
        (WRITE.index (ACCESS.ID.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.address
          (ADD
            (READ.base)
            (READ.index))))
  - ID: SBIV
    execution: &executionSBIV |
      stage ID:
      new doscale = %4;
      new dri = @3;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
      CS.XMF = 1;
    behavior: &behaviorSBIV |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.dri (METHOD.%3))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1))))
  - ID: LBIA
    execution: &executionLBIA |
      stage ID:
      new doscale = %4;
      stage RR:
      new base = %3;
      new index = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      @Instruction
      stage CR:
      %1 = result1;
    behavior: &behaviorLBIA |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.base (ACCESS.RR.%3))
        (WRITE.index (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (MACRO.Instruction)
        (COMMIT.CR.%1 (READ.result1)))
  - ID: AABI
    execution: &executionAABI |
      stage ID:
      new doscale = %4;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
      @Instruction
      stage SR:
      %3 = result3;
    behavior: &behaviorAABI |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%3 (READ.result3)))
  - ID: ABI
    execution: &executionABI |
      stage ID:
      new doscale = %4;
      new boolcas = 1;
      stage RR:
      new index = %1;
      new base = %2;
      new scaling = doscale ? %0.MemorySize : 1;
      new address = base + (index * scaling);
      stage E1:
      new argument3 = %3;
      @Instruction
      stage SR:
      %3 = result3;
    behavior: &behaviorABI |
      (SEQ
        (WRITE.doscale (ACCESS.ID.%4))
        (WRITE.boolcas (CONST.1))
        (WRITE.index (ACCESS.RR.%1))
        (WRITE.base (ACCESS.RR.%2))
        (WRITE.scaling
          (SELECT
            (I2B (READ.doscale))
            (PROPERTY.MemorySize.%0)
            (CONST.1)))
        (WRITE.address
          (ADD
            (READ.base)
            (MUL
              (READ.index)
              (READ.scaling))))
        (WRITE.argument3 (ACCESS.E1.%3))
        (MACRO.Instruction)
        (COMMIT.SR.%3 (READ.result3)))
  - ID: FDDDIE4
    execution: &executionFDDDIE4 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = CS.RM;
      @Instruction
      stage E4:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: &behaviorFDDDIE4 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
        (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FDDIE4
    execution: &executionFDDIE4 |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = CS.RM;
      @Instruction
      stage E4:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: &behaviorFDDIE4 |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
        (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FQQDI
    execution: &executionFQQDI |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new argument1 = %1;
      new RM = CS.RM;
      @Instruction
      stage E4:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: &behaviorFQQDI |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.RM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
        (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (COMMIT.E4.%1 (READ.result1)))
  - ID: FQDI
    execution: &executionFQDI |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      new RM = CS.RM;
      @Instruction
      stage E4:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: &behaviorFQDI |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.RM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_RM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_OV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_UN) (CONST.1)))))
        (STORE.E4 (AGGL.CS (CONST.CS_IN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E4 (AGGL.CS (CONST.CS_OV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E4 (AGGL.CS (CONST.CS_UN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (COMMIT.E4.%1 (READ.result1)))
Format:
  ## BCU: steering=00
  - ID: BCU_NOB
    what: BCU Opcode Error
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "000"
      - bcucode7: "000000"
      - tcacode2: "0000"
      - tcacode5: "00"
      - bcucode6: { ERROP: "000000" }
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    scheduling: ALL
  - ID: BCU_PCREL11
    what: BCU PCREL11 Dummy
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { PCREL11: "00" }
      - ccbcomp: "0000"
      - pcrel11: "-----------"
      - registerY: "000000"
      - registerZ: "______"
    encoding: simple
    operands: [ pcrel11 ]
    syntax: "%0 %1"
    scheduling: ALL
    execution:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.RR.%1))
  - ID: BCU_PCREL11.X
    what: BCU PCREL Dummy
    fields2:
      - parallel2: "-"
    fields1:
      - steerimx: "00"
      - exunum2: "00"
      - upper27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "00"
      - bcucode1: { PCREL38: "00" }
      - ccbcomp: "0000"
      - lower11: "-----------"
      - registerY: "000000"
      - registerZ: "______"
    encoding: double
    operands: [ { pcrel38: [ upper27, lower11 ] } ]
    syntax: "%0 %1"
    scheduling: ALL
    execution:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.RR.%1))
  - ID: BCU_AOEOI
    what: BCU Align Octuple Word From Coprocessor Shifted Even Odd Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { ALIGNO: "000" }
      - registerN: "----"
      - bcucode4: "10"
      - registerBe: "-----"
      - exubit12: "1"
      - registerCo: "-----"
      - exubit6: "0"
      - byteshift: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { xwordoRegE: registerBe }, { xwordoRegO: registerCo }, { unsigned6: byteshift } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_TINY_AUXW_CRRP
    execution: &executionMFS |
      stage ID:
      new argument4 = %4;
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1;
    behavior: &behaviorMFS |
      (SEQ
        (WRITE.argument4 (ACCESS.ID.%4))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1)))
  - ID: BCU_AOEOR
    what: BCU Align Octuple Word From Coprocessor Shifted Even Odd Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { ALIGNO: "000" }
      - registerN: "----"
      - bcucode4: "10"
      - registerBe: "-----"
      - exubit12: "1"
      - registerCo: "-----"
      - exubit6: "1"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { xwordoRegE: registerBe }, { xwordoRegO: registerCo }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AOOEI
    what: BCU Align Octuple Word From Coprocessor Shifted Odd Even Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { ALIGNO: "000" }
      - registerN: "----"
      - bcucode4: "11"
      - registerBo: "-----"
      - exubit12: "1"
      - registerCe: "-----"
      - exubit6: "0"
      - byteshift: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { xwordoRegO: registerBo }, { xwordoRegE: registerCe }, { unsigned6: byteshift } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AOOER
    what: BCU Align Octuple Word From Coprocessor Shifted Odd Even Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { ALIGNO: "000" }
      - registerN: "----"
      - bcucode4: "11"
      - registerBo: "-----"
      - exubit12: "1"
      - registerCe: "-----"
      - exubit6: "1"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { xwordoRegO: registerBo }, { xwordoRegE: registerCe }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_TINY_AUXW_CRRP
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AVEOI
    what: BCU Align Vector Even Odd Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { ALIGNV: "00" }
      - tcacode1: "001"
      - registerA: "------"
      - registerBe: "-----"
      - exubit12: "0"
      - registerCo: "-----"
      - exubit6: "0"
      - byteshift: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoRegE: registerBe }, { xwordoRegO: registerCo }, { unsigned6: byteshift } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AVEOR
    what: BCU Align Vector Even Odd Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { ALIGNV: "00" }
      - tcacode1: "001"
      - registerA: "------"
      - registerBe: "-----"
      - exubit12: "0"
      - registerCo: "-----"
      - exubit6: "1"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoRegE: registerBe }, { xwordoRegO: registerCo }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AVOEI
    what: BCU Align Vector Odd Even Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { ALIGNV: "00" }
      - tcacode1: "001"
      - registerA: "------"
      - registerBo: "-----"
      - exubit12: "1"
      - registerCe: "-----"
      - exubit6: "0"
      - byteshift: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoRegO: registerBo }, { xwordoRegE: registerCe }, { unsigned6: byteshift } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: BCU_AVOER
    what: BCU Align Vector Odd Even Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { ALIGNV: "00" }
      - tcacode1: "001"
      - registerA: "------"
      - registerBo: "-----"
      - exubit12: "1"
      - registerCe: "-----"
      - exubit6: "1"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoRegO: registerBo }, { xwordoRegE: registerCe }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: BCU_CRRP_CRWL_CRWH
    execution: *executionMFS
    behavior: *behaviorMFS
  - ID: EXT_MMABW0
    what: Extension Matrix Multiply-Add Bytes to Words 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMMA484BW: "010" }
      - registerAp: "-----"
      - exubit18: "0"
      - registerBp: "-----"
      - exubit12: "0"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: &executionMMA484BW |
      stage RR:
      new argument4 = %4;
      new argument4_0 = _ZX_64(argument4);
      new argument4_1 = _ZX_64(argument4 >> 64);
      new argument4_2 = _ZX_64(argument4 >> 128);
      new argument4_3 = _ZX_64(argument4 >> 192);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
    behavior: &behaviorMMA484BW |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (ZX.64 (READ.argument4)))
        (WRITE.argument4_1 (ZX.64 (SHR (READ.argument4) (CONST.64))))
        (WRITE.argument4_2 (ZX.64 (SHR (READ.argument4) (CONST.128))))
        (WRITE.argument4_3 (ZX.64 (SHR (READ.argument4) (CONST.192))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1)))
  - ID: EXT_MMABW1
    what: Extension Matrix Multiply-Add Bytes to Words 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMMA484UBW: "010" }
      - registerAp: "-----"
      - exubit18: "0"
      - registerBp: "-----"
      - exubit12: "1"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_MMABW2
    what: Extension Matrix Multiply-Add Bytes to Words 2
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMMA484SUBW: "010" }
      - registerAp: "-----"
      - exubit18: "1"
      - registerBp: "-----"
      - exubit12: "0"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_MMABW3
    what: Extension Matrix Multiply-Add Bytes to Words 3
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMMA484USBW: "010" }
      - registerAp: "-----"
      - exubit18: "1"
      - registerBp: "-----"
      - exubit12: "1"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordxReg: registerAp }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: *executionMMA484BW
    behavior: *behaviorMMA484BW
  - ID: EXT_FMMAHW0
    what: Extension Floating-Point Matrix Multiply-Add Half Words to Words 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { FMMA242HW0: "011" }
      - registerA0: "-----"
      - exubit18: "0"
      - registerBp: "-----"
      - exubit12: "0"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordqReg0M4: registerA0 }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage RR:
      new argument4 = %4;
      new argument4_0 = _ZX_64(argument4);
      new argument4_1 = _ZX_64(argument4 >> 64);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument2_0 = %2:0;
      new argument2_0_0 = argument2_0.32[0];
      new argument2_0_1 = argument2_0.32[1];
      new argument2_1_0 = argument2_0.32[2];
      new argument2_1_1 = argument2_0.32[3];
      new XRM = CS.XRM;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E5:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (ZX.64 (READ.argument4)))
        (WRITE.argument4_1 (ZX.64 (SHR (READ.argument4) (CONST.64))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (READ.32[0].argument2_0))
        (WRITE.argument2_0_1 (READ.32[1].argument2_0))
        (WRITE.argument2_1_0 (READ.32[2].argument2_0))
        (WRITE.argument2_1_1 (READ.32[3].argument2_0))
        (WRITE.XRM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E5.%1 (READ.result1)))
  - ID: EXT_FMMAHW1
    what: Extension Floating-Point Matrix Multiply-Add Half Words to Words 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { FMMA242HW1: "011" }
      - registerA1: "-----"
      - exubit18: "0"
      - registerBp: "-----"
      - exubit12: "1"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordqReg1M4: registerA1 }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage RR:
      new argument4 = %4;
      new argument4_0 = _ZX_64(argument4);
      new argument4_1 = _ZX_64(argument4 >> 64);
      new argument3 = %3;
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_0 = %2:0;
      new argument2_2_0 = _ZX_32(argument2_0 >> 128);
      new argument2_2_1 = _ZX_32(argument2_0 >> 160);
      new argument2_3_0 = _ZX_32(argument2_0 >> 192);
      new argument2_3_1 = _ZX_32(argument2_0 >> 224);
      new XRM = CS.XRM;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E5:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (ZX.64 (READ.argument4)))
        (WRITE.argument4_1 (ZX.64 (SHR (READ.argument4) (CONST.64))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_2_0 (ZX.32 (SHR (READ.argument2_0) (CONST.128))))
        (WRITE.argument2_2_1 (ZX.32 (SHR (READ.argument2_0) (CONST.160))))
        (WRITE.argument2_3_0 (ZX.32 (SHR (READ.argument2_0) (CONST.192))))
        (WRITE.argument2_3_1 (ZX.32 (SHR (READ.argument2_0) (CONST.224))))
        (WRITE.XRM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E5.%1 (READ.result1)))
  - ID: EXT_FMMAHW2
    what: Extension Floating-Point Matrix Multiply-Add Half Words to Words 2
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { FMMA242HW2: "011" }
      - registerA2: "-----"
      - exubit18: "1"
      - registerBp: "-----"
      - exubit12: "0"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordqReg2M4: registerA2 }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage RR:
      new argument4 = %4;
      new argument4_2 = _ZX_64(argument4 >> 128);
      new argument4_3 = _ZX_64(argument4 >> 192);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument2_1 = %2:1;
      new argument2_0_2 = argument2_1.32[0];
      new argument2_0_3 = argument2_1.32[1];
      new argument2_1_2 = argument2_1.32[2];
      new argument2_1_3 = argument2_1.32[3];
      new XRM = CS.XRM;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E5:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_2 (ZX.64 (SHR (READ.argument4) (CONST.128))))
        (WRITE.argument4_3 (ZX.64 (SHR (READ.argument4) (CONST.192))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_0_2 (READ.32[0].argument2_1))
        (WRITE.argument2_0_3 (READ.32[1].argument2_1))
        (WRITE.argument2_1_2 (READ.32[2].argument2_1))
        (WRITE.argument2_1_3 (READ.32[3].argument2_1))
        (WRITE.XRM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E5.%1 (READ.result1)))
  - ID: EXT_FMMAHW3
    what: Extension Floating-Point Matrix Multiply-Add Half Words to Words 3
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { FMMA242HW3: "011" }
      - registerA3: "-----"
      - exubit18: "1"
      - registerBp: "-----"
      - exubit12: "1"
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordqReg3M4: registerA3 }, { xwordxReg: registerBp }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage RR:
      new argument4 = %4;
      new argument4_2 = _ZX_64(argument4 >> 128);
      new argument4_3 = _ZX_64(argument4 >> 192);
      new argument3 = %3;
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_1 = %2:1;
      new argument2_2_2 = _ZX_32(argument2_1 >> 128);
      new argument2_2_3 = _ZX_32(argument2_1 >> 160);
      new argument2_3_2 = _ZX_32(argument2_1 >> 192);
      new argument2_3_3 = _ZX_32(argument2_1 >> 224);
      new XRM = CS.XRM;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E5:
      CS.IN |= finexact();
      CS.IO |= finvalid();
      CS.OV |= foverflow();
      CS.UN |= funderflow();
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_2 (ZX.64 (SHR (READ.argument4) (CONST.128))))
        (WRITE.argument4_3 (ZX.64 (SHR (READ.argument4) (CONST.192))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2_2 (ZX.32 (SHR (READ.argument2_1) (CONST.128))))
        (WRITE.argument2_2_3 (ZX.32 (SHR (READ.argument2_1) (CONST.160))))
        (WRITE.argument2_3_2 (ZX.32 (SHR (READ.argument2_1) (CONST.192))))
        (WRITE.argument2_3_3 (ZX.32 (SHR (READ.argument2_1) (CONST.224))))
        (WRITE.XRM
          (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2)))))
        (MACRO.Instruction)
        (WRITE.CS_in
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
        (WRITE.CS_io
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
        (WRITE.CS_ov
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
        (WRITE.CS_un
          (F2I.1 (LOAD.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finexact)
              (READ.CS_in))))
        (STORE.E5 (AGGL.CS (CONST.CS_XIO) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.finvalid)
              (READ.CS_io))))
        (STORE.E5 (AGGL.CS (CONST.CS_XOV) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.foverflow)
              (READ.CS_ov))))
        (STORE.E5 (AGGL.CS (CONST.CS_XUN) (CONST.1))
          (I2F.1
            (IOR
              (APPLY.funderflow)
              (READ.CS_un))))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E5.%1 (READ.result1)))
  - ID: EXT_MMAHBD0
    what: Extension Matrix Multiply-Add Half Words by Bytes to Double Words 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerAq: "----"
      - tcacode3: "00"
      - registerBq: "----"
      - tcacode5: { "[ MMA444HBD0, MMA444UHBD0, MMA444SUHBD0, MMA444USHBD0 ]": "00..11" }
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordvReg: registerBq }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: &executionMMAHBD0 |
      stage RR:
      new argument4 = %4;
      new argument4_0 = argument4.32[0];
      new argument4_1 = argument4.32[2];
      new argument4_2 = _ZX_32(argument4 >> 128);
      new argument4_3 = _ZX_32(argument4 >> 192);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: &behaviorMMAHBD0 |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (READ.32[0].argument4))
        (WRITE.argument4_1 (READ.32[2].argument4))
        (WRITE.argument4_2 (ZX.32 (SHR (READ.argument4) (CONST.128))))
        (WRITE.argument4_3 (ZX.32 (SHR (READ.argument4) (CONST.192))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_MMAHBD1
    what: Extension Matrix Multiply-Add Half Words by Bytes to Double Words 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerAq: "----"
      - tcacode3: "01"
      - registerBq: "----"
      - tcacode5: { "[ MMA444HBD1, MMA444UHBD1, MMA444SUHBD1, MMA444USHBD1 ]": "00..11" }
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordvReg: registerBq }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: &executionMMAHBD1 |
      stage RR:
      new argument4 = %4;
      new argument4_0 = argument4.32[1];
      new argument4_1 = argument4.32[3];
      new argument4_2 = _ZX_32(argument4 >> 160);
      new argument4_3 = _ZX_32(argument4 >> 224);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: &behaviorMMAHBD1 |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (READ.32[1].argument4))
        (WRITE.argument4_1 (READ.32[3].argument4))
        (WRITE.argument4_2 (ZX.32 (SHR (READ.argument4) (CONST.160))))
        (WRITE.argument4_3 (ZX.32 (SHR (READ.argument4) (CONST.224))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_MMAHD
    what: Extension Matrix Multiply-Add Half Words to Double Words
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "100"
      - registerAq: "----"
      - tcacode3: "10"
      - registerBq: "----"
      - tcacode5: { "[ MMA444HD, MMA444UHD, MMA444SUHD, MMA444USHD ]": "00..11" }
      - registerC: "------"
      - registerD: "------"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordvReg: registerBq }, { xwordoReg: registerC }, { xwordoReg: registerD } ]
    syntax: "%0 %1 = %2, %3, %4"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: &executionMMAHD |
      stage RR:
      new argument4 = %4;
      new argument4_0 = _ZX_64(argument4);
      new argument4_1 = _ZX_64(argument4 >> 64);
      new argument4_2 = _ZX_64(argument4 >> 128);
      new argument4_3 = _ZX_64(argument4 >> 192);
      new argument3 = %3;
      new argument3_0 = _ZX_64(argument3);
      new argument3_1 = _ZX_64(argument3 >> 64);
      new argument3_2 = _ZX_64(argument3 >> 128);
      new argument3_3 = _ZX_64(argument3 >> 192);
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: &behaviorMMAHD |
      (SEQ
        (WRITE.argument4 (ACCESS.RR.%4))
        (WRITE.argument4_0 (ZX.64 (READ.argument4)))
        (WRITE.argument4_1 (ZX.64 (SHR (READ.argument4) (CONST.64))))
        (WRITE.argument4_2 (ZX.64 (SHR (READ.argument4) (CONST.128))))
        (WRITE.argument4_3 (ZX.64 (SHR (READ.argument4) (CONST.192))))
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument3_0 (ZX.64 (READ.argument3)))
        (WRITE.argument3_1 (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.argument3_2 (ZX.64 (SHR (READ.argument3) (CONST.128))))
        (WRITE.argument3_3 (ZX.64 (SHR (READ.argument3) (CONST.192))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_MTD
    what: Extension Matrix Transpose Double Words
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { XMT44D: "100" }
      - registerAq: "----"
      - tcacode3: "11"
      - registerBq: "----"
      - tcacode5: "00"
      - registerC: "______"
      - registerD: "______"
    encoding: simple
    operands: [ { xwordvReg: registerAq }, { xwordvReg: registerBq } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage RR:
      new argument2_0 = %2:0;
      new argument2_1 = %2:1;
      new argument2_2 = %2:2;
      new argument2_3 = %2:3;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1:0 = result1_0;
      %1:1 = result1_1;
      %1:2 = result1_2;
      %1:3 = result1_3;
    behavior: |
      (SEQ
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1:0 (READ.result1_0))
        (COMMIT.E3.%1:1 (READ.result1_1))
        (COMMIT.E3.%1:2 (READ.result1_2))
        (COMMIT.E3.%1:3 (READ.result1_3)))
  - ID: EXT_CDHVL
    what: Extension Convert Double Word to Half Word Vector 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVDHV0: "101" }
      - registerAE: "------"
      - registerBq: "----"
      - tcacode5: "00"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordqRegE: registerAE }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_6(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_0_0 = _ZX_64(argument2_0);
      new argument2_1_0 = _ZX_64(argument2_0 >> 64);
      new argument2_1 = %2:1;
      new argument2_0_1 = _ZX_64(argument2_1);
      new argument2_1_1 = _ZX_64(argument2_1 >> 64);
      new argument2_2 = %2:2;
      new argument2_0_2 = _ZX_64(argument2_2);
      new argument2_1_2 = _ZX_64(argument2_2 >> 64);
      new argument2_3 = %2:3;
      new argument2_0_3 = _ZX_64(argument2_3);
      new argument2_1_3 = _ZX_64(argument2_3 >> 64);
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = (result1_1 << 64) | _ZX_64(result1_0);
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.6 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (ZX.64 (READ.argument2_0)))
        (WRITE.argument2_1_0 (ZX.64 (SHR (READ.argument2_0) (CONST.64))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_0_1 (ZX.64 (READ.argument2_1)))
        (WRITE.argument2_1_1 (ZX.64 (SHR (READ.argument2_1) (CONST.64))))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_0_2 (ZX.64 (READ.argument2_2)))
        (WRITE.argument2_1_2 (ZX.64 (SHR (READ.argument2_2) (CONST.64))))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_0_3 (ZX.64 (READ.argument2_3)))
        (WRITE.argument2_1_3 (ZX.64 (SHR (READ.argument2_3) (CONST.64))))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1
          (IOR
            (SHL (READ.result1_1) (CONST.64))
            (ZX.64 (READ.result1_0)))))
  - ID: EXT_CDHVH
    what: Extension Convert Double Word to Half Word Vector 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVDHV1: "101" }
      - registerAO: "------"
      - registerBq: "----"
      - tcacode5: "01"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xwordqRegO: registerAO }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_6(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_2_0 = _ZX_64(argument2_0 >> 128);
      new argument2_3_0 = _ZX_64(argument2_0 >> 192);
      new argument2_1 = %2:1;
      new argument2_2_1 = _ZX_64(argument2_1 >> 128);
      new argument2_3_1 = _ZX_64(argument2_1 >> 192);
      new argument2_2 = %2:2;
      new argument2_2_2 = _ZX_64(argument2_2 >> 128);
      new argument2_3_2 = _ZX_64(argument2_2 >> 192);
      new argument2_3 = %2:3;
      new argument2_2_3 = _ZX_64(argument2_3 >> 128);
      new argument2_3_3 = _ZX_64(argument2_3 >> 192);
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = (result1_1 << 64) | _ZX_64(result1_0);
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.6 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_2_0 (ZX.64 (SHR (READ.argument2_0) (CONST.128))))
        (WRITE.argument2_3_0 (ZX.64 (SHR (READ.argument2_0) (CONST.192))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2_1 (ZX.64 (SHR (READ.argument2_1) (CONST.128))))
        (WRITE.argument2_3_1 (ZX.64 (SHR (READ.argument2_1) (CONST.192))))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_2_2 (ZX.64 (SHR (READ.argument2_2) (CONST.128))))
        (WRITE.argument2_3_2 (ZX.64 (SHR (READ.argument2_2) (CONST.192))))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_2_3 (ZX.64 (SHR (READ.argument2_3) (CONST.128))))
        (WRITE.argument2_3_3 (ZX.64 (SHR (READ.argument2_3) (CONST.192))))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1
          (IOR
            (SHL (READ.result1_1) (CONST.64))
            (ZX.64 (READ.result1_0)))))
  - ID: EXT_CWBV0
    what: Extension Convert Word to Byte Vector 0
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVWBV0: "110" }
      - registerAx: "------"
      - registerBq: "----"
      - tcacode5: "00"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xworddReg0M4: registerAx }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_5(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_0_0 = argument2_0.32[0];
      new argument2_0_1 = argument2_0.32[1];
      new argument2_1 = %2:1;
      new argument2_0_2 = argument2_1.32[0];
      new argument2_0_3 = argument2_1.32[1];
      new argument2_2 = %2:2;
      new argument2_0_4 = argument2_2.32[0];
      new argument2_0_5 = argument2_2.32[1];
      new argument2_3 = %2:3;
      new argument2_0_6 = argument2_3.32[0];
      new argument2_0_7 = argument2_3.32[1];
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1_0;
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.5 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (READ.32[0].argument2_0))
        (WRITE.argument2_0_1 (READ.32[1].argument2_0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_0_2 (READ.32[0].argument2_1))
        (WRITE.argument2_0_3 (READ.32[1].argument2_1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_0_4 (READ.32[0].argument2_2))
        (WRITE.argument2_0_5 (READ.32[1].argument2_2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_0_6 (READ.32[0].argument2_3))
        (WRITE.argument2_0_7 (READ.32[1].argument2_3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1_0)))
  - ID: EXT_CWBV1
    what: Extension Convert Word to Byte Vector 1
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVWBV1: "110" }
      - registerAy: "------"
      - registerBq: "----"
      - tcacode5: "01"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xworddReg1M4: registerAy }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_5(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_1_0 = argument2_0.32[2];
      new argument2_1_1 = argument2_0.32[3];
      new argument2_1 = %2:1;
      new argument2_1_2 = argument2_1.32[2];
      new argument2_1_3 = argument2_1.32[3];
      new argument2_2 = %2:2;
      new argument2_1_4 = argument2_2.32[2];
      new argument2_1_5 = argument2_2.32[3];
      new argument2_3 = %2:3;
      new argument2_1_6 = argument2_3.32[2];
      new argument2_1_7 = argument2_3.32[3];
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1_1;
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.5 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_1_0 (READ.32[2].argument2_0))
        (WRITE.argument2_1_1 (READ.32[3].argument2_0))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_1_2 (READ.32[2].argument2_1))
        (WRITE.argument2_1_3 (READ.32[3].argument2_1))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_1_4 (READ.32[2].argument2_2))
        (WRITE.argument2_1_5 (READ.32[3].argument2_2))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_1_6 (READ.32[2].argument2_3))
        (WRITE.argument2_1_7 (READ.32[3].argument2_3))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1_1)))
  - ID: EXT_CWBV2
    what: Extension Convert Word to Byte Vector 2
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVWBV2: "110" }
      - registerAz: "------"
      - registerBq: "----"
      - tcacode5: "10"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xworddReg2M4: registerAz }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_5(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_2_0 = _ZX_32(argument2_0 >> 128);
      new argument2_2_1 = _ZX_32(argument2_0 >> 160);
      new argument2_1 = %2:1;
      new argument2_2_2 = _ZX_32(argument2_1 >> 128);
      new argument2_2_3 = _ZX_32(argument2_1 >> 160);
      new argument2_2 = %2:2;
      new argument2_2_4 = _ZX_32(argument2_2 >> 128);
      new argument2_2_5 = _ZX_32(argument2_2 >> 160);
      new argument2_3 = %2:3;
      new argument2_2_6 = _ZX_32(argument2_3 >> 128);
      new argument2_2_7 = _ZX_32(argument2_3 >> 160);
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1_2;
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.5 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_2_0 (ZX.32 (SHR (READ.argument2_0) (CONST.128))))
        (WRITE.argument2_2_1 (ZX.32 (SHR (READ.argument2_0) (CONST.160))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_2_2 (ZX.32 (SHR (READ.argument2_1) (CONST.128))))
        (WRITE.argument2_2_3 (ZX.32 (SHR (READ.argument2_1) (CONST.160))))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_2_4 (ZX.32 (SHR (READ.argument2_2) (CONST.128))))
        (WRITE.argument2_2_5 (ZX.32 (SHR (READ.argument2_2) (CONST.160))))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_2_6 (ZX.32 (SHR (READ.argument2_3) (CONST.128))))
        (WRITE.argument2_2_7 (ZX.32 (SHR (READ.argument2_3) (CONST.160))))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1_2)))
  - ID: EXT_CWBV3
    what: Extension Convert Word to Byte Vector 3
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { CONVWBV3: "110" }
      - registerAt: "------"
      - registerBq: "----"
      - tcacode5: "11"
      - exubit11: "_"
      - roundint: "---"
      - saturate: "-"
      - exubit6: "0"
      - unused6: "______"
    encoding: simple
    operands: [ { xworddReg3M4: registerAt }, { xwordvReg: registerBq }, roundint, saturate ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new saturate = %4;
      new roundint = %3;
      stage RR:
      new dropbits = _ZX_5(CS.XDROP);
      new argument2_0 = %2:0;
      new argument2_3_0 = _ZX_32(argument2_0 >> 192);
      new argument2_3_1 = _ZX_32(argument2_0 >> 224);
      new argument2_1 = %2:1;
      new argument2_3_2 = _ZX_32(argument2_1 >> 192);
      new argument2_3_3 = _ZX_32(argument2_1 >> 224);
      new argument2_2 = %2:2;
      new argument2_3_4 = _ZX_32(argument2_2 >> 192);
      new argument2_3_5 = _ZX_32(argument2_2 >> 224);
      new argument2_3 = %2:3;
      new argument2_3_6 = _ZX_32(argument2_3 >> 192);
      new argument2_3_7 = _ZX_32(argument2_3 >> 224);
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E3:
      %1 = result1_3;
    behavior: |
      (SEQ
        (WRITE.saturate (ACCESS.ID.%4))
        (WRITE.roundint (ACCESS.ID.%3))
        (WRITE.dropbits (ZX.5 (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XDROP) (CONST.6))))))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_3_0 (ZX.32 (SHR (READ.argument2_0) (CONST.192))))
        (WRITE.argument2_3_1 (ZX.32 (SHR (READ.argument2_0) (CONST.224))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_3_2 (ZX.32 (SHR (READ.argument2_1) (CONST.192))))
        (WRITE.argument2_3_3 (ZX.32 (SHR (READ.argument2_1) (CONST.224))))
        (WRITE.argument2_2 (ACCESS.RR.%2:2))
        (WRITE.argument2_3_4 (ZX.32 (SHR (READ.argument2_2) (CONST.192))))
        (WRITE.argument2_3_5 (ZX.32 (SHR (READ.argument2_2) (CONST.224))))
        (WRITE.argument2_3 (ACCESS.RR.%2:3))
        (WRITE.argument2_3_6 (ZX.32 (SHR (READ.argument2_3) (CONST.192))))
        (WRITE.argument2_3_7 (ZX.32 (SHR (READ.argument2_3) (CONST.224))))
        (MACRO.Instruction)
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E3.%1 (READ.result1_3)))
  - ID: EXT_FSWV
    what: Extension Floating Point Scale Word Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: "111"
      - registerA: "------"
      - registerB: "------"
      - silent2: "-"
      - xrounding: "---"
      - rectify: "-"
      - exubit6: { FSCALEWV: "0" }
      - unused6: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordoReg: registerB }, { rounding: xrounding }, { silent: silent2 }, rectify ]
    syntax: "%0%3%4%5 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new rectify = %5;
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2 = %2;
      new pow2scale = _SX_6(CS.XPOW2);
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.rectify (ACCESS.ID.%5))
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (WRITE.pow2scale
          (SX.6
            (F2I.6 (LOAD.RR (AGGL.CS (CONST.CS_XPOW2) (CONST.6))))))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
          (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
          (COMMIT.E4.%1
            (READ.result1)))
  - ID: EXT_FNWHV
    what: Extension Floating Point Narrow Word to Half Vector
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "00"
      - tcacode1: { FNARROW44WH: "111" }
      - registerA: "------"
      - registerBp: "-----"
      - exubit12: "0"
      - silent2: "-"
      - xrounding: "---"
      - exubit7: "_"
      - exubit6: "1"
      - pow2scale: "______"
    encoding: simple
    operands: [ { xwordoReg: registerA }, { xwordxReg: registerBp }, { rounding: xrounding }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: EXT
    execution: |
      stage ID:
      new silent = %4;
      new rounding = %3;
      stage RR:
      new argument2_0 = %2:0;
      new argument2_0_0 = argument2_0.32[0];
      new argument2_0_1 = argument2_0.32[1];
      new argument2_1_0 = argument2_0.32[2];
      new argument2_1_1 = argument2_0.32[3];
      new argument2_2_0 = _ZX_32(argument2_0 >> 128);
      new argument2_2_1 = _ZX_32(argument2_0 >> 160);
      new argument2_3_0 = _ZX_32(argument2_0 >> 192);
      new argument2_3_1 = _ZX_32(argument2_0 >> 224);
      new argument2_1 = %2:1;
      new argument2_0_2 = argument2_1.32[0];
      new argument2_0_3 = argument2_1.32[1];
      new argument2_1_2 = argument2_1.32[2];
      new argument2_1_3 = argument2_1.32[3];
      new argument2_2_2 = _ZX_32(argument2_1 >> 128);
      new argument2_2_3 = _ZX_32(argument2_1 >> 160);
      new argument2_3_2 = _ZX_32(argument2_1 >> 192);
      new argument2_3_3 = _ZX_32(argument2_1 >> 224);
      new XRM = rounding == 7 ? CS.XRM : rounding;
      @Instruction
      stage E1:
      CS.XMF = 1;
      stage E4:
      if (silent == 0) {
        CS.XUN |= funderflow();
        CS.XIN |= finexact();
        CS.XIO |= finvalid();
        CS.XOV |= foverflow();
      }
      %1 = (result1_1 << 128) | _ZX_128(result1_0);
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%4))
        (WRITE.rounding (ACCESS.ID.%3))
        (WRITE.argument2_0 (ACCESS.RR.%2:0))
        (WRITE.argument2_0_0 (READ.32[0].argument2_0))
        (WRITE.argument2_0_1 (READ.32[1].argument2_0))
        (WRITE.argument2_1_0 (READ.32[2].argument2_0))
        (WRITE.argument2_1_1 (READ.32[3].argument2_0))
        (WRITE.argument2_2_0 (ZX.32 (SHR (READ.argument2_0) (CONST.128))))
        (WRITE.argument2_2_1 (ZX.32 (SHR (READ.argument2_0) (CONST.160))))
        (WRITE.argument2_3_0 (ZX.32 (SHR (READ.argument2_0) (CONST.192))))
        (WRITE.argument2_3_1 (ZX.32 (SHR (READ.argument2_0) (CONST.224))))
        (WRITE.argument2_1 (ACCESS.RR.%2:1))
        (WRITE.argument2_0_2 (READ.32[0].argument2_1))
        (WRITE.argument2_0_3 (READ.32[1].argument2_1))
        (WRITE.argument2_1_2 (READ.32[2].argument2_1))
        (WRITE.argument2_1_3 (READ.32[3].argument2_1))
        (WRITE.argument2_2_2 (ZX.32 (SHR (READ.argument2_1) (CONST.128))))
        (WRITE.argument2_2_3 (ZX.32 (SHR (READ.argument2_1) (CONST.160))))
        (WRITE.argument2_3_2 (ZX.32 (SHR (READ.argument2_1) (CONST.192))))
        (WRITE.argument2_3_3 (ZX.32 (SHR (READ.argument2_1) (CONST.224))))
        (WRITE.XRM
          (SELECT
            (EQ (READ.rounding) (CONST.7))
            (F2I.2 (LOAD.RR (AGGL.CS (CONST.CS_XRM) (CONST.2))))
            (READ.rounding)))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_xun
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1)))))
            (WRITE.CS_xin
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1)))))
            (WRITE.CS_xio
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1)))))
            (WRITE.CS_xov
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_XUN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.funderflow)
                  (READ.CS_xun))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIN) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finexact)
                  (READ.CS_xin))))
            (STORE.E4 (AGGL.CS (CONST.CS_XIO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_xio))))
            (STORE.E4 (AGGL.CS (CONST.CS_XOV) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.foverflow)
                    (READ.CS_xov)))))
          (SKIP))
        (STORE.E1 (AGGL.CS (CONST.CS_XMF) (CONST.1)) (I2F.1 (CONST.1)))
        (COMMIT.E4.%1
          (IOR
            (SHL (READ.result1_1) (CONST.128))
            (ZX.128 (READ.result1_0)))))
  - ID: BCU_CB
    what: BCU Conditional Branches
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { CB: "01" }
      - branchcond: "----"
      - pcrel17: "-----------------"
      - registerZ: "------"
    encoding: simple
    operands: [ scalarcond: branchcond, { singleReg: registerZ }, pcrel17 ]
    syntax: "%0%1 %2? %3"
    properties: { '%0': Control;Conditional, '%3': Target }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
      new argument2 = %2;
      new argument3 = %3;
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.ID.%1))
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument3 (ACCESS.ID.%3)))
  - ID: BCU_HLS
    what: BCU Hardware Loop Setup
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { LOOPDO: "1110" }
      - pcrel17: "-----------------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, pcrel17 ]
    syntax: "%0 %1, %2"
    properties: { '%0': Control, '%2': Target }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
      new argument2 = %2;
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.ID.%1))
        (WRITE.argument2 (ACCESS.ID.%2)))
  - ID: BCU_TLB
    what: BCU TLB Management
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ TLBREAD, TLBPROBE, TLBWRITE ]": "00000..00010", "[ TLBDINVAL, TLBIINVAL ]": "00011..00100" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: ALL
  - ID: BCU_IPC
    what: BCU Instruction Pipeline Control
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ AWAIT, SLEEP, STOP, BARRIER ]": "01000..01011" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: ALL
  - ID: BCU_PGI
    what: BCU Processing Group Instructions
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WAITIT, SYNCGROUP ]": "01100..01101" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_WFX
    what: BCU Half-Word Effects
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemT2: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlyfxReg: systemT2 }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: BCU
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_WFXA
    what: BCU Half-Word Effects Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { aloneReg: systemAlone }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: ALL
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_WFXHW
    what: BCU Half-Word Effects [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ WFXL, WFXM ]": "01110..01111" }
      - bcucode8: "___"
      - systemT4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { systemReg: systemT4 }, { singleReg: registerZ } ]
    syntax: "%0 %1, %2"
    scheduling: BCU
    execution: |
      stage ID:
      new argument2 = %2;
      stage E4:
      new argument1 = %1;
      @Instruction
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.ID.%2))
        (WRITE.argument1 (ACCESS.E4.%1))
        (MACRO.Instruction)
        (COMMIT.E4.%1 (READ.result1)))
  - ID: BCU_SET
    what: BCU Set System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemT3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlysetReg: systemT3 }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETA
    what: BCU Set System Register Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { aloneReg: systemAlone }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALL
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETRA
    what: BCU Set System Register RA
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemRA: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { onlyraReg: systemRA }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_SETHW
    what: BCU Set System Registers [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { SET: "10000" }
      - bcucode8: "___"
      - systemT4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { systemReg: systemT4 }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU
    execution: *executionSET
    behavior: *behaviorSET
  - ID: BCU_GSR
    what: BCU Get System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { GET: "10001" }
      - bcucode8: "___"
      - systemS2: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { onlygetReg: systemS2 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionGET
    behavior: *behaviorGET
  - ID: BCU_GSRHW
    what: BCU Get System Registers [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { GET: "10001" }
      - bcucode8: "___"
      - systemS3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { systemReg: systemS3 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionGET
    behavior: *behaviorGET
  - ID: BCU_RSWAP
    what: BCU General and System Register Swap
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemS4: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { onlyswapReg: systemS4 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_RSWAPA
    what: BCU General and System Register Swap Alone
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemAlone: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { aloneReg: systemAlone } ]
    syntax: "%0 %1 = %2"
    scheduling: ALL
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_RSWAPHW
    what: BCU General and System Register Swap [ONLY_FOR_HW]
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { RSWAP: "10010" }
      - bcucode8: "___"
      - systemS3: "---------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, { systemReg: systemS3 } ]
    syntax: "%0 %1 = %2"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: *executionRSWAP
    behavior: *behaviorRSWAP
  - ID: BCU_IGSR
    what: BCU Indirect Get System Registers
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { IGET: "10011" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    scheduling: BCU_TINY_TINY_MAU_XNOP
    execution: |
      stage ID:
      new index = _ZX_9(%1);
      stage RR:
      @Instruction
      stage E1:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.index (ZX.9 (ACCESS.ID.%1)))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: BCU_RTS
    what: BCU Return from Call and System Calls
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ RET, RFE ]": "10100..10101" }
      - bcucode5: "______"
      - bcucode6: "______"
      - unused6: "______"
    encoding: simple
    syntax: "%0"
    properties: { '%0': Control }
    scheduling: BCU
  - ID: BCU_IBC
    what: BCU Indirect Branch and Call from Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: "1111"
      - bcucode3: { "[ IGOTO, ICALL ]": "10110..10111" }
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_SCI
    what: BCU Supervisor Call Immediate
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { SCALL: "1111" }
      - bcucode3: "11000"
      - bcucode5: "______"
      - sysnumber: "------------"
    encoding: simple
    operands: [ sysnumber ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_SCR
    what: BCU Supervisor Call Register
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: "01"
      - bcucode2: { SCALL: "1111" }
      - bcucode3: "11001"
      - bcucode5: "______"
      - bcucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ } ]
    syntax: "%0 %1"
    properties: { '%0': Control }
    scheduling: ALL
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  - ID: BCU_UB
    what: BCU Unconditional Branches
    fields:
      - parallel: "-"
      - steering: "00"
      - bcucode1: { "[ GOTO, CALL ]": "10..11" }
      - pcrel27: "---------------------------"
    encoding: simple
    operands: [ pcrel27 ]
    syntax: "%0 %1"
    properties: { '%0': Control, '%1': Target }
    scheduling: BCU
    execution: |
      stage ID:
      new argument1 = %1;
    behavior: |
      (WRITE.argument1 (ACCESS.ID.%1))
  ## LSU: steering=01
  - ID: LSU_LSBO
    what: LSU Load Scalar Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: &loadsingle { "[ LBZ, LBS, LHZ, LHS ]": "000..011", "[ LWZ, LWS, LD ]": "100..110" }
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: &descriptionLBO >
      The effective address is computed by adding the %3 to the %2.
    properties: &propertiesLBO { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LSBO.X
    what: LSU Load Scalar Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: &fieldsX
      - steerimx: "00"
      - exunum2: "__"
      - upper27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LSBO: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.X
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LSBO.Y
    what: LSU Load Scalar Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: &fieldsY
      - steerimx3: "00"
      - exunum3: "__"
      - extend27: "---------------------------"
      - parallel2: "1"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LSBO: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.Y
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LQBO
    what: LSU Load Quadruple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: &loadpaired { "[ LQ ]": "111..111" }
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LQBO.X
    what: LSU Load Quadruple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LQBO: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.X
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LQBO.Y
    what: LSU Load Quadruple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LQBO: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.Y
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LOBO
    what: LSU Load Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: &loadquad { "[ LO ]": "111..111" }
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, signed10, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LOBO.X
    what: LSU Load Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LOBO: 0..31 }
    encoding: double
    operands: [ { quadReg: registerN }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.X
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_LOBO.Y
    what: LSU Load Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_LOBO: 0..31 }
    encoding: triple
    operands: [ { quadReg: registerN }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, variant ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.Y
    execution: *executionLBO
    behavior: *behaviorLBO
  - ID: LSU_FXBO
    what: LSU Memory Effects Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: &memoryeffects { "[ DTOUCHL, DINVALL, DPURGEL, DFLUSHL ]": "0000..0011", "[ I1TOUCHL, I1INVALS ]": "0100..0101" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerZ }, signed10 ]
    syntax: "%0 %2[%1]"
    description: &descriptionFBO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesFBO { '%0': MemoryEffect, '%1': Base, '%2': Offset }
    scheduling: LSU
    execution: *executionFBO
    behavior: *behaviorFBO
  - ID: LSU_FXBO.X
    what: LSU Memory Effects Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FXBO: 0..31 }
    encoding: double
    operands: [ { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %2[%1]"
    description: *descriptionFBO
    properties: *propertiesFBO
    scheduling: LSU.X
    execution: *executionFBO
    behavior: *behaviorFBO
  - ID: LSU_FXBO.Y
    what: LSU Memory Effects Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FXBO: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %2[%1]"
    description: *descriptionFBO
    properties: *propertiesFBO
    scheduling: LSU.Y
    execution: *executionFBO
    behavior: *behaviorFBO
  - ID: LSU_XLOBO
    what: LSU Extension Load Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: &loadaccel { "[ XLO ]": "000..000" }
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, signed10, { singleReg: registerZ }, speculate ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: &propertiesLBOV { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLBOV
    behavior: *behaviorLBOV
  - ID: LSU_XLOBO.X
    what: LSU Extension Load Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOBO: 0..31 }
    encoding: double
    operands: [ { xwordoReg: registerG }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, speculate ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBOV
    scheduling: LSU.X
    execution: *executionLBOV
    behavior: *behaviorLBOV
  - ID: LSU_XLOBO.Y
    what: LSU Extension Load Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLOBO: 0..31 }
    encoding: triple
    operands: [ { xwordoReg: registerG }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, speculate ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBOV
    scheduling: LSU.Y
    execution: *executionLBOV
    behavior: *behaviorLBOV
  - ID: LSU_XLSBO
    what: LSU Extension Load Scatter Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, signed10, { singleReg: registerZ }, speculate, qindex ]
    syntax: "%0%4%5 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBOV
    scheduling: LSU
    execution: *executionLVSBO
    behavior: *behaviorLVSBO
  - ID: LSU_XLSBO.X
    what: LSU Extension Load Scatter Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLSBO: 0..31 }
    encoding: double
    operands: [ { xwordvReg: registerGq }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, speculate, qindex ]
    syntax: "%0%4%5 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBOV
    scheduling: LSU.X
    execution: *executionLVSBO
    behavior: *behaviorLVSBO
  - ID: LSU_XLSBO.Y
    what: LSU Extension Load Scatter Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XLSBO: 0..31 }
    encoding: triple
    operands: [ { xwordvReg: registerGq }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, speculate, qindex ]
    syntax: "%0%4%5 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBOV
    scheduling: LSU.Y
    execution: *executionLVSBO
    behavior: *behaviorLVSBO
  - ID: LSU_SSBO
    what: LSU Store Scalar Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &storesingle { "[ SB, SH, SW, SD ]": "00100..00111" }
      - registerT: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: &descriptionSBO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesSBO { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SSBO.X
    what: LSU Store Scalar Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SSBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SSBO.Y
    what: LSU Store Scalar Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SSBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO
    what: LSU Store Quadruple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &storepaired0 { "[ SQ ]": "01000..01000" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO.X
    what: LSU Store Quadruple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SQBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SQBO.Y
    what: LSU Store Quadruple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SQBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SOBO
    what: LSU Store Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &storequad { "[ SO ]": "01000..01000" }
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SOBO.X
    what: LSU Store Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SOBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.X
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_SOBO.Y
    what: LSU Store Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_SOBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { quadReg: registerV } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBO
    scheduling: LSU_AUXR.Y
    execution: *executionSBO
    behavior: *behaviorSBO
  - ID: LSU_FZBO
    what: LSU Memory Zero Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: &memoryzero { DZEROL: "0000" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ } ]
    syntax: "%0 %1[%2]"
    description: &descriptionZBO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesZBO { '%0': MemoryEffect, '%1': Offset, '%2': Base }
    scheduling: LSU
    execution: *executionZBO
    behavior: *behaviorZBO
  - ID: LSU_FZBO.X
    what: LSU Memory Zero Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FZBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ } ]
    syntax: "%0 %1[%2]"
    description: *descriptionZBO
    properties: *propertiesZBO
    scheduling: LSU.X
    execution: *executionZBO
    behavior: *behaviorZBO
  - ID: LSU_FZBO.Y
    what: LSU Memory Zero Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_FZBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ } ]
    syntax: "%0 %1[%2]"
    description: *descriptionZBO
    properties: *propertiesZBO
    scheduling: LSU.Y
    execution: *executionZBO
    behavior: *behaviorZBO
  - ID: LSU_XSOBO
    what: LSU Extension Store Octuple Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &storeaccel { "[ XSO ]": "01001..01001" }
      - registerE: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: &propertiesSBOV { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSBOV
    behavior: *behaviorSBOV
  - ID: LSU_XSOBO.X
    what: LSU Extension Store Octuple Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBOV
    scheduling: LSU_CRRP.X
    execution: *executionSBOV
    behavior: *behaviorSBOV
  - ID: LSU_XSOBO.Y
    what: LSU Extension Store Octuple Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_XSOBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { xwordoReg: registerE } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesSBOV
    scheduling: LSU_CRRP.Y
    execution: *executionSBOV
    behavior: *behaviorSBOV
  - ID: LSU_ASBO
    what: LSU Atomic Scalar Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &memoryatomicS { "[ ALCLRW, ALCLRD ]": "01010..01011" }
      - registerW: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed10, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW
    execution: *executionLBOA
    behavior: *behaviorLBOA
  - ID: LSU_ASBO.X
    what: LSU Atomic Scalar Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_ASBO: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed37: [ upper27, lower10 ] }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.X
    execution: *executionLBOA
    behavior: *behaviorLBOA
  - ID: LSU_ASBO.Y
    what: LSU Atomic Scalar Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_ASBO: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2[%3]"
    description: *descriptionLBO
    properties: *propertiesLBO
    scheduling: LSU_AUXW.Y
    execution: *executionLBOA
    behavior: *behaviorLBOA
  - ID: LSU_AABO
    what: LSU Atomic Add Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &memoryatomicA { "[ ASWAPW, ASWAPD, ALADDW, ALADDD ]": "01100..01111" }
      - registerT: "------"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesAABO
    scheduling: LSU_AUXR_AUXW
    execution: *executionAABO
    behavior: *behaviorAABO
  - ID: LSU_AABO.X
    what: LSU Atomic Add Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_AABO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesAABO
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionAABO
    behavior: *behaviorAABO
  - ID: LSU_AABO.Y
    what: LSU Atomic Add Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_AABO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { singleReg: registerT } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionSBO
    properties: *propertiesAABO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionAABO
    behavior: *behaviorAABO
  - ID: LSU_APBO
    what: LSU Atomic Pair Base Offset
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: &memoryatomicP { "[ ACSWAPW, ACSWAPD ]": "11110..11111" }
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ signed10, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: &descriptionABO >
      The effective address is computed by adding the %2 to the %1.
    properties: &propertiesABO { '%0': MemoryEffect, '%1': Offset, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR_AUXW
    execution: *executionABO
    behavior: *behaviorABO
  - ID: LSU_APBO.X
    what: LSU Atomic Pair Base Offset Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_APBO: 0..31 }
    encoding: double
    operands: [ { signed37: [ upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionABO
    properties: *propertiesABO
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionABO
    behavior: *behaviorABO
  - ID: LSU_APBO.Y
    what: LSU Atomic Pair Base Offset Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { LSU_APBO: 0..31 }
    encoding: triple
    operands: [ { wrapped64: [ extend27, upper27, lower10 ] }, { singleReg: registerZ }, { pairedReg: registerU } ]
    syntax: "%0 %1[%2] = %3"
    description: *descriptionABO
    properties: *propertiesABO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionABO
    behavior: *behaviorABO
  - ID: LSU_COPYO
    what: LSU Copy Octuple Word
    fields:
      - parallel: "-"
      - steering: "01"
      - exubit28: "1"
      - exubit27: "1"
      - lsucode3: { COPYO: "110" }
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "01"
      - lower10: "__________"
      - registerR: "----"
      - exubit1: "_"
      - exubit0: "_"
    encoding: simple
    operands: [ { quadReg: registerN }, { quadReg: registerR } ]
    properties: &propertiesCOPYO { '%2': Stored }
    syntax: "%0 %1 = %2"
    scheduling: LSU_AUXR_AUXW
    execution: |
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E3:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E3.%1 (READ.result1)))
  - ID: LSU_MCC
    what: LSU Memory and Cache Control
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: "11111"
      - lsucode2: { "[ D1INVAL, I1INVAL ]": "1000..1001", "[ FENCE ]": "1100..1100" }
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "01"
      - unused16: "________________"
    encoding: simple
    syntax: "%0"
    scheduling: LSU
  - ID: LSU_LSPB
    what: LSU Load Scalar Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: &descriptionLPB >
      The effective address is given by the %3. The predicate is computed on the %2 with the %4.
    properties: &propertiesLPB { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLPB
    behavior: *behaviorLPB
  - ID: LSU_LSPB.O
    what: LSU Load Scalar Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: &fieldsO
      - steerimx: "00"
      - exunum2: "__"
      - offset27: "---------------------------"
      - parallel: "1"
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LSPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: &descriptionLPBO >
      The effective address is given by adding the %5 to the %3. The predicate is computed on the %2 with the %4.
    properties: &propertiesLPBO { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%5': Offset }
    scheduling: LSU_AUXW.X
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_LSPB.Y
    what: LSU Load Scalar Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LSPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_LQPB
    what: LSU Load Quadruple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLPB
    scheduling: LSU_AUXW
    execution: *executionLPB
    behavior: *behaviorLPB
  - ID: LSU_LQPB.O
    what: LSU Load Quadruple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LQPB: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.X
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_LQPB.Y
    what: LSU Load Quadruple Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LQPB: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_LOPB
    what: LSU Load Octuple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, variant ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLPB
    scheduling: LSU_AUXW
    execution: *executionLPB
    behavior: *behaviorLPB
  - ID: LSU_LOPB.O
    what: LSU Load Octuple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOPB: 0..31 }
    encoding: double
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.X
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_LOPB.Y
    what: LSU Load Octuple Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_LOPB: 0..31 }
    encoding: triple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] }, variant ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLPBO
    behavior: *behaviorLPBO
  - ID: LSU_FXCB
    what: LSU Memory Effects Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond } ]
    syntax: "%0%3 %1? [%2]"
    description: &descriptionFPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %3.
    properties: &propertiesFPB { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base }
    scheduling: LSU
    execution: *executionFPB
    behavior: *behaviorFPB
  - ID: LSU_FXCB.O
    what: LSU Memory Effects Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_FXCB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%3 %1? %4[%2]"
    description: &descriptionFPBO >
      The effective address is given by the %4 to the %2. The condition is computed on the %1 with the %3.
    properties: &propertiesFPBO { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base, '%4': Offset }
    scheduling: LSU.X
    execution: *executionFPBO
    behavior: *behaviorFPBO
  - ID: LSU_FXCB.Y
    what: LSU Memory Effects Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_FXCB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%3 %1? %4[%2]"
    description: *descriptionFPBO
    properties: *propertiesFPBO
    scheduling: LSU.Y
    execution: *executionFPBO
    behavior: *behaviorFPBO
  - ID: LSU_XLQB
    what: LSU Extension Load Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, speculate ]
    syntax: "%0%5%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: &propertiesLPBV { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLPBV
    behavior: *behaviorLPBV
  - ID: LSU_XLQB.O
    what: LSU Extension Load Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLQB: 0..31 }
    encoding: double
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 }, speculate ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: &propertiesLPBOV { '%0': MemoryRead;Predicated, '%1': Loaded, '%2': Tested, '%3': Base, '%5': Offset, '%CS': NoEffects }
    scheduling: LSU.X
    execution: *executionLPBOV
    behavior: *behaviorLPBOV
  - ID: LSU_XLQB.Y
    what: LSU Extension Load Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLQB: 0..31 }
    encoding: triple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] }, speculate ]
    syntax: "%0%6%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBOV
    scheduling: LSU.Y
    execution: *executionLPBOV
    behavior: *behaviorLPBOV
  - ID: LSU_XLSPB
    what: LSU Extension Load Scatter Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, speculate, qindex ]
    syntax: "%0%5%4%6 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLPBV
    scheduling: LSU
    execution: *executionLPBT
    behavior: *behaviorLPBT
  - ID: LSU_XLSPB.O
    what: LSU Extension Load Scatter Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLSPB: 0..31 }
    encoding: double
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 }, speculate, qindex ]
    syntax: "%0%6%4%7 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBOV
    scheduling: LSU.X
    execution: *executionLPBOT
    behavior: *behaviorLPBOT
  - ID: LSU_XLSPB.Y
    what: LSU Extension Load Scatter Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XLSPB: 0..31 }
    encoding: triple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] }, speculate, qindex ]
    syntax: "%0%6%4%7 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBOV
    scheduling: LSU.Y
    execution: *executionLPBOT
    behavior: *behaviorLPBOT
  - ID: LSU_SSPB
    what: LSU Store Scalar Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: &descriptionSPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesSPB { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSPB
    behavior: *behaviorSPB
  - ID: LSU_SSPB.O
    what: LSU Store Scalar Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SSPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: &descriptionSPBO >
      The effective address is given by adding the %5 to the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesSPBO { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%5': Offset }
    scheduling: LSU_AUXR.X
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_SSPB.Y
    what: LSU Store Scalar Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SSPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_SQPB
    what: LSU Store Quadruple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: *propertiesSPB
    scheduling: LSU_AUXR
    execution: *executionSPB
    behavior: *behaviorSPB
  - ID: LSU_SQPB.O
    what: LSU Store Quadruple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SQPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBO
    scheduling: LSU_AUXR.X
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_SQPB.Y
    what: LSU Store Quadruple Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SQPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_SOPB
    what: LSU Store Octuple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: *propertiesSPB
    scheduling: LSU_AUXR
    execution: *executionSPB
    behavior: *behaviorSPB
  - ID: LSU_SOPB.O
    what: LSU Store Octuple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBO
    scheduling: LSU_AUXR.X
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_SOPB.Y
    what: LSU Store Octuple Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_SOPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBO
    scheduling: LSU_AUXR.Y
    execution: *executionSPBO
    behavior: *behaviorSPBO
  - ID: LSU_FZCB
    what: LSU Memory Zero Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond } ]
    syntax: "%0%3 %1? [%2]"
    description: &descriptionZPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %3.
    properties: &propertiesZPB { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base }
    scheduling: LSU
    execution: *executionZPB
    behavior: *behaviorZPB
  - ID: LSU_FZCB.O
    what: LSU Memory Zero Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_FZCB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%3 %1? %4[%2]"
    description: &descriptionZPBO >
      The effective address is given by the %4 to the %2. The condition is computed on the %1 with the %3.
    properties: &propertiesZPBO { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base, '%4': Offset }
    scheduling: LSU.X
    execution: *executionZPBO
    behavior: *behaviorZPBO
  - ID: LSU_FZCB.Y
    what: LSU Memory Zero Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_FZCB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%3 %1? %4[%2]"
    description: *descriptionZPBO
    properties: *propertiesZPBO
    scheduling: LSU.Y
    execution: *executionZPBO
    behavior: *behaviorZPBO
  - ID: LSU_XSQB
    what: LSU Store Quadruple Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: *descriptionSPB
    properties: &propertiesSPBV { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSPBV
    behavior: *behaviorSPBV
  - ID: LSU_XSQB.O
    what: LSU Store Quadruple Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSQB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: &propertiesSPBOV { '%0': MemoryWrite;Predicated, '%1': Tested, '%2': Base, '%3': Stored, '%5': Offset, '%CS': NoEffects }
    scheduling: LSU_CRRP.X
    execution: *executionSPBOV
    behavior: *behaviorSPBOV
  - ID: LSU_XSQB.Y
    what: LSU Store Quadruple Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_XSQB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionSPBO
    properties: *propertiesSPBOV
    scheduling: LSU_CRRP.Y
    execution: *executionSPBOV
    behavior: *behaviorSPBOV
  - ID: LSU_ASPB
    what: LSU Atomic Scalar Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond } ]
    syntax: "%0%4 %2? %1 = [%3]"
    description: *descriptionLPB
    properties: *propertiesLPB
    scheduling: LSU_AUXW
    execution: *executionLPBA
    behavior: *behaviorLPBA
  - ID: LSU_ASPB.O
    what: LSU Atomic Scalar Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_ASPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.X
    execution: *executionLPBOA
    behavior: *behaviorLPBOA
  - ID: LSU_ASPB.Y
    what: LSU Atomic Scalar Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_ASPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %2? %1 = %5[%3]"
    description: *descriptionLPBO
    properties: *propertiesLPBO
    scheduling: LSU_AUXW.Y
    execution: *executionLPBOA
    behavior: *behaviorLPBOA
  - ID: LSU_AAPB
    what: LSU Atomic Add Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: &descriptionAAPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesAAPB { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base, '%3': Loaded }
    scheduling: LSU_AUXR_AUXW
    execution: *executionAAPB
    behavior: *behaviorAAPB
  - ID: LSU_AAPB.O
    what: LSU Atomic Add Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_AAPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: &descriptionAAPBO >
      The effective address is given by adding the %5 to the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesAAPBO { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base, '%3': Loaded, '%5': Offset }
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionAAPBO
    behavior: *behaviorAAPBO
  - ID: LSU_AAPB.Y
    what: LSU Atomic Add Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_AAPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionAAPBO
    properties: *propertiesAAPBO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionAAPBO
    behavior: *behaviorAAPBO
  - ID: LSU_APPB
    what: LSU Atomic Pair Predicated Base
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond } ]
    syntax: "%0%4 %1? [%2] = %3"
    description: &descriptionAPB >
      The effective address is given by the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesAPB { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base }
    scheduling: LSU_AUXR_AUXW
    execution: *executionAPB
    behavior: *behaviorAPB
  - ID: LSU_APPB.O
    what: LSU Atomic Pair Predicated Base Offset
    fields2:
      - parallel2: "-"
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_APPB: 0..31 }
    encoding: double
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed27: offset27 } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: &descriptionAPBO >
      The effective address is given by adding the %5 to the %2. The condition is computed on the %1 with the %4.
    properties: &propertiesAPBO { '%0': MemoryEffect;Predicated, '%1': Tested, '%2': Base, '%5': Offset }
    scheduling: LSU_AUXR_AUXW.X
    execution: *executionAPBO
    behavior: *behaviorAPBO
  - ID: LSU_APPB.Y
    what: LSU Atomic Pair Predicated Base Offset Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsO
    fields:
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucond: "----"
      - registerY: "------"
      - registerZ: "------"
    samefields: { LSU_APPB: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, { scalarcond: lsucond }, { signed54: [ extend27, offset27 ] } ]
    syntax: "%0%4 %1? %5[%2] = %3"
    description: *descriptionAPBO
    properties: *propertiesAPBO
    scheduling: LSU_AUXR_AUXW.Y
    execution: *executionAPBO
    behavior: *behaviorAPBO
  - ID: LSU_LSBI
    what: LSU Load Scalar Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadsingle
      - variant: "--"
      - registerW: "------"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: &descriptionLBI >
      The effective address is computed by adding the %3 to the %2 and scaled by the %4.
    properties: &propertiesLBI { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base }
    scheduling: LSU_AUXW
    execution: *executionLBI
    behavior: *behaviorLBI
  - ID: LSU_LQBI
    what: LSU Load Quadruple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadpaired
      - variant: "--"
      - registerM: "-----"
      - lsubit18: "0"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLBI
    properties: *propertiesLBI
    scheduling: LSU_AUXW
    execution: *executionLBI
    behavior: *behaviorLBI
  - ID: LSU_LOBI
    what: LSU Load Quadruple Base + (Index*Scaling) 1
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadquad
      - variant: "--"
      - registerN: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { quadReg: registerN }, { singleReg: registerY }, { singleReg: registerZ }, doscale, variant ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLBI
    properties: *propertiesLBI
    scheduling: LSU_AUXW
    execution: *executionLBI
    behavior: *behaviorLBI
  - ID: LSU_FXBI
    what: LSU Memory Effects Base + Index
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode1: "111"
      - cachelev: "00"
      - lsucode2: *memoryeffects
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "10"
      - lsucode5: "111"
      - doscale: "0"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ } ]
    syntax: "%0 %1[%2]"
    description: &descriptionFBI >
      The effective address is computed by adding the %2 to the %1.
    properties: &attributesFBI { '%0': MemoryEffect, '%1': Offset, '%2': Base }
    scheduling: LSU
    execution: *executionFBI
    behavior: *behaviorFBI
  - ID: LSU_XLBI
    what: LSU Extension Load Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "0"
      - speculate: "-"
      - registerG: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordoReg: registerG }, { singleReg: registerY }, { singleReg: registerZ }, doscale, speculate ]
    syntax: "%0%5%4 %1 = %2[%3]"
    description: *descriptionLBI
    properties: &propertiesLBIV { '%0': MemoryRead, '%1': Loaded, '%2': Offset, '%3': Base, '%CS': NoEffects }
    scheduling: LSU
    execution: *executionLBIV
    behavior: *behaviorLBIV
  - ID: LSU_XLSBI
    what: LSU Extension Load Scatter Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - loadcode: *loadaccel
      - lsubit25: "1"
      - speculate: "-"
      - registerGq: "----"
      - qindex: "--"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordvReg: registerGq }, { singleReg: registerY }, { singleReg: registerZ }, doscale, speculate, qindex ]
    syntax: "%0%5%6%4 %1 = %2[%3]"
    description: *descriptionLBI
    properties: *propertiesLBIV
    scheduling: LSU
    execution: *executionLVSBI
    behavior: *behaviorLVSBI
  - ID: LSU_SSBI
    what: LSU Store Scalar Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storesingle
      - registerT: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: &descriptionSBI >
      The effective address is computed by adding the %2 to the %1 and scaled by the %4.
    properties: &propertiesSBI { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored }
    scheduling: LSU_AUXR
    execution: *executionSBI
    behavior: *behaviorSBI
  - ID: LSU_SQBI
    what: LSU Store Quadruple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storepaired0
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBI
    properties: *propertiesSBI
    scheduling: LSU_AUXR
    execution: *executionSBI
    behavior: *behaviorSBI
  - ID: LSU_SOBI
    what: LSU Store Octuple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storequad
      - registerV: "----"
      - lsubit19: "0"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { quadReg: registerV }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBI
    properties: *propertiesSBI
    scheduling: LSU_AUXR
    execution: *executionSBI
    behavior: *behaviorSBI
  - ID: LSU_FZBI
    what: LSU Memory Zero Base + Index
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: "01000"
      - lsucode2: *memoryzero
      - lsubit19: "1"
      - lsubit18: "1"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "0"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ } ]
    syntax: "%0 %1[%2]"
    description: &descriptionZBI >
      The effective address is computed by adding the %2 to the %1.
    properties: &attributesZBI { '%0': MemoryEffect, '%2': Base }
    scheduling: LSU
    execution: *executionZBI
    behavior: *behaviorZBI
  - ID: LSU_XSOBI
    what: LSU Extension Store Octuple Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *storeaccel
      - registerE: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { xwordoReg: registerE }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: *descriptionSBI
    properties: &propertiesSBIV { '%0': MemoryWrite, '%1': Offset, '%2': Base, '%3': Stored, '%CS': NoEffects }
    scheduling: LSU_CRRP
    execution: *executionSBIV
    behavior: *behaviorSBIV
  - ID: LSU_ASBI
    what: LSU Atomic Scalar Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicS
      - registerW: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerY }, { singleReg: registerZ }, doscale ]
    syntax: "%0%4 %1 = %2[%3]"
    description: *descriptionLBI
    properties: *propertiesLBI
    scheduling: LSU_AUXW
    execution: *executionLBIA
    behavior: *behaviorLBIA
  - ID: LSU_AABI
    what: LSU Atomic Add Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicA
      - registerT: "------"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { singleReg: registerT }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: &descriptionAABI >
      The effective address is computed by adding the %2 to the %1 scaled by the %4.
    properties: &propertiesAABI { '%0': MemoryEffect, '%2': Base, '%3': Loaded }
    scheduling: LSU_AUXR_AUXW
    execution: *executionAABI
    behavior: *behaviorAABI
  - ID: LSU_APBI
    what: LSU Atomic Pair Base + (Index*Scaling)
    fields:
      - parallel: "-"
      - steering: "01"
      - lsucode0: *memoryatomicP
      - registerU: "-----"
      - lsubit18: "0"
      - lsucode4: "11"
      - lsucode5: "111"
      - doscale: "-"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerY }, { singleReg: registerZ }, { pairedReg: registerU }, doscale ]
    syntax: "%0%4 %1[%2] = %3"
    description: &descriptionABI >
      The effective address is computed by adding the %2 to the %1 and scaled by the %4.
    properties: &propertiesABI { '%0': MemoryEffect, '%2': Base }
    scheduling: LSU_AUXR_AUXW
    execution: *executionABI
    behavior: *behaviorABI
  ## ALU: steering=11
  - ID: ALU_MAKE
    what: ALU Make from Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - signed16: "----------------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed16 ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_MAKE.X
    what: ALU Make from Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - extend6: "------"
    samefields: { ALU_MAKE: 16..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed43: [ extend6, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY.X
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_MAKE.Y
    what: ALU Make from Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { MAKE: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - unused6: "______"
    samefields: { ALU_MAKE: 16..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_TINY.Y
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_DWRI
    what: ALU Write Read Double Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRI.X
    what: ALU Write Read Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRI.Y
    what: ALU Write Read Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD ]": "0001..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_CWRI
    what: ALU Compare Write Read Immediate
    fields:
      - parallel: "-"
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CWRI.X
    what: ALU Compare Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_CWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_CWRI.Y
    what: ALU Compare Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: { COMPD: "11" }
      - exubit28: "0"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_CWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WRIS
    what: ALU Write Read Immediate Saturating
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDSD, SBFSD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WRIS.X
    what: ALU Write Read Immediate Saturating Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDSD, SBFSD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_WRIS: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WRIS.Y
    what: ALU Write Read Immediate Saturating Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ ADDSD, SBFSD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_WRIS: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.Y
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DCMWRI
    what: ALU Double Conditional Move Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DCMWRI.X
    what: ALU Double Conditional Move Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DCMWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE.X
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DCMWRI.Y
    what: ALU Double Conditional Move Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DCMWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE.Y
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_DBMWRI
    what: ALU Bit Matrix Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DBMWRI.X
    what: ALU Bit Matrix Write Read Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DBMWRI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DBMWRI.Y
    what: ALU Bit Matrix Write Read Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "0"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_DBMWRI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.Y
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WRB
    what: ALU Write Read Bitmask
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "0"
      - wricode1: { "[ INSF, EXTFZ, EXTFS, CLRF ]": "00..11" }
      - stopbit2: "--"
      - registerW: "------"
      - exucode4: "11"
      - stopbit4: "----"
      - startbit: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { unsigned6: [ stopbit2, stopbit4 ] }, { unsigned6: startbit } ]
    syntax: "%0 %1 = %2, %3, %4"
    scheduling: ALU_LITE
    execution: |
      stage ID:
      new startbit = %4;
      new stopbit = %3;
      new bias = startbit <= stopbit;
      new mask = _ZX_64((2 << stopbit) - ((2 - bias) << startbit) + bias - 1);
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.startbit (ACCESS.ID.%4))
        (WRITE.stopbit (ACCESS.ID.%3))
        (WRITE.bias
          (B2I
            (LE
              (READ.startbit)
              (READ.stopbit))))
        (WRITE.mask
          (ZX.64
            (ADD
              (SUB
                (SHL
                  (CONST.2)
                  (READ.stopbit))
                (SHL
                  (SUB
                    (CONST.2)
                    (READ.bias))
                  (READ.startbit)))
              (SUB
                (READ.bias)
                (CONST.1)))))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E1.%1 (READ.result1)))
  - ID: ALU_PCREL
    what: ALU Add PC to Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - signed16: "----------------"
    encoding: simple
    operands: [ { singleReg: registerW }, signed16 ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_PCREL.X
    what: ALU Add PC to Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - extend6: "------"
    samefields: { ALU_PCREL: 16..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { signed43: [ extend6, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL.X
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_PCREL.Y
    what: ALU Add PC to Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { PCREL: "0000" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - unused6: "______"
    samefields: { ALU_PCREL: 16..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_FULL.Y
    execution: *executionDWI
    behavior: *behaviorDWI
  - ID: ALU_WRIW
    what: ALU Write Read Immediate Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDW, MINW, MAXW, ABDW, SBFW, MINUW, MAXUW ]": "0001..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WRIW.X
    what: ALU Write Read Immediate Extended Word
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDW, MINW, MAXW, ABDW, SBFW, MINUW, MAXUW ]": "0001..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { ALU_WRIW: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_DWRR
    what: ALU Double Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD ]": "0000..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D ]": "0000..0111", "[ ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "0000", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": "0100" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: { "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": ALU_LITE, "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": ALU_TINY }
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DWRR.M
    what: ALU Double Write Read Read Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD ]": "0000..0111", "[ ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "1000..1111", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D ]": "0000..0111", "[ ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": "0000", "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": "0100" }
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: { "[ ADDX2D, SBFX2D, ADDX4D, SBFX4D, ADDX8D, SBFX8D, ADDX16D, SBFX16D, ADDWD, SBFWD, ADDUWD, SBFUWD, LANDD, LNANDD, LIORD, LNIORD ]": ALU_LITE.X, "[ STSUD, ADDD, MIND, MAXD, ABDD, SBFD, MINUD, MAXUD, ANDD, NANDD, IORD, NIORD, EORD, NEORD, ANDND, IORND ]": ALU_TINY.X }
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WWRR0
    what: ALU Word Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ STSUW, ADDW, MINW, MAXW, ABDW, SBFW, MINUW, MAXUW ]": "0000..0111", "[ ANDW, NANDW, IORW, NIORW, EORW, NEORW, ANDNW, IORNW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPWRR0
    what: ALU Word Pair Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDWP, MINWP, MAXWP, ABDWP, SBFWP, MINUWP, MAXUWP ]": "0001..0111", "[ ADDWC.C, SBFWC.C ]": "1100..1101" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPWRR0.M
    what: ALU Word Pair Write Read Read 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDWP, MINWP, MAXWP, ABDWP, SBFWP, MINUWP, MAXUWP ]": "0001..0111", "[ ADDWC.C, SBFWC.C ]": "1100..1101" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0010"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPWRR0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQWRR0
    what: ALU Half Quadruple Write Read Read 0
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDHQ, MINHQ, MAXHQ, ABDHQ, SBFHQ, MINUHQ, MAXUHQ ]": "0001..0111", "[ ADDHCP.C, SBFHCP.C ]": "1100..1101" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQWRR0.M
    what: ALU Half Quadruple Write Read Read 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDHQ, MINHQ, MAXHQ, ABDHQ, SBFHQ, MINUHQ, MAXUHQ ]": "0001..0111", "[ ADDHCP.C, SBFHCP.C ]": "1100..1101" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0011"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_HQWRR0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_TINY.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WWRR1
    what: ALU Word Write Read Read 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2W, SBFX2W, ADDX4W, SBFX4W, ADDX8W, SBFX8W, ADDX16W, SBFX16W ]": "0000..0111", "[ AVGW, AVGUW, AVGRW, AVGRUW, LANDW, LNANDW, LIORW, LNIORW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0101"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WWRR1.W
    what: ALU Word Write Read Read 1 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2W, SBFX2W, ADDX4W, SBFX4W, ADDX8W, SBFX8W, ADDX16W, SBFX16W ]": "0000..0111", "[ AVGW, AVGUW, AVGRW, AVGRUW, LANDW, LNANDW, LIORW, LNIORW ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0101"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPWRR1
    what: ALU Word Pair Write Read Read 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WP, SBFX2WP, ADDX4WP, SBFX4WP, ADDX8WP, SBFX8WP, ADDX16WP, SBFX16WP ]": "0000..0111", "[ AVGWP, AVGUWP, AVGRWP, AVGRUWP, LANDWP, LNANDWP, LIORWP, LNIORWP ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPWRR1.M
    what: ALU Word Pair Write Read Read 1 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WP, SBFX2WP, ADDX4WP, SBFX4WP, ADDX8WP, SBFX8WP, ADDX16WP, SBFX16WP ]": "0000..0111", "[ AVGWP, AVGUWP, AVGRWP, AVGRUWP, LANDWP, LNANDWP, LIORWP, LNIORWP ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQWRR1
    what: ALU Write Read Read Half Word Quadruple 1
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2HQ, SBFX2HQ, ADDX4HQ, SBFX4HQ, ADDX8HQ, SBFX8HQ, ADDX16HQ, SBFX16HQ ]": "0000..0111", "[ AVGHQ, AVGUHQ, AVGRHQ, AVGRUHQ, LANDHQ, LNANDHQ, LIORHQ, LNIORHQ ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQWRR1.M
    what: ALU Half Quadruple Write Read Read 1 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2HQ, SBFX2HQ, ADDX4HQ, SBFX4HQ, ADDX8HQ, SBFX8HQ, ADDX16HQ, SBFX16HQ ]": "0000..0111", "[ AVGHQ, AVGUHQ, AVGRHQ, AVGRUHQ, LANDHQ, LNANDHQ, LIORHQ, LNIORHQ ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "0111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_HQWRR1: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WDWRR2
    what: ALU Word to Double Write Read Read 2
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WD, SBFX2WD, ADDX4WD, SBFX4WD, ADDX8WD, SBFX8WD, ADDX16WD, SBFX16WD ]": "0000..0111", "[ ADDX2UWD, SBFX2UWD, ADDX4UWD, SBFX4UWD, ADDX8UWD, SBFX8UWD, ADDX16UWD, SBFX16UWD ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WDWRR2.W
    what: ALU Word to Double Write Read Read 2 Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDX2WD, SBFX2WD, ADDX4WD, SBFX4WD, ADDX8WD, SBFX8WD, ADDX16WD, SBFX16WD ]": "0000..0111", "[ ADDX2UWD, SBFX2UWD, ADDX4UWD, SBFX4UWD, ADDX8UWD, SBFX8UWD, ADDX16UWD, SBFX16UWD ]": "1000..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1000"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WDWRR2: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_CWRR
    what: ALU Double Comparison Write Read Read
    fields:
      - parallel: "-"
      - steering: { COMPD: "11" }
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WRRS
    what: ALU Write Read Read Saturating
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSD, SBFSD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DCWRR
    what: ALU Double Comparison Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ COMPW, COMPWD, COMPUWD ]": "1011..1101" }
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_DCWRR.W
    what: ALU Double Comparison Write Read Read Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: "01"
      - exucode5: { "[ COMPW, COMPWD, COMPUWD ]": "1011..1101" }
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DCWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_AWRRW
    what: ALU Arithmetic Write Read Read Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSW, SBFSW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_AWRRW.W
    what: ALU Arithmetic Write Read Read Word Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSW, SBFSW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_AWRRW: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE.X
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_DCWRRC
    what: ALU Double Carry Write Read Read Carry
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDCD, SBFCD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_FULL
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DCWRRC.W
    what: ALU Double Carry Write Read Read Carry Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDCD, SBFCD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1100"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DCWRRC: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_FULL.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DCWRRCI
    what: ALU Double Carry Write Read Read Carry Initialize
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDCD.I, SBFCD.I ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1101"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_FULL
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DCWRRCI.W
    what: ALU Double Carry Write Read Read Carry Initialize Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDCD.I, SBFCD.I ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1101"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_DCWRRCI: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_FULL.X
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WPCNWRR
    what: ALU Comparison Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNWP: "01" }
      - exucode5: "1110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPCNWRR.M
    what: ALU Comparison Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNWP: "01" }
      - exucode5: "1110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_AWRRWP
    what: ALU Arithmetic Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSWP, SBFSWP ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_AWRRWP.M
    what: ALU Arithmetic Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSWP, SBFSWP ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1110"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_AWRRWP: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_HQCWRR
    what: ALU Comparison Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNHQ: "01" }
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, comparison ]
    syntax: "%0%4 %1 = %2, %3"
    scheduling: ALU_TINY
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_HQCWRR.M
    what: ALU Comparison Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - comparison: "----"
      - registerW: "------"
      - exucode4: { COMPNHQ: "01" }
      - exucode5: "1111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, comparison, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    scheduling: ALU_TINY.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_AWRRHQ
    what: ALU Arithmetic Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSHQ, SBFSHQ ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_AWRRHQ.M
    what: ALU Arithmetic Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ADDSHQ, SBFSHQ ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "01"
      - exucode5: "1111"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_AWRRHQ: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_DCMWRR
    what: ALU Double Conditional Move Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - scalarcond: "----"
      - registerW: "------"
      - exucode4: { CMOVED: "10" }
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, scalarcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_BWRR
    what: ALU Bit Matrix Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BWRR.M
    what: ALU Bit Matrix Write Read Read Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SBMM8D, SBMMT8D ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_BWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: ALU_LITE.X
    execution: *executionDWRRM
    behavior: *behaviorDWRRM
  - ID: ALU_WPCMWRR
    what: ALU Move Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEWP: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, simdcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_WPCMWRR.M
    what: ALU Move Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEWP: "0" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_WPCMWRR: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, simdcond, splat32 ]
    syntax: "%0%4 %2? %1 = %3%5"
    scheduling: ALU_LITE.X
    execution: *executionCMWRRM
    behavior: *behaviorCMWRRM
  - ID: ALU_CMWRRHQ
    what: ALU Move Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEHQ: "1" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, simdcond ]
    syntax: "%0%4 %2? %1 = %3"
    scheduling: ALU_LITE
    execution: *executionCMWRR
    behavior: *behaviorCMWRR
  - ID: ALU_CMWRRHQ.M
    what: ALU Move Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { CMOVEHQ: "1" }
      - simdcond: "---"
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_CMWRRHQ: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, simdcond, splat32 ]
    syntax: "%0%4 %2? %1 = %3%5"
    scheduling: ALU_LITE.X
    execution: *executionCMWRRM
    behavior: *behaviorCMWRRM
  - ID: ALU_BWRD
    what: ALU Bit Write Read Double
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZD, CLSD, CBSD, CTZD ]": "0000..0011" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0010"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_DSWRI
    what: ALU Double Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSD, SLLD, SRAD, SRLD, SLSD ]": "1000..1100", "[ SATD, SATUD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0010"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_BWRW
    what: ALU Bit Write Read Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZW, CLSW, CBSW, CTZW ]": "0000..0011" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0011"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionWZWR
    behavior: *behaviorWZWR
  - ID: ALU_WSWRI
    what: ALU Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSW, SLLW, SRAW, SRLW, SLSW ]": "1000..1100", "[ ROLW, RORW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0011"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_BWRWP
    what: ALU Bit Write Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ CLZWP, CLSWP, CBSWP, CTZWP ]": "0000..0011", "[ ZXLHWP, ZXMHWP, SXLHWP, SXMHWP ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0100"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_WPSWRI
    what: ALU Word Pair Shift Rotate Write Read Immediate
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSWPS, SLLWPS, SRAWPS, SRLWPS, SLSWPS ]": "1000..1100", "[ ROLWPS, RORWPS ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0100"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_LWRHQ
    what: ALU Arithmetic Write Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ ZXLBHQ, ZXMBHQ, SXLBHQ, SXMBHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0101"
      - exucode6: "______"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
  - ID: ALU_HQSWRI
    what: ALU Shift Rotate Write Read Immediate Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSHQS, SLLHQS, SRAHQS, SRLHQS, SLSHQS ]": "1000..1100" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0101"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_DSWRR
    what: ALU Double Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSD, SLLD, SRAD, SRLD, SLSD ]": "1000..1100", "[ SATD, SATUD ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_WSWRR
    what: ALU Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSW, SLLW, SRAW, SRLW, SLSW ]": "1000..1100", "[ ROLW, RORW ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "0111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionWZWRR
    behavior: *behaviorWZWRR
  - ID: ALU_WPSWRR
    what: ALU Word Pair Shift Rotate Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSWPS, SLLWPS, SRAWPS, SRLWPS, SLSWPS ]": "1000..1100", "[ ROLWPS, RORWPS ]": "1110..1111" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_HQSWRR
    what: ALU Shift Rotate Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ SRSHQS, SLLHQS, SRAHQS, SRLHQS, SLSHQS ]": "1000..1100" }
      - registerW: "------"
      - exucode4: "10"
      - exucode5: "1001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_MTWQE
    what: ALU Move Quadruple Word To Block Register Even
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { MOVETQ: "1111" }
      - registerAE: "------"
      - exucode4: "10"
      - exucode5: "1110"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordqRegE: registerAE }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE_CRWL
    execution: *executionMOVETQ
    behavior: *behaviorMOVETQ
  - ID: ALU_MTWQO
    what: ALU Move Quadruple Word To Block Register Odd
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { MOVETQ: "1111" }
      - registerAO: "------"
      - exucode4: "10"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { xwordqRegO: registerAO }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: ALU_LITE_CRWH
    execution: *executionMOVETQ
    behavior: *behaviorMOVETQ
  - ID: ALU_FCWRRS
    what: ALU Floating-Point Comparison Write Read Read Scalar
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPW, FCOMPD ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_FCWRRS.W
    what: ALU Floating-Point Comparison Write Read Immediate Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { "[ FCOMPW, FCOMPD ]": "0..1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0000"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { ALU_FCWRRS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE.X
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPFCWRR
    what: ALU Floating-Point Comparison Write Read Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNWP: "0" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_WPFCWRR.M
    what: ALU Floating-Point Comparison Write Read Read Word Pair Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNWP: "0" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_HQFCWRR
    what: ALU Floating-Point Comparison Write Read Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNHQ: "1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, floatcomp ]
    syntax: "%0%4 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionCWRR
    behavior: *behaviorCWRR
  - ID: ALU_HQFCWRR.M
    what: ALU Floating-Point Comparison Write Read Read Half Word Quadruple Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "11"
      - exubit28: "1"
      - exubit27: { FCOMPNHQ: "1" }
      - floatcomp: "---"
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, floatcomp, splat32 ]
    syntax: "%0%4 %1 = %2, %3%5"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE.X
    execution: *executionCWRRM
    behavior: *behaviorCWRRM
  - ID: ALU_DFWR
    what: ALU Double Floating-Point Write Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FNEGD, FABSD, FNEGW, FABSW, FNEGWP, FABSWP, FNEGHQ, FABSHQ ]": "0000..0111", FSRSRD: "1000", FSRSRW: "1010", FSRSRWP: "1100" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0010"
      - silent2: "_"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ } ]
    syntax: "%0 %1 = %2"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionDWR
    behavior: *behaviorDWR
## [ FRINTD, FROUNDD, FCEILD, FFLOORD, FTRUNCD ]
  - ID: ALU_FWR
    what: ALU Floating-Point Write Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FWIDENLWD, FWIDENMWD, FWIDENLHW, FWIDENMHW, FWIDENLHWP, FWIDENMHWP ]": "1000..1101" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0011"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: |
      stage ID:
      new silent = %3;
      stage RR:
      new argument2 = %2;
      @Instruction
      stage E1:
      if (silent == 0) {
        CS.IO |= finvalid();
      }
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.silent (ACCESS.ID.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (IF
          (EQ (READ.silent) (CONST.0))
          (SEQ
            (WRITE.CS_io
              (F2I.1 (LOAD.E4 (AGGL.CS (CONST.CS_IO) (CONST.1)))))
            (STORE.E4 (AGGL.CS (CONST.CS_IO) (CONST.1))
              (I2F.1
                (IOR
                  (APPLY.finvalid)
                  (READ.CS_io)))))
          (SKIP))
        (COMMIT.E1.%1
          (READ.result1)))
  - ID: ALU_HQFWR
    what: ALU Floating-Point Write Read Half Word Quadruple
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FSRECD: "0000", FSRECW: "0010", FSRECWP: "0100" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0100"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRSRD
    behavior: *behaviorWRSRD
  - ID: ALU_DFWRR
    what: ALU Double Floating-Point Write Read Read
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FSDIVD, FCDIVD, FSDIVW, FCDIVW, FSDIVWP, FCDIVWP ]": "0000..0101" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0101"
      - silent2: "-"
      - rounding2: "___"
      - exucode7: "__"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { silent: silent2 } ]
    syntax: "%0%3 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRSRD
    behavior: *behaviorWRSRD
  - ID: ALU_FWRWLL
    what: ALU Floating-Point Write Read Word Long Latency
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FRECW, FRSRW ]": "0010..0011" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_FULL
    execution: *executionWRSF
    behavior: *behaviorWRSF
  - ID: ALU_FWRW
    what: ALU Floating-Point Write Read Word
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FNARROWDW: "1000", FNARROWWH: "1010" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRE1
    behavior: *behaviorWRE1
  - ID: ALU_WPFWR
    what: ALU Floating-Point Write Word Read Word Pair
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { FNARROWDWP: "1100", FNARROWWHQ: "1110" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "0110"
      - silent2: "-"
      - rounding2: "---"
      - exucode7: "__"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { singleReg: registerW }, { pairedReg: registerP }, { rounding: rounding2 }, { silent: silent2 } ]
    syntax: "%0%3%4 %1 = %2"
    scheduling: ALU_LITE
    execution: *executionWRE1
    behavior: *behaviorWRE1
  - ID: ALU_DFWRD
    what: ALU Double Floating-Point Write Read Division
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { "[ FMIND, FMAXD, FMINW, FMAXW, FMINWP, FMAXWP, FMINHQ, FMAXHQ ]": "0000..0111" }
      - registerW: "------"
      - exucode4: "11"
      - exucode5: "1000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: ALU_LITE
    execution: *executionDWRR
    behavior: *behaviorDWRR
  - ID: ALU_NOP
    what: ALU No Operation
    fields:
      - parallel: "-"
      - steering: "11"
      - exubit28: "1"
      - exucode2: { NOP: "1111" }
      - registerW: "______"
      - exucode4: "11"
      - exucode5: "1111"
      - registerY: "______"
      - registerZ: "______"
    encoding: simple
    syntax: "%0"
    scheduling: ALU_NOP
  ## MAU: steering=10
  - ID: MAU_DDDI0
    what: MAU Double Double Double Immediate 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DDDI0.X
    what: MAU Double Double Double Immediate 0 Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DDDI0: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DDDI0.Y
    what: MAU Double Double Double Immediate 0 Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DDDI0: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.Y
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DDI
    what: MAU Double Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULD, MULWP, MULHQ, MULWC ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DDI.X
    what: MAU Double Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULD, MULWP, MULHQ, MULWC ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DDI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.X
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DDI.Y
    what: MAU Double Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULD, MULWP, MULHQ, MULWC ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DDI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.Y
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQDI
    what: MAU Quadruple Quadruple Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDDT, MADDUDT, MADDSUDT, MADDUZDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQDI.X
    what: MAU Quadruple Quadruple Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDDT, MADDUDT, MADDSUDT, MADDUZDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_QQDI: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQDI.Y
    what: MAU Quadruple Quadruple Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MADDDT, MADDUDT, MADDSUDT, MADDUZDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_QQDI: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.Y
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QDI
    what: MAU Quadruple Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULDT, MULUDT, MULSUDT, CMULDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QDI.X
    what: MAU Quadruple Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULDT, MULUDT, MULSUDT, CMULDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_QDI: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.X
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QDI.Y
    what: MAU Quadruple Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ MULDT, MULUDT, MULSUDT, CMULDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_QDI: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.Y
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DPI
    what: MAU Double Pair Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ DOT2WD, DOT2UWD, DOT2SUWD, DOT2W ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "00"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DPI.X
    what: MAU Double Pair Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ DOT2WD, DOT2UWD, DOT2SUWD, DOT2W ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DPI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.X
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DPI.Y
    what: MAU Double Pair Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ DOT2WD, DOT2UWD, DOT2SUWD, DOT2W ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "00"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_DPI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.Y
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_FDDDI
    what: MAU Floating-Point Double Double Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAD, FFMAWD, FFMAWP, FFMAHQ ]": "0000..0011", "[ FFMSD, FFMSWD, FFMSWP, FFMSHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDIE4
    behavior: *behaviorFDDDIE4
  - ID: MAU_FDDDI.X
    what: MAU Floating-Point Double Double Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAD, FFMAWD, FFMAWP, FFMAHQ ]": "0000..0011", "[ FFMSD, FFMSWD, FFMSWP, FFMSHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDDI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.X
    execution: *executionFDDDIE4
    behavior: *behaviorFDDDIE4
  - ID: MAU_FDDDI.Y
    what: MAU Floating-Point Double Double Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAD, FFMAWD, FFMAWP, FFMAHQ ]": "0000..0011", "[ FFMSD, FFMSWD, FFMSWP, FFMSHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDDI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.Y
    execution: *executionFDDDIE4
    behavior: *behaviorFDDDIE4
  - ID: MAU_FDDI
    what: MAU Floating-Point Double Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULD, FMULWD, FMULWP, FMULHQ ]": "1000..1011", "[ FDOT2W, FDOT2WD, FMULWC, FMULWC.C ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FDDI.X
    what: MAU Floating-Point Double Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULD, FMULWD, FMULWP, FMULHQ ]": "1000..1011", "[ FDOT2W, FDOT2WD, FMULWC, FMULWC.C ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.X
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FDDI.Y
    what: MAU Floating-Point Double Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULD, FMULWD, FMULWP, FMULHQ ]": "1000..1011", "[ FDOT2W, FDOT2WD, FMULWC, FMULWC.C ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.Y
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FDDI1
    what: MAU Floating-Point Double Double Immediate 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDD, FADDWP, FADDHQ, FADDWC.C ]": "0000..0011", "[ FSBFD, FSBFWP, FSBFHQ, FSBFWC.C ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FDDI1.X
    what: MAU Floating-Point Double Double Immediate 1 Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDD, FADDWP, FADDHQ, FADDWC.C ]": "0000..0011", "[ FSBFD, FSBFWP, FSBFHQ, FSBFWC.C ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDI1: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.X
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FDDI1.Y
    what: MAU Floating-Point Double Double Immediate 1 Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDD, FADDWP, FADDHQ, FADDWC.C ]": "0000..0011", "[ FSBFD, FSBFWP, FSBFHQ, FSBFWC.C ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FDDI1: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.Y
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FSSSI
    what: MAU Floating-Point Single Single Single Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAHW, FFMAW, FFMSHW, FFMSW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FSSSI.X
    what: MAU Floating-Point Single Single Single Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAHW, FFMAW, FFMSHW, FFMSW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FSSSI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.X
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FSSSI.Y
    what: MAU Floating-Point Single Single Single Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAHW, FFMAW, FFMSHW, FFMSW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FSSSI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.Y
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FSSI
    what: MAU Floating-Point Single Single Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDW, FSBFW, FMULW, FMULHW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FSSI.X
    what: MAU Floating-Point Single Single Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDW, FSBFW, FMULW, FMULHW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FSSI: 0..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.X
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FSSI.Y
    what: MAU Floating-Point Single Single Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FADDW, FSBFW, FMULW, FMULHW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FSSI: 0..31 }
    encoding: triple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.Y
    execution: *executionFDDIE4
    behavior: *behaviorFDDIE4
  - ID: MAU_FQQDI
    what: MAU Floating-Point Quadruple Quadruple Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAWDP, FFMAHWQ ]": "0000..0001", "[ FFMSWDP, FFMSHWQ ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FQQDI.X
    what: MAU Floating-Point Quadruple Quadruple Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAWDP, FFMAHWQ ]": "0000..0001", "[ FFMSWDP, FFMSHWQ ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FQQDI: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.X
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FQQDI.Y
    what: MAU Floating-Point Quadruple Quadruple Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FFMAWDP, FFMAHWQ ]": "0000..0001", "[ FFMSWDP, FFMSHWQ ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FQQDI: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR.Y
    execution: *executionFQQDI
    behavior: *behaviorFQQDI
  - ID: MAU_FQDI
    what: MAU Floating-Point Quadruple Double Immediate
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULWDP, FMULHWQ ]": "0000..0001", "[ FMULWDC, FMULWDC.C ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - signed10: "----------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, signed10 ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFQDI
    behavior: *behaviorFQDI
  - ID: MAU_FQDI.X
    what: MAU Floating-Point Quadruple Double Immediate Extended
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULWDP, FMULHWQ ]": "0000..0001", "[ FMULWDC, FMULWDC.C ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FQDI: 0..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { signed37: [ upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.X
    execution: *executionFQDI
    behavior: *behaviorFQDI
  - ID: MAU_FQDI.Y
    what: MAU Floating-Point Quadruple Double Immediate Extended Extended
    fields3:
      - parallel3: "-"
    fields2: *fieldsY
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FMULWDP, FMULHWQ ]": "0000..0001", "[ FMULWDC, FMULWDC.C ]": "0010..0011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - lower10: "----------"
      - registerZ: "------"
    samefields: { MAU_FQDI: 0..31 }
    encoding: triple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped64: [ extend27, upper27, lower10 ] } ]
    syntax: "%0 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU.Y
    execution: *executionFQDI
    behavior: *behaviorFQDI
  - ID: MAU_FDD
    what: MAU Floating-Point Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "0"
      - exucode2: { "[ FLOATD, FLOATUD, FIXEDD, FIXEDUD ]": "0100..0111", "[ FLOATW, FLOATUW, FIXEDW, FIXEDUW ]": "1000..1011", "[ FLOATWP, FLOATUWP, FIXEDWP, FIXEDUWP ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - unsigned6: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, unsigned6, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDE4
    behavior: *behaviorFDDE4
  - ID: MAU_DDDD0
    what: MAU Double Double Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010", "[ MSBFD, MSBFWP, MSBFHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DDDD0.M
    what: MAU Double Double Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDD, MADDWP, MADDHQ ]": "0000..0010", "[ MSBFD, MSBFWP, MSBFHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_DDDD0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1M
    behavior: *behaviorDW2RRR1M
  - ID: MAU_QQDD
    what: MAU Quadruple Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWDP, MADDUWDP, MADDSUWDP, MMA212W ]": "1000..1011", "[ MSBFWDP, MSBFUWDP, MSBFSUWDP, MMS212W ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0000"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQDD.M
    what: MAU Quadruple Quadruple Double Double Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWDP, MADDUWDP, MADDSUWDP, MMA212W ]": "1000..1011", "[ MSBFWDP, MSBFUWDP, MSBFSUWDP, MMS212W ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0000"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_QQDD: 12..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1M
    behavior: *behaviorDW2RRR1M
  - ID: MAU_QDD0
    what: MAU Quadruple Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWDP, MULUWDP, MULSUWDP, MM212W ]": "0000..0011" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QDD0.M
    what: MAU Quadruple Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWDP, MULUWDP, MULSUWDP, MM212W ]": "0000..0011" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_QDD0: 12..31 }
    encoding: double
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU.X
    execution: *executionDW2RRM
    behavior: *behaviorDW2RRM
  - ID: MAU_DDD0
    what: MAU Double Double Double 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULD, MULWP, MULHQ, MULWC ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DDD0.M
    what: MAU Double Double Double 0 Magic
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULD, MULWP, MULHQ ]": "0100..0110" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0001"
      - splat32: "-"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_DDD0: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] }, splat32 ]
    syntax: "%0 %1 = %2, %3%4"
    scheduling: MAU.X
    execution: *executionDW2RRM
    behavior: *behaviorDW2RRM
  - ID: MAU_QQDD1
    what: MAU Quadruple Quadruple Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDDT, MADDUDT, MADDSUDT, MADDUZDT ]": "1000..1011", "[ MSBFDT, MSBFUDT, MSBFSUDT, MSBFUZDT ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QDD1
    what: MAU Quadruple Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULDT, MULUDT, MULSUDT, CMULDT ]": "1000..1011" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQDD2
    what: MAU Quadruple Quadruple Double Double 2
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CMULXDT, CMULGLXDT, CMULGMXDT, CMULGHXDT ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "00"
      - exucode5: "0001"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QQQ
    what: MAU Quadruple Quadruple Quadruple
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ DOT2WDP, DOT2UWDP, DOT2SUWDP, DOT2WZP ]": "0000..0011", MULWQ: "0100" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0010"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DDD1
    what: MAU Double Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { MULWC.C: "0101" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QDD2
    what: MAU Quadruple Double Double 2
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWDC, MULWDC.C ]": "0110..0111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_CRC
    what: MAU CRC
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CRCBELMW, CRCBELLW, CRCLELMW, CRCLELLW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_CRC.W
    what: MAU CRC Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ CRCBELMW, CRCBELLW, CRCLELMW, CRCLELLW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_CRC: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_DPP
    what: MAU Double Pair Pair
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ DOT2WD, DOT2UWD, DOT2SUWD, DOT2W ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0010"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_SSSS
    what: MAU Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWD, MADDUWD, MADDSUWD, MADDW ]": "0000..0011", "[ MSBFWD, MSBFUWD, MSBFSUWD, MSBFW ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_SSSS.W
    what: MAU Single Single Single Single Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDWD, MADDUWD, MADDSUWD, MADDW ]": "0000..0011", "[ MSBFWD, MSBFUWD, MSBFSUWD, MSBFW ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_SSSS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR.X
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_SSS
    what: MAU Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWD, MULUWD, MULSUWD, MULW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_SSS.W
    what: MAU Single Single Single Wrapped
    fields2:
      - parallel2: "-"
    fields1: *fieldsX
    fields:
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULWD, MULUWD, MULSUWD, MULW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "00"
      - exucode5: "0011"
      - splat32: "0"
      - lower5: "-----"
      - registerZ: "------"
    samefields: { MAU_SSS: 12..31 }
    encoding: double
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { wrapped32: [ upper27, lower5 ] } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU.X
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_QQDD3
    what: MAU Quadruple Quadruple Double Double 3
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MADDHWQ, MADDUHWQ, MADDSUHWQ ]": "0000..0010", "[ MSBFHWQ, MSBFUHWQ, MSBFSUHWQ ]": "0100..0110" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU_AUXR
    execution: *executionDW2RRR1
    behavior: *behaviorDW2RRR1
  - ID: MAU_QDD3
    what: MAU Quadruple Double Double 3
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ MULHWQ, MULUHWQ, MULSUHWQ ]": "1000..1010" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "0100"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: *executionDW2RR
    behavior: *behaviorDW2RR
  - ID: MAU_DIVREM
    what: MAU Integer Division and Remainder
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - scalarcond: "----"
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: { "[ DIVREMD, DIVREMUD, DIVREMW, DIVREMUW ]": "1000..1011" }
      - registerY: "------"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ scalarcond, { pairedReg: registerM }, { pairedReg: registerP }, { singleReg: registerY } ]
    syntax: "%0%1 %3? %2 = %4"
    scheduling: MAU
    execution: |
      stage ID:
      new argument1 = %1;
      stage RR:
      new argument4 = %2;
      new argument4_l = _ZX_64(argument4);
      new argument4_m = _ZX_64(argument4 >> 64);
      new argument3 = %3;
      stage E1:
      if (scalarcond(argument1, argument3)) {
        @Instruction
      stage SF:
        %2 = (result2_m << 64) | _ZX_64(result2_l);
      }
    behavior: |
      (SEQ
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.SF.%1
          (IOR
            (SHL (READ.result2_m) (CONST.64))
            (ZX.64 (READ.result2_l)))))
  - ID: MAU_COPYQ
    what: MAU Copy Quadruple Word
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { COPYQ: "1111" }
      - registerM: "-----"
      - exubit18: "_"
      - exucode4: "00"
      - exucode5: "1111"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY } ]
    syntax: "%0 %1 = %2, %3"
    scheduling: MAU
    execution: |
      stage RR:
      new argument3 = %3;
      new argument2 = %2;
      @Instruction
      stage E2:
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.argument3 (ACCESS.RR.%3))
        (WRITE.argument2 (ACCESS.RR.%2))
        (MACRO.Instruction)
        (COMMIT.E2.%1 (READ.result1)))
  - ID: MAU_FDDDD
    what: MAU Floating-Point Double Double Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAD, FFMAWD, FFMAWP, FFMAHQ ]": "0000..0011", "[ FFMSD, FFMSWD, FFMSWP, FFMSHQ ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDDE4
    behavior: *behaviorFDDDDE4
  - ID: MAU_FDDD
    what: MAU Floating-Point Double Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FMULD, FMULWD, FMULWP, FMULHQ ]": "1000..1011", "[ FDOT2W, FDOT2WD, FMULWC, FMULWC.C ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "01"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDDE4
    behavior: *behaviorFDDDE4
  - ID: MAU_FDDD1
    what: MAU Floating-Point Double Double Double 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDD, FADDWP, FADDHQ, FADDWC.C ]": "0000..0011", "[ FSBFD, FSBFWP, FSBFHQ, FSBFWC.C ]": "0100..0111" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFDDDE4
    behavior: *behaviorFDDDE4
  - ID: MAU_FSSSS
    what: MAU Floating-Point Single Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAHW, FFMAW, FFMSHW, FFMSW ]": "1000..1011" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFDDDDE4
    behavior: *behaviorFDDDDE4
  - ID: MAU_FSSS
    what: MAU Floating-Point Single Single Single
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDW, FSBFW, FMULW, FMULHW ]": "1100..1111" }
      - registerW: "------"
      - exucode4: "10"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { singleReg: registerW }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQDD
    what: MAU Floating-Point Quadruple Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FFMAWDP, FFMAHWQ ]": "0000..0001", "[ FFMSWDP, FFMSHWQ ]": "0010..0011", FMMA212W: "0100", FMMS212W: "0110" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFQQDD
    behavior: *behaviorFQQDD
  - ID: MAU_FQDD
    what: MAU Floating-Point Quadruple Double Double
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FMULWDP, FMULHWQ ]": "0000..0001", "[ FMULWDC, FMULWDC.C ]": "0010..0011", FMM212W: "0100" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerY: "------"
      - registerZ: "------"
    encoding: simple
    operands: [ { pairedReg: registerM }, { singleReg: registerZ }, { singleReg: registerY }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQQ0
    what: MAU Floating-Point Quadruple Quadruple Quadruple 0
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDDP, FADDDC.C, FSBFDP, FSBFDC.C ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "0"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFSSS
    behavior: *behaviorFSSS
  - ID: MAU_FQQQ1
    what: MAU Floating-Point Quadruple Quadruple Quadruple 1
    fields:
      - parallel: "-"
      - steering: "10"
      - exubit28: "1"
      - exucode2: { "[ FADDWQ, FADDWCP.C, FSBFWQ, FSBFWCP.C ]": "1000..1011", "[ FDOT2WDP, FDOT2WZP, FMULWQ, FMULDP ]": "1100..1111" }
      - registerM: "-----"
      - exubit18: "1"
      - exucode4: "11"
      - silent: "-"
      - rounding: "---"
      - registerO: "-----"
      - exubit6: "_"
      - registerP: "-----"
      - exubit0: "_"
    encoding: simple
    operands: [ { pairedReg: registerM }, { pairedReg: registerP }, { pairedReg: registerO }, rounding, silent ]
    syntax: "%0%4%5 %1 = %2, %3"
    properties: { '%CS': NoEffects }
    scheduling: MAU_AUXR
    execution: *executionFSSS
    behavior: *behaviorFSSS
Generic:
Immediate:
  - ID: pcrel11
    what: CCB Offset
    relative: PC
    execution: "(_SX_11(%0)<<2)"
  - ID: pcrel17
    what: CB Offset
    relative: PC
    execution: "(_SX_17(%0)<<2)"
  - ID: pcrel27
    what: GOTO / CALL Offset
    relative: PC
    execution: "(_SX_27(%0)<<2)"
  - ID: pcrel38
    what: CCB Offset Extended
    relative: PC
    execution: "(_SX_38(%0)<<2)"
  - ID: sysnumber
    what: System Number
    execution: "_ZX_12(%0)"
  - ID: unsigned6
    what: Zero Extended Immediate 6 bits
    shortName: u6
    execution: "_ZX_6(%0)"
  - ID: signed10
    what: Sign Extended Immediate 10 bits
    shortName: s10
    execution: "_SX_10(%0)"
  - ID: signed16
    what: Sign Extended Immediate 16 bits
    shortName: s16
    execution: "_SX_16(%0)"
  - ID: signed27
    what: Sign Extended Immediate 27 bits
    shortName: s27
    execution: "_SX_27(%0)"
  - ID: wrapped32
    what: Wrapped Immediate 32 bits
    shortName: w32
    execution: "_WX_32(%0)"
  - ID: signed37
    what: Sign Extended Immediate 37 bits
    shortName: s37
    execution: "_SX_37(%0)"
  - ID: signed43
    what: Sign Extended Immediate 43 bits
    shortName: s43
    execution: "_SX_43(%0)"
  - ID: signed54
    what: Sign Extended Immediate 54 bits
    shortName: s54
    execution: "_SX_54(%0)"
  - ID: wrapped64
    what: Wrapped Immediate 64 bits
    shortName: w64
    execution: "_WX_64(%0)"
Instruction:
  - ID: AWAIT
    what: Wait for any event or interrupt.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU0} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      idle(0);
    behavior: |
      (EFFECT.RR.idle (CONST.0))
  - ID: SLEEP
    what: Wait for an eligible interrupt.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU1} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      idle(1);
    behavior: |
      (EFFECT.RR.idle (CONST.1))
  - ID: STOP
    what: Wait for power controller wake-up.
    formats: [ BCU_IPC ]
    description: >
      Wait until \textbf{WS.WU2} equals one (cf Idle Modes chapter).
      The main core clock is gated during the waiting period to reduce power consumption.
    execution: |
      stage RR:
      if (stop_owner()) {
        idle(2);
      } else {
        _THROW(PRIVILEGE);
      }
    behavior: |
      (SEQ
        (IF
          (TEST.stop_owner)
          (EFFECT.RR.idle (CONST.2))
          (THROW.RR.PRIVILEGE)))
  - ID: BARRIER
    what: Instruction Pipeline Barrier
    formats: [ BCU_IPC ]
    properties: { '%0': MemoryFence }
    description: >
      Flush the core instruction pipeline and memory system.
    execution: |
      stage RR:
      barrier();
    behavior: |
      (EFFECT.RR.barrier)
  - ID: TLBREAD
    what: Read TLB Entry
    formats: [ BCU_TLB ]
    description: >
      Read the TLB entry into the TEL:TEH register pair using MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        readtlb();
      }
    behavior: |
      (SEQ
        (IF (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.readtlb)))
  - ID: TLBPROBE
    what: Probe TLB
    formats: [ BCU_TLB ]
    description: >
      Probe the TLB for virtual address match in the TEL:TEH register pair and write to MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        probetlb();
      }
    behavior: |
      (SEQ
        (IF
          (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.probetlb)))
  - ID: TLBWRITE
    what: TLB Entry Write
    formats: [ BCU_TLB ]
    properties: { '%0': Privilege }
    schedulings: [ ALL ]
    description: >
      Write the TLB entry from the TEL:TEH register pair using MMC.IDX.
    execution: |
      if (!mmi_owner()) {
        _THROW(PRIVILEGE);
      } else {
        writetlb();
      }
    behavior: |
      (SEQ
        (IF
          (NOTL (TEST.mmi_owner))
          (THROW.ID.PRIVILEGE)
          (EFFECT.ID.writetlb)))
  - ID: TLBDINVAL
    what: Invalidate Data Micro-TLB.
    formats: [ BCU_TLB ]
    description: >
      Invalidate Data Micro-TLB.
    execution: |
      stage RR:
      invaldtlb();
    behavior: |
      (EFFECT.RR.invaldtlb)
  - ID: TLBIINVAL
    what: Invalidate Instruction Micro-TLB.
    formats: [ BCU_TLB ]
    description: >
      Invalidate Instruction Micro-TLB.
    execution: |
      stage RR:
      invalitlb();
    behavior: |
      (EFFECT.RR.invalitlb)
  - ID: ERROP
    what: Error Opcode
    formats: [ BCU_NOB ]
    description: >
      Invalid opcode, should always trap.
    execution: |
      stage RR:
      _THROW(OPCODE);
    behavior: |
      (THROW.RR.OPCODE)
  - ID: RET
    what: Return from Call
    formats: [ BCU_RTS ]
    description: >
      The next bundle \textbf{PC} is obtained by reading the contents of the \textbf{RA} register.
    execution: |
      stage ID:
      NPC = RA;
    behavior: |
      (SEQ
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (LOAD.ID (AGGL.SFR (CONST.RA) (CONST.1))))
        (EFFECT.RR.branch_info (CONST.1)
          (F2I.64 (LOAD.ID (AGGL.SFR (CONST.RA) (CONST.1)))))
      )
  - ID: RFE
    what: Return from Exception
    formats: [ BCU_RTS ]
    properties: { '%0': Privilege }
    schedulings: [ ALL ]
    description: >
      The \textbf{PS} is restored from the \textbf{SPS}.
      The \textbf{SPS} is restored from the \textbf{SSPS}.
      The next bundle \textbf{PC} is obtained by reading the contents of the \textbf{SPC} register.
      The \textbf{SPC} is restored from the \textbf{SSPC}.
    execution: |
      stage ID:
      if (rfe_owner()) {
        rfe();
      }
    behavior: |
      (SEQ
        (IF
          (TEST.rfe_owner)
          (SEQ
            (EFFECT.RR.rfe)
            (EFFECT.RR.branch_info (CONST.1)
              (F2I.64 (LOAD.ID (AGGL.SFR (CONST.SPC) (CONST.1)))))
          )
          (SKIP)))
  - ID: IGOTO
    what: Indirect Branch from Register
    formats: [ BCU_IBC ]
    description: >
      The next bundle \textbf{PC} is computed by reading the %1.
    execution: |
      stage RR:
      NPC = argument1;
    behavior: |
      (SEQ
        (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.argument1)))
        (EFFECT.RR.branch_info (CONST.1) (READ.argument1))
        )
  - ID: ICALL
    what: Indirect Call from Register
    formats: [ BCU_IBC ]
    description: >
      The sequential next bundle \textbf{PC} is copied into the \textbf{RA} register.
      The next bundle \textbf{PC} is computed by reading the %1.
    execution: |
      stage ID:
      new next = NPC;
      stage RR:
      NPC = argument1;
      RA = next;
    behavior: |
      (SEQ
        (WRITE.next
          (F2I.64 (LOAD.ID (AGGL.NPC (CONST.0) (CONST.1)))))
        (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.argument1)))
        (STORE.RR (AGGL.SFR (CONST.RA) (CONST.1))
          (I2F.64 (READ.next)))
        (EFFECT.RR.branch_info (CONST.1) (READ.argument1)))
  - ID: SCALL
    what: System Call
    formats: [ BCU_SCR, BCU_SCI ]
    description: >
      System call with number %2. Interrupts are disabled.
    execution: |
      stage ID:
      syscall(argument1);
    behavior: |
      (SEQ
        (EFFECT.ID.syscall (READ.argument1))
        (EFFECT.ID.branch_info (CONST.1) (READ.argument1)))
  - ID: LOOPDO
    what: Hardware Loop setup and Do execute
    formats: [ BCU_HLS ]
    description: >
      If \textbf{PS.HLE} is cleared, this instruction throws an OPCODE trap.
      The \textbf{LS} register is set to the sequential next bundle \textbf{PC}. The \textbf{LE} register is set to
      the current bundle \textbf{PC} plus the %2 after sign extension and scaling by 4. The \textbf{LC} register is set with the %1.
      If the \textbf{PS.HLE} bit is set in the \textbf{PS} register, hardware loop execution proceeds by comparing
      the sequential next bundle \textbf{PC} to the value of the \textbf{LE} register:
      \begin{itemize}
      \item If different, the next bundle \textbf{PC} is computed as usual.
      \item If the sequential next bundle \textbf{PC} equals the value of the \textbf{LE} register: \begin{itemize}
        \item If the value of the \textbf{LC} register ${}-1$ is non-zero, the value of the next bundle \textbf{PC}
        is read from the \textbf{LS} register, unless a branch is taken in the current bundle (in which case the next bundle \textbf{PC} is the branch target bundle \textbf{PC}).
        \item If the value of the \textbf{LC} register ${}-1$ is zero, the value of the next bundle \textbf{PC} is
        the value of the \textbf{LE} register, unless a branch is taken in the current bundle (in which case the next bundle \textbf{PC} is the branch target bundle \textbf{PC}).
        \item The \textbf{LC} register is decremented if its value is not already zero.
        \end{itemize}
      \end{itemize}
      According to these rules, the LOOPDO instruction loops forever whenever the value of the %1 is zero, as the
      the value of the \textbf{LC} register ${}-1$ is always non-zero, while the \textbf{LC} register is never decremented.
      This instruction is provided for counted loops which iterate at least once, and while loops by setting the counter to zero.
    execution: |
      stage ID:
      if (!PS.HLE) {
        _THROW(OPCODE);
      } else {
        LS = NPC;
        LE = PC + _SX_32(argument2);
        LC = _ZX_64(argument1);
      }
    behavior: |
      (SEQ
        (IF (NOTL (I2B (F2I.1 (LOAD.ID (AGGL.PS (CONST.PS_HLE) (CONST.1))))))
          (THROW.ID.OPCODE)
          (SKIP))
        (STORE.E2 (AGGL.SFR (CONST.LS) (CONST.1))
          (LOAD.E2 (AGGL.NPC (CONST.0) (CONST.1))))
        (STORE.E2 (AGGL.SFR (CONST.LE) (CONST.1))
          (I2F.64
            (ADD
              (F2I.64 (LOAD.E2 (AGGL.PC (CONST.0) (CONST.1))))
              (SX.32 (READ.argument2)))))
        (EFFECT.ID.invalpfb)
        (STORE.ID (AGGL.SFR (CONST.LC) (CONST.1))
          (I2F.64 (ZX.64 (READ.argument1))))))
  - ID: WFXL
    what: Effects on Least Significant Word of System Register
    formats: [ BCU_WFX, BCU_WFXA, BCU_WFXHW ]
    description: >
      The least significant word of the %1 is operated, with the most significant word of the %2
      as a set mask and the least significant word of the %2 as a clear mask.
    execution: |
      if (wfxl_check_access(@1, @2)) {
        new setmask = argument2.32[1];
        new clrmask = argument2.32[0];
        result1 = (argument1 & ~clrmask) | setmask;
      }
    behavior: |
      (SEQ
        (IF (TEST.wfxl_check_access (METHOD.%1) (METHOD.%2))
          (WRITE.result1
            (APPLY.wfxl (METHOD.%1) (ZX.64 (READ.argument2))))
          (SKIP)))
  - ID: WFXM
    what: Word Effects on Most Significant Word of System Register
    formats: [ BCU_WFX, BCU_WFXA, BCU_WFXHW ]
    description: >
      The most significant word of the %1 is operated, with the most significant word of the %2
      as a set mask and the least significant word of the %2 as a clear mask.
    execution: |
      if (wfxm_check_access(@1, @2)) {
        new setmask = argument2.32[1] << 32;
        new clrmask = argument2.32[0] << 32;
        result1 = (argument1 & ~clrmask) | setmask;
      }
    behavior: |
      (SEQ
        (IF (TEST.wfxm_check_access (METHOD.%1) (METHOD.%2))
          (WRITE.result1
            (APPLY.wfxm (METHOD.%1) (ZX.64 (READ.argument2))))
          (SKIP)))
  - ID: GET
    what: Get System Register
    formats: [ BCU_GSR, BCU_GSRHW ]
    description: >
      The %1 is copied from the %2 register.
    execution: |
      stage RR:
      if (get_check_access(@2, @1)) {
        new result1 = get(@2, _ZX_64(argument2));
      }
    behavior: |
      (IF (TEST.get_check_access (METHOD.%2) (METHOD.%1))
        (WRITE.result1
          (APPLY.get (METHOD.%2) (ZX.64 (READ.argument2))))
        (SKIP))
  - ID: IGET
    what: Indirect Get System Register
    formats: [ BCU_IGSR ]
    description: >
      The %1 is copied from the system register whose index is in the %1.
    execution: |
      stage RR:
      if (get_check_access(index, @1)) {
        new result1 = get(index, SFR[index]);
      }
    behavior: |
      (IF (TEST.get_check_access (READ.index) (METHOD.%1))
        (WRITE.result1
          (APPLY.get
            (READ.index) (F2I.64 (LOAD.RR (AGGL.SFR (READ.index) (CONST.1))))))
        (SKIP))
  - ID: SET
    what: Set System Register
    formats: [ BCU_SET, BCU_SETA, BCU_SETRA, BCU_SETHW ]
    description: >
      The %1 register is set with the %2.
    execution: |
      stage RR:
      if (set_check_access(@1, argument2, @2)) {
        new result1 = _ZX_64(argument2);
        stage E3:
        %1 = result1;
      }
    behavior: |
      (IF (TEST.set_check_access (METHOD.%1) (ZX.64 (READ.argument2)) (METHOD.%2))
        (SEQ
          (WRITE.result1 (ZX.64 (READ.argument2)))
          (COMMIT.E3.%1 (READ.result1)))
        (SKIP))
  - ID: RSWAP
    what: General and System Register Swap
    formats: [ BCU_RSWAP, BCU_RSWAPA, BCU_RSWAPHW ]
    description: >
      The contents of the %1 are swapped set with the contents of the %2.
    execution: |
      stage E1:
      new result2 = _ZX_64(argument1);
      new result1 = _ZX_64(argument2);
    behavior: |
      (IF (ANDL
            (TEST.get_check_access (METHOD.%2) (METHOD.%1))
            (TEST.set_check_access (METHOD.%2) (ZX.64 (READ.argument1)) (METHOD.%1)))
        (SEQ
          (WRITE.result2 (ZX.64 (READ.argument1)))
          (WRITE.result1 (ZX.64 (READ.argument2)))
          (COMMIT.E1.%1 (READ.result1))
          (COMMIT.E1.%2 (READ.result2)))
        (SKIP))
  - ID: WAITIT
    what: Wait for Interrupt
    formats: [ BCU_PGI ]
    schedulings: [ BCU_TINY_TINY_MAU_XNOP ]
    description: >
      Execution waits for selected interrupts in the \textbf{ILR} register (masking non-owned interrupts, i.e. interrupts that belong to a more privileged PL. The %1 is interpreted as an OR-mask in the
      least significant word and a AND-mask in the most significant word. The wait ends if all the bits in \textbf{ILR}
      match the non-zero AND-mask, or if any bit in \textbf{ILR} matches the non-zero OR-mask.
      When the wait is over, the value of \textbf{ILR} (masked in the same way) is written to the %1.
      When both the AND-mask and OR-mask are zero, no wait happens.
    execution: |
      stage RR:
      new ormask = argument1 & 0xFFFFFFFF;
      new andmask = argument1.32[1];
      new result1 = waitit(ormask, andmask);
      %1 = result1;
    behavior: |
      (SEQ
        (WRITE.ormask
          (AND (READ.argument1) (CONST.0xFFFFFFFF)))
        (WRITE.andmask
          (READ.32[1].argument1))
        (WRITE.result1
          (APPLY.waitit (READ.ormask) (READ.andmask)))
        (COMMIT.RR.%1 (READ.result1)))
  - ID: SYNCGROUP
    what: Synchronize Group of Cores
    formats: [ BCU_PGI ]
    description: >
      The %1 is interpreted as four 16-bit fields: \textbf{waitclrF}, \textbf{waitclrB}, \textbf{notifyF}, \textbf{notifyB}.
      Upon executing the instruction, the core waits until all the events designated by bits in \textbf{waitclrF} and
      \textbf{waitclrB} in the 32 least-significant bits of \textbf{IPE} are set. When all the designated events are set, the core
      clears them, then notifies the event lines corresponding to the bit sets in fields \textbf{notifyF} and and \textbf{notifyB}.
      This notification of events is not registered in the core, it is a signal sent to set bits into the \textbf{IPE.FE} and
      \textbf{IPE.BE} fields of the destination cores. The successor core always receives the \textbf{notifyF} events in its
      \textbf{IPE.FE} field; likewise, the predecessor core always receives the \textbf{notifyB} events in its \textbf{IPE.BE} field.
      Furthermore, other PEs may receive these events, depending on the setting of the \textbf{IPE.FM} and \textbf{IPE.BM} fields
      in these neighbor PE cores.
    execution: |
      stage RR:
      if (!syncgroup_owner()) {
        _THROW(PRIVILEGE);
      } else {
        new waitclrF = argument1 & 0xFFFF;
        new waitclrB = (argument1 >> 16) & 0xFFFF;
        new notifyF = (argument1 >> 32) & 0xFFFF;
        new notifyB = (argument1 >> 48) & 0xFFFF;
        syncgroup(waitclrF, waitclrB, notifyF, notifyB);
      }
    behavior: |
      (IF
        (NOTL (TEST.syncgroup_owner))
        (THROW.RR.PRIVILEGE)
        (SEQ
          (WRITE.waitclrF
            (AND (READ.argument1) (CONST.0xFFFF)))
          (WRITE.waitclrB
            (AND (SHR (READ.argument1) (CONST.16)) (CONST.0xFFFF)))
          (WRITE.notifyF
            (AND (SHR (READ.argument1) (CONST.32)) (CONST.0xFFFF)))
          (WRITE.notifyB
            (AND (SHR (READ.argument1) (CONST.48)) (CONST.0xFFFF)))
          (EFFECT.RR.syncgroup
            (READ.waitclrF)
            (READ.waitclrB)
            (READ.notifyF)
            (READ.notifyB))))
  - ID: GOTO
    what: Branch Unconditional PC-Relative
    formats: [ BCU_UB ]
    description: >
      The next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC} the %1
      after sign extension and scaling by 4.
    execution: |
      stage ID:
      NPC = PC + _SX_32(argument1);
    behavior: |
      (SEQ
        (WRITE.address
          (ADD
            (F2I.64 (LOAD.ID (AGGL.PC (CONST.0) (CONST.1))))
            (SX.32 (READ.argument1)))))
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.address)))
        (EFFECT.ID.branch_info (CONST.1) (READ.address))
      )
  - ID: CALL
    formats: [ BCU_UB ]
    what: Call Subroutine PC-Relative
    description: >
      The sequential next bundle \textbf{PC} is copied into the \textbf{RA} register.
      The next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC} the %1
      after sign extension and scaling by 4.
    execution: |
      stage ID:
      new next = NPC;
      NPC = PC + _SX_32(argument1);
      stage RR:
      RA = next;
    behavior: |
      (SEQ
        (WRITE.next
          (F2I.64 (LOAD.ID (AGGL.NPC (CONST.0) (CONST.1)))))
        (WRITE.address
          (ADD
            (F2I.64 (LOAD.ID (AGGL.PC (CONST.0) (CONST.1))))
            (SX.32 (READ.argument1))))
        (STORE.ID (AGGL.NPC (CONST.0) (CONST.1))
          (I2F.64 (READ.address)))
        (STORE.RR (AGGL.SFR (CONST.RA) (CONST.1))
          (I2F.64 (READ.next)))
        (EFFECT.ID.branch_info (CONST.1) (READ.address)))
  - ID: CB
    what: Conditional Branch PC-Relative
    formats: [ BCU_CB ]
    description: >
      If %2 satisfies condition %1, the next bundle \textbf{PC} is computed by adding to the current bundle \textbf{PC}
      the %3 after sign extension and scaling by 4.
    execution: |
      stage RR:
      if (scalarcond(argument1, argument2)) {
        NPC = PC + argument3;
      }
    behavior: |
      (IF
        (TEST.scalarcond (READ.argument1) (READ.argument2))
        (SEQ
          (WRITE.address
            (ADD
              (F2I.64 (LOAD.RR (AGGL.PC (CONST.0) (CONST.1))))
              (SX.64 (READ.argument3))))
          (STORE.RR (AGGL.NPC (CONST.0) (CONST.1))
            (I2F.64 (READ.address)))
          (EFFECT.RR.branch_info (CONST.1) (READ.address))
        )
        (EFFECT.RR.branch_info (CONST.0) (CONST.0)))
  - ID: LBZ
    what: Load Byte Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %1 is loaded from the memory byte at the effective address after zero extension.
    execution: |
      new result1 = _ZX_8(MEM.load(address, 0x1, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.8
          (APPLY.8.MEM_load
            (READ.address)
            (CONST.0x1)
            (READ.variant)
            (METHOD.%1))))
  - ID: LBS
    what: Load Byte Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %1 is loaded from the memory byte at the effective address after sign extension.
    execution: |
      new result1 = _SX_8(MEM.load(address, 0x1, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.8
          (APPLY.8.MEM_load
            (READ.address)
            (CONST.0x1)
            (READ.variant)
            (METHOD.%1))))
  - ID: LHZ
    what: Load Half Word Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %1 is loaded from the memory half word at the effective address after zero extension.
    execution: |
      new result1 = _ZX_16(MEM.load(address, 0x3, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.16
          (APPLY.16.MEM_load
            (READ.address)
            (CONST.0x3)
            (READ.variant)
            (METHOD.%1))))
  - ID: LHS
    what: Load Half Word Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %1 is loaded from the memory half word at the effective address after sign extension.
    execution: |
      new result1 = _SX_16(MEM.load(address, 0x3, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.16
          (APPLY.16.MEM_load
            (READ.address)
            (CONST.0x3)
            (READ.variant)
            (METHOD.%1))))
  - ID: LWZ
    what: Load Word Zero Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %1 is loaded from the memory word at the effective address after zero extension.
    execution: |
      new result1 = _ZX_32(MEM.load(address, 0xF, variant, @1));
    behavior: |
      (WRITE.result1
        (ZX.32
          (APPLY.32.MEM_load
            (READ.address)
            (CONST.0xF)
            (READ.variant)
            (METHOD.%1))))
  - ID: LWS
    what: Load Word Sign Extended
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %1 is loaded from the memory word at the effective address after sign extension.
    execution: |
      new result1 = _SX_32(MEM.load(address, 0xF, variant, @1));
    behavior: |
      (WRITE.result1
        (SX.32
          (APPLY.32.MEM_load
            (READ.address)
            (CONST.0xF)
            (READ.variant)
            (METHOD.%1))))
  - ID: LD
    what: Load Double Word
    formats: [ LSU_LSBO, LSU_LSBO.X, LSU_LSBO.Y, LSU_LSPB, LSU_LSPB.O, LSU_LSPB.Y, LSU_LSBI ]
    properties: { '%0': MemorySize=8 }
    description: >
      The %1 is loaded from the memory double word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFF, variant, @1);
    behavior: |
      (WRITE.result1
        (APPLY.64.MEM_load
            (READ.address)
            (CONST.0xFF)
            (READ.variant)
            (METHOD.%1)))
  - ID: LQ
    what: Load Quadruple Word
    formats: [ LSU_LQBO, LSU_LQBO.X, LSU_LQBO.Y, LSU_LQPB, LSU_LQPB.O, LSU_LQPB.Y, LSU_LQBI ]
    properties: { '%0': MemorySize=16 }
    description: >
      The %1 is loaded from the memory quadruple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFF, variant, @1 << 1);
    behavior: |
      (WRITE.result1
        (APPLY.128.MEM_load
            (READ.address)
            (CONST.0xFFFF)
            (READ.variant)
            (SHL (METHOD.%1) (CONST.1))))
  - ID: LO
    what: Load Octuple Word
    formats: [ LSU_LOBO, LSU_LOBO.X, LSU_LOBO.Y, LSU_LOPB, LSU_LOPB.O, LSU_LOPB.Y, LSU_LOBI ]
    properties: { '%0': MemorySize=32 }
    description: >
      The %1 is loaded from the memory octuple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFFFFFF, variant, @1 << 2);
    behavior: |
      (WRITE.result1
        (APPLY.256.MEM_load
          (READ.address)
          (CONST.0xFFFFFFFF)
          (READ.variant)
          (SHL (METHOD.%1) (CONST.2))))
  - ID: XLO
    what: Extension Load Octuple Word Uncached
    formats: [ LSU_XLOBO, LSU_XLOBO.X, LSU_XLOBO.Y, LSU_XLQB, LSU_XLQB.O, LSU_XLQB.Y, LSU_XLBI, LSU_XLSBO, LSU_XLSBO.X, LSU_XLSBO.Y, LSU_XLSPB, LSU_XLSPB.O, LSU_XLSPB.Y, LSU_XLSBI ]
    properties: { '%0': Extension;MemorySize=32;MemoryLevel=2 }
    description: >
      The %1 is loaded from the memory octuple word at the effective address.
    execution: |
      new result1 = MEM.load(address, 0xFFFFFFFF, variant, dri);
    behavior: |
      (WRITE.result1
        (APPLY.256.MEM_load
          (READ.address)
          (CONST.0xFFFFFFFF)
          (READ.variant)
          (READ.dri)))
  - ID: SB
    what: Store Byte
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.Y ]
    properties: { '%0': MemorySize=1 }
    description: >
      The %3 is stored into the memory byte at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0x1, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0x1)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SH
    what: Store Half Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.Y ]
    properties: { '%0': MemorySize=2 }
    description: >
      The %3 is stored into the memory half word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0x3, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0x3)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SW
    what: Store Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.Y ]
    properties: { '%0': MemorySize=4 }
    description: >
      The %3 is stored into the memory word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xF, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xF)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SD
    what: Store Double Word
    formats: [ LSU_SSBO, LSU_SSBO.X, LSU_SSBO.Y, LSU_SSBI, LSU_SSPB, LSU_SSPB.O, LSU_SSPB.Y ]
    properties: { '%0': MemorySize=8 }
    description: >
      The %3 is stored into the memory double word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFF, 0, argument3, @3);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFF)
        (CONST.0)
        (READ.argument3)
        (METHOD.%3))
  - ID: SQ
    what: Store Quadruple Word
    formats: [ LSU_SQBO, LSU_SQBO.X, LSU_SQBO.Y, LSU_SQBI, LSU_SQPB, LSU_SQPB.O, LSU_SQPB.Y ]
    properties: { '%0': MemorySize=16 }
    description: >
      The %3 is stored into the memory quadruple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFF, 0, argument3, @3 << 1);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFFFF)
        (CONST.0)
        (READ.argument3)
        (SHL (METHOD.%3) (CONST.1)))
  - ID: SO
    what: Store Octuple Word
    formats: [ LSU_SOBO, LSU_SOBO.X, LSU_SOBO.Y, LSU_SOBI, LSU_SOPB, LSU_SOPB.O, LSU_SOPB.Y ]
    properties: { '%0': MemorySize=32 }
    description: >
      The %3 is stored into the memory octuple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFFFFFF, 0, argument3, @3 << 2);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFFFFFFFF)
        (CONST.0)
        (READ.argument3)
        (SHL (METHOD.%3) (CONST.2)))
  - ID: XSO
    what: Extension Store Octuple Word
    formats: [ LSU_XSOBO, LSU_XSOBO.X, LSU_XSOBO.Y, LSU_XSOBI, LSU_XSQB, LSU_XSQB.O, LSU_XSQB.Y ]
    properties: { '%0': Extension;MemorySize=32 }
    description: >
      The %3 is stored into the memory octuple word at the effective address.
    execution: |
      stage E3:
      MEM.store(address, 0xFFFFFFFF, 0, argument3, dri);
    behavior: |
      (EFFECT.E3.MEM_store
        (READ.address)
        (CONST.0xFFFFFFFF)
        (CONST.0)
        (READ.argument3)
        (READ.dri))
  - ID: ACSWAPW
    what: Atomic Compare and Swap Word
    formats: [ LSU_APBO, LSU_APBO.X, LSU_APBO.Y, LSU_APBI, LSU_APPB, LSU_APPB.O, LSU_APPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      This instruction implements Compare-And-Swap (CAS) on memory word with word aligned address.
      The %3 is interpreted as the concatenation of \texttt{update} (low 64 bits) and \texttt{expected} (high 64 bits).
      The memory word at the effective address is read into \texttt{current}.
      If \texttt{current} equals \texttt{expected}, the swap is successful and \texttt{update}
      is stored into the memory word at the effective address. Otherwise, the swap has failed and the memory is not updated.
      The instruction status is defined as the true/false value of success in case \texttt{boolcas} is true, or
      the \texttt{current} value in case \texttt{boolcas} is false.
      The concatenation of the status (low 64 bits) and \texttt{expected} (high 64 bits) is returned into the %3.
    execution: |
      new update = _ZX_64(argument3);
      new expected = _ZX_64(argument3 >> 64);
      new success = MEM.atomic_cas(address, 0xF, boolcas, update.32[0], expected.32[0], @3 << 1);
      new result3 = (expected << 64) | _ZX_64(success);
    behavior: |
      (SEQ
        (WRITE.update
          (ZX.64 (READ.argument3)))
        (WRITE.expected
          (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.success
          (APPLY.64.MEM_atomic_cas
            (READ.address)
            (CONST.0xF)
            (READ.boolcas)
            (READ.32[0].update)
            (READ.32[0].expected)
            (SHL (METHOD.%3) (CONST.1))))
        (WRITE.result3
          (IOR
            (SHL (READ.expected) (CONST.64))
            (ZX.64 (READ.success)))))
  - ID: ACSWAPD
    what: Atomic Compare and Swap Double Word
    formats: [ LSU_APBO, LSU_APBO.X, LSU_APBO.Y, LSU_APBI, LSU_APPB, LSU_APPB.O, LSU_APPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      This instruction implements Compare-And-Swap (CAS) on memory double word with double word aligned address.
      The %3 is interpreted as the concatenation of \texttt{update} (low 64 bits) and \texttt{expected} (high 64 bits).
      The memory double word at the effective address is read into \texttt{current}.
      If \texttt{current} equals \texttt{expected}, the swap is successful and \texttt{update}
      is stored into the memory double word at the effective address. Otherwise, the swap has failed and the memory is not updated.
      The instruction status is defined as the true/false value of success in case \texttt{boolcas} is true, or
      the \texttt{current} value in case \texttt{boolcas} is false.
      The concatenation of the status (low 64 bits) and \texttt{expected} (high 64 bits) is returned into the %3.
    execution: |
      new update = _ZX_64(argument3);
      new expected = _ZX_64(argument3 >> 64);
      new success = MEM.atomic_cas(address, 0xFF, boolcas, update, expected, @3 << 1);
      new result3 = (expected << 64) | _ZX_64(success);
    behavior: |
      (SEQ
        (WRITE.update
          (ZX.64 (READ.argument3)))
        (WRITE.expected
          (ZX.64 (SHR (READ.argument3) (CONST.64))))
        (WRITE.success
          (APPLY.64.MEM_atomic_cas
            (READ.address)
            (CONST.0xFF)
            (READ.boolcas)
            (READ.update)
            (READ.expected)
            (SHL (METHOD.%3) (CONST.1))))
        (WRITE.result3
          (IOR
            (SHL (READ.expected) (CONST.64))
            (ZX.64 (READ.success)))))
  - ID: ALCLRW
    what: Atomic Load and Clear Word
    formats: [ LSU_ASBO, LSU_ASBO.X, LSU_ASBO.Y, LSU_ASBI, LSU_ASPB, LSU_ASPB.O, LSU_ASPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      The %1 is loaded from the memory word starting at the effective address.
      The value 0 is stored into the memory word starting at the effective address.
      This atomic instruction implements Test-and-Clear in memory. A zero
      word in memory means that the lock at the effective address is taken. Unlocking is
      achieved by storing a non-zero word at the effective address.
    execution: |
      new result1 = _ZX_32(MEM.atomic_swap(address, 0xF, 0, 0, @1));
    behavior: |
      (WRITE.result1
        (ZX.32
          (APPLY.MEM_atomic_swap
            (READ.address)
            (CONST.0xF)
            (CONST.0)
            (CONST.0)
            (METHOD.%1))))
  - ID: ALCLRD
    what: Atomic Load and Clear Double Word
    formats: [ LSU_ASBO, LSU_ASBO.X, LSU_ASBO.Y, LSU_ASBI, LSU_ASPB, LSU_ASPB.O, LSU_ASPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      The %1 is loaded from the memory double word starting at the effective address.
      The value 0 is stored into the memory double word starting at the effective address.
      This atomic instruction implements Test-and-Clear in memory. A zero
      double word in memory means that the lock at the effective address is taken. Unlocking is
      achieved by storing a non-zero double word at the effective address.
    execution: |
      new result1 = MEM.atomic_swap(address, 0xFF, 0, 0, @1);
    behavior: |
      (WRITE.result1
        (APPLY.MEM_atomic_swap
          (READ.address)
          (CONST.0xFF)
          (CONST.0)
          (CONST.0)
          (METHOD.%1)))
  - ID: ALADDW
    what: Atomic Load and Add Word
    formats: [ LSU_AABO, LSU_AABO.X, LSU_AABO.Y, LSU_AABI, LSU_AAPB, LSU_AAPB.O, LSU_AAPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=4;MemoryAligned }
    description: >
      This instruction implements atomic load-add-store on word.
      The word at effective address is added with the %3, and its previous value is returned into the %3.
      The effective address must be word aligned (multiple of 4).
    execution: |
      new result3 = _ZX_32(MEM.atomic_add(address, 0xF, 0, argument3.32[0], @3));
    behavior: |
      (WRITE.result3
        (ZX.32 (APPLY.32.MEM_atomic_add
          (READ.address)
          (CONST.0xF)
          (CONST.0)
          (READ.32[0].argument3)
          (METHOD.%3))))
  - ID: ALADDD
    what: Atomic Load and Add Double Word
    formats: [ LSU_AABO, LSU_AABO.X, LSU_AABO.Y, LSU_AABI, LSU_AAPB, LSU_AAPB.O, LSU_AAPB.Y ]
    properties: { '%0': MemoryEffect;MemorySize=8;MemoryAligned }
    description: >
      This instruction implements atomic load-add-store on double word.
      The double word at effective address is added with the %3, and its previous value is returned into the %3.
      The effective address must be double word aligned (multiple of 8).
    execution: |
      new result3 = MEM.atomic_add(address, 0xFF, 0, argument3.64[0], @3);
    behavior: |
      (WRITE.result3
        (APPLY.64.MEM_atomic_add
          (READ.address)
          (CONST.0xFF)
          (CONST.0)
          (READ.64[0].argument3)
          (METHOD.%3)))
  - ID: DTOUCHL
    what: Data Cache 1 Touch Line
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI, LSU_FXCB, LSU_FXCB.O, LSU_FXCB.Y ]
    properties: { '%0': MemoryTouch;MemorySize=64 }
    description: >
      The effective address is sent to the data cache, with request to prefetch the corresponding L1 cache line.
      The effect is the same as a LBS instruction, except that no destination register is written.
    execution: |
      stage E3:
      MEM.dtouchl(address);
    behavior: |
      (EFFECT.E3.MEM_dtouchl (READ.address))
  - ID: DINVALL
    what: Data Cache 1 Invalidate Line
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI, LSU_FXCB, LSU_FXCB.O, LSU_FXCB.Y ]
    description: >
      The effective address is sent to the data cache, with request to invalidate the corresponding L1 cache line.
      Has no effects if the line is not cached. Else, the L1 cache line is invalidated even if it is modified.
    execution: |
      stage E3:
      MEM.dinvall(address);
    behavior: |
      (EFFECT.E3.MEM_dinvall (READ.address))
  - ID: DZEROL
    what: Data Cache 1 Zero Line
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FZBO, LSU_FZBO.X, LSU_FZBO.Y, LSU_FZBI, LSU_FZCB, LSU_FZCB.O, LSU_FZCB.Y ]
    description: >
      The effect is the same as explicitly writing zeroes in the range of addresses corresponding to the L1 cache line
      at the effective address. If the data cache is disabled the instruction directly writes zeroes to memory.
    execution: |
      stage E3:
      MEM.dzerol(address, 1);
    behavior: |
      (EFFECT.E3.MEM_dzerol (READ.address) (CONST.1))
  - ID: I1INVALS
    what: Instruction Cache 1 Invalidate Set
    properties: { '%0': MemoryEffect;MemorySize=64 }
    formats: [ LSU_FXBO, LSU_FXBO.X, LSU_FXBO.Y, LSU_FXBI, LSU_FXCB, LSU_FXCB.O, LSU_FXCB.Y ]
    description: >
      The effective address is sent to the instruction cache, with request to invalidate the corresponding L1 cache set.
      (All the cache lines with the same index.)
    execution: |
      stage E3:
      MEM.i1invals(address);
    behavior: |
      (EFFECT.E3.MEM_i1invals (READ.address))
  - ID: D1INVAL
    what: Data Cache 1 Invalidate
    formats: [ LSU_MCC ]
    description: >
      Request to invalidate the data cache. Cache contents is invalidated even if it is modified.
    execution: |
      stage E3:
      MEM.d1inval();
    behavior: |
      (EFFECT.E3.MEM_d1inval)
  - ID: I1INVAL
    what: Instruction Cache 1 Invalidate
    formats: [ LSU_MCC ]
    description: >
      Request to invalidate the instruction cache.
    execution: |
      stage E3:
      MEM.i1inval();
    behavior: |
      (EFFECT.E3.MEM_i1inval)
  - ID: FENCE
    what: Memory Fence
    formats: [ LSU_MCC ]
    properties: { '%0': MemoryFence }
    description: >
      Ensures that all issued memory operations are committed to memory. This instruction is typically used
      to ensure a write to memory is visible to other cores.
    execution: |
      stage E3:
      MEM.fence(0);
    behavior: |
      (EFFECT.E3.MEM_fence (CONST.0))
  - ID: NOP
    what: No Operation
    formats: [ ALU_NOP ]
    description: >
      No effects except extending the current bundle by one syllable.
    execution: |
      ;
    behavior: |
      (SKIP)
  - ID: STSUD
    what: Subtract, Test and Shift Unsigned Double Words
    formats: [ ALU_DWRR ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 is subtracted from the %3 If positive, the result is shifted left one bit and OR-ed with 0x1.
      Else, the %3 is shifted left one bit. The result is stored into the %1.
      This instruction is provided to support double word unsigned integer division.
    execution: |
      new result1 = _ZX_64(argument3) >= _ZX_64(argument2) ?
                    _ZX_64(argument3) - _ZX_64(argument2) << 1 | 1 :
                    _ZX_64(argument3) << 1;
    behavior: |
      (WRITE.result1
        (SELECT
          (GE
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))
          (IOR
            (SHL
              (SUB
                (ZX.64 (READ.argument3))
                (ZX.64 (READ.argument2)))
              (CONST.1))
            (CONST.1))
          (SHL
            (ZX.64 (READ.argument3))
            (CONST.1))))
  - ID: ADDD
    what: Add Double Word to Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The %3 and the %2 are added. The result is stored into the %1.
    execution: |
      new result1 = argument3 + argument2;
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (READ.argument2)))
  - ID: SBFD
    what: Subtract Double Word From Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%2': Right, '%3': Left }
    description: >
      The %2 is subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - argument2;
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (READ.argument2)))
  - ID: ABDD
    what: Absolute Difference of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    schedulings: [ ALU_LITE, ALU_LITE.X, ALU_LITE, ALU_LITE.X, ALU_LITE.Y ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result is stored into the %1.
    execution: |
      new result1 = _ABS(_SX_64(argument3) - _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MIND
    what: Minimum of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The minimum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MIN(_SX_64(argument3), _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MINUD
    what: Minimum of Unsigned Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The unsigned minimum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MIN(_ZX_64(argument3), _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: MAXD
    what: Maximum of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The maximum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MAX(_SX_64(argument3), _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MAXUD
    what: Maximum of Unsigned Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      The unsigned maximum of the %3 and the %2 is computed. The result is stored into the %1.
    execution: |
      new result1 = _MAX(_ZX_64(argument3), _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: ANDD
    what: Bitwise And Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (READ.argument3)))
  - ID: NANDD
    what: Bitwise Not And Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise and of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 & argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (AND
            (READ.argument2)
            (READ.argument3))))
  - ID: IORD
    what: Bitwise Inclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NIORD
    what: Bitwise Not Inclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise inclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 | argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (IOR
            (READ.argument2)
            (READ.argument3))))
  - ID: EORD
    what: Bitwise Exclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = argument2 ^ argument3;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NEORD
    what: Bitwise Not Exclusive Or Between Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise exclusive or of the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~(argument2 ^ argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (XOR
            (READ.argument2)
            (READ.argument3))))
  - ID: ANDND
    what: Bitwise And with Not Operand Between Double Words
    properties: { '%0': Bitwise }
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      Bitwise and of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: IORND
    what: Bitwise Inclusive Or with Not Operand Between Double Words
    properties: { '%0': Bitwise }
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    description: >
      Bitwise inclusive or of not the %2 with the %3. The result is stored into the %1.
    execution: |
      new result1 = ~argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: SBMM8D
    what: Swapped Bit Matrix Multiplication 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    schedulings: [ ALU_LITE, ALU_LITE.X, ALU_LITE, ALU_LITE.X, ALU_LITE.Y ]
    description: >
      The %3 interpreted as a 8$\times$8 bit matrix is multiplied by the %2 interpreted as a 8$\times$8 bit matrix.
      The result is stored into the %1.
    execution: &executionSBMM8 |
      new result1 = _BMM_8(_ZX_64(argument3), _ZX_64(argument2));
    behavior: &behaviorSBMM8 |
      (WRITE.result1
        (APPLY.64._BMM_8
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: SBMMT8D
    what: Swapped Bit Matrix Multiplication Transposed 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    schedulings: [ ALU_LITE, ALU_LITE.X, ALU_LITE, ALU_LITE.X, ALU_LITE.Y ]
    description: >
      The %3 interpreted as a 8$\times$8 bit matrix is multiplied by the %2 interpreted as a 8$\times$8 bit matrix.
      The result is transposed, and stored into the %1.
    execution: &executionSBMMT8 |
      new result1 = _BMT_8(_BMM_8(_ZX_64(argument3), _ZX_64(argument2)));
    behavior: &behaviorSBMMT8 |
      (WRITE.result1
        (APPLY.64._BMT_8
          (APPLY.64._BMM_8
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: ADDSD
    what: Add Saturated Double Words
    formats: [ ALU_WRIS, ALU_WRIS.X, ALU_WRIS.Y, ALU_WRRS ]
    description: >
      The %3 and the %2 are added with 64-bit saturation.
    execution: |
      new result1 = _SAT_64(_SX_64(argument3) + _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SAT.64
          (ADD
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: SBFSD
    what: Subtract Saturated Double Words
    formats: [ ALU_WRIS, ALU_WRIS.X, ALU_WRIS.Y, ALU_WRRS ]
    description: >
      The %2 is subtracted from the %3 with 64-bit saturation.
    execution: |
      new result1 = _SAT_64(_SX_64(argument3) - _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SAT.64
          (SUB
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: ADDX2D
    what: Add Double Word to Double Word Times 2
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: ADDX4D
    what: Add Double Word to Double Word Times 4
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: ADDX8D
    what: Add Double Word to Double Word Times 8
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: ADDX16D
    what: Add Double Word to Double Word Times 16
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: SBFX2D
    what: Subtract Double Word Times 2 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: SBFX4D
    what: Subtract Double Word Times 4 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: SBFX8D
    what: Subtract Double Word Times 8 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: SBFX16D
    what: Subtract Double Word Times 16 from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: ADDWD
    what: Add Word to Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is sign-extended from 32 bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: SBFWD
    what: Subtract Word from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is sign-extended from 32 bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: ADDUWD
    what: Add Unsigned Word to Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is zero-extended from 32 bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + argument2.32[0];
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (READ.32[0].argument2)))
  - ID: SBFUWD
    what: Subtract Unsigned Word from Double Word
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %2 is zero-extended from 32 bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - argument2.32[0];
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (READ.32[0].argument2)))
  - ID: LANDD
    what: Logical And of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are converted to booleans, which are AND-ed. The result is stored into the %1.
    execution: |
      new result1 = (_ZX_64(argument3) != 0) & (_ZX_64(argument2) != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (ANDL
            (I2B
              (ZX.64 (READ.argument3)))
            (I2B
              (ZX.64 (READ.argument2))))))
  - ID: LNANDD
    what: Logical Not And of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are converted to booleans, which are NOT AND-ed. The result is stored into the %1.
    execution: |
      new result1 = !((_ZX_64(argument3) != 0) & (_ZX_64(argument2) != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (ANDL
              (I2B
                (ZX.64 (READ.argument3)))
              (I2B
                (ZX.64 (READ.argument2)))))))
  - ID: LIORD
    what: Logical Or of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are converted to booleans, which are OR-ed. The result is stored into the %1.
    execution: |
      new result1 = (_ZX_64(argument3) != 0) | (_ZX_64(argument2) != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (IORL
            (I2B
              (ZX.64 (READ.argument3)))
            (I2B
              (ZX.64 (READ.argument2))))))
  - ID: LNIORD
    what: Logical Not Or of Double Words
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    description: >
      The %3 and the %2 are converted to booleans, which are not OR-ed. The result is stored into the %1.
    execution: |
      new result1 = !((_ZX_64(argument3) != 0) | (_ZX_64(argument2) != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (IORL
              (I2B
                (ZX.64 (READ.argument3)))
              (I2B
                (ZX.64 (READ.argument2)))))))
  - ID: STSUW
    what: Subtract, Test and Shift Unsigned Word
    formats: [ ALU_WWRR0 ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 is subtracted from the %3. If positive, the result is shifted left one bit and OR-ed with 0x1.
      Else, the %3 is shifted left one bit. The result with the 32 upper bits cleared is stored into the %1.
      This instruction is provided to support unsigned integer division.
    execution: |
      new result1 = argument3.32[0] >= argument2.32[0] ?
                    argument3.32[0] - argument2.32[0] << 1 | 1 :
                    argument3.32[0] << 1;
    behavior: |
      (WRITE.result1
        (SELECT
          (GE
            (READ.32[0].argument3)
            (READ.32[0].argument2))
          (IOR
            (SHL
              (SUB
                (READ.32[0].argument3)
                (READ.32[0].argument2))
              (CONST.1))
            (CONST.1))
          (SHL
            (READ.32[0].argument3)
            (CONST.1))))
  - ID: ADDW
    what: Add Word to Word
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The %3 and the %2 are added. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + argument2;
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (READ.argument2)))
  - ID: SBFW
    what: Subtract Word from Word
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The %2 is subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - argument2;
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (READ.argument2)))
  - ID: ABDW
    what: Absolute Difference of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    schedulings: [ ALU_LITE, ALU_LITE.X, ALU_LITE ]
    description: >
      The %2 is subtracted from the %3. The absolute value of the result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ABS(_SX_32(argument3) - _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (ABS
          (SUB
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MINW
    what: Minimum of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The minimum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MIN(_SX_32(argument3), _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (MIN
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MINUW
    what: Minimum of Unsigned Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The unsigned minimum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MIN(argument3.32[0], argument2.32[0]);
    behavior: |
      (WRITE.result1
        (MIN
          (READ.32[0].argument3)
          (READ.32[0].argument2)))
  - ID: MAXW
    what: Maximum of Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The maximum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MAX(_SX_32(argument3), _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (MAX
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MAXUW
    what: Maximum of Unsigned Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    description: >
      The unsigned maximum of the %3 and the %2 is computed. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _MAX(argument3.32[0], argument2.32[0]);
    behavior: |
      (WRITE.result1
        (MAX
          (READ.32[0].argument3)
          (READ.32[0].argument2)))
  - ID: ANDW
    what: Bitwise And Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (READ.argument3)))
  - ID: NANDW
    what: Bitwise Not And Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise and of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 & argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (AND
            (READ.argument2)
            (READ.argument3))))
  - ID: IORW
    what: Bitwise Inclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NIORW
    what: Bitwise Not Inclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise inclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 | argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (IOR
            (READ.argument2)
            (READ.argument3))))
  - ID: EORW
    what: Bitwise Exclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise exclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2 ^ argument3;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (READ.argument3)))
  - ID: NEORW
    what: Bitwise Not Exclusive Or Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise not of bitwise exclusive or of the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~(argument2 ^ argument3);
    behavior: |
      (WRITE.result1
        (NOT
          (XOR
            (READ.argument2)
            (READ.argument3))))
  - ID: ANDNW
    what: Bitwise And with Not Operand Between Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise and of not the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~argument2 & argument3;
    behavior: |
      (WRITE.result1
        (AND
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: IORNW
    what: Bitwise Inclusive Or with Not Operand Between Double Words
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    properties: { '%0': Bitwise }
    description: >
      Bitwise inclusive or of not the %2 with the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = ~argument2 | argument3;
    behavior: |
      (WRITE.result1
        (IOR
          (NOT (READ.argument2))
          (READ.argument3)))
  - ID: ADDSW
    what: Add Saturated Words
    formats: [ ALU_AWRRW, ALU_AWRRW.W ]
    description: >
      The %3 and the %2 are added with 32-bit saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SAT_32(_SX_32(argument3) + _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (SAT.32
          (ADD
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: SBFSW
    what: Subtract Saturated Words
    formats: [ ALU_AWRRW, ALU_AWRRW.W ]
    description: >
      The %2 is subtracted from the %3 with 32-bit saturation. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SAT_32(_SX_32(argument3) - _SX_32(argument2));
    behavior: |
      (WRITE.result1
        (SAT.32
          (SUB
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: ADDX2W
    what: Add Word to Word Times 2
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by one bit and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: ADDX4W
    what: Add Word to Word Times 4
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by two bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: ADDX8W
    what: Add Word to Word Times 8
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by three bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: ADDX16W
    what: Add Word to Word Times 16
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by four bits and added to the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 + (argument2 << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: SBFX2W
    what: Subtract Word Times 2 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by one bit and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.1))))
  - ID: SBFX4W
    what: Subtract Word Times 4 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by two bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.2))))
  - ID: SBFX8W
    what: Subtract Word Times 8 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by three bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.3))))
  - ID: SBFX16W
    what: Subtract Word Times 16 from Word
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %2 is shifted left by four bits and subtracted from the %3. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument3 - (argument2 << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument3)
          (SHL
            (READ.argument2)
            (CONST.4))))
  - ID: AVGW
    what: Average of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added. The result is shifted right arithmetic one bit and stored into the %1.
    execution: |
      new result1 = (_SX_32(argument3) + _SX_32(argument2)) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))
          (CONST.1)))
  - ID: AVGUW
    what: Average of Unsigned Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added. The result is shifted right logical one bit and stored into the %1.
    execution: |
      new result1 = (argument3.32[0] + argument2.32[0]) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (READ.32[0].argument3)
            (READ.32[0].argument2))
          (CONST.1)))
  - ID: AVGRW
    what: Average Rounded of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added. The result is incremented, shifted right arithmetic one bit and stored into the %1.
    execution: |
      new result1 = (_SX_32(argument2) + _SX_32(argument3) + 1) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (ADD
              (SX.32 (READ.argument3))
              (SX.32 (READ.argument2)))
            (CONST.1))
          (CONST.1)))
  - ID: AVGRUW
    what: Average Rounded of Unsigned Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are added. The result is incremented, shifted right logical one bit and stored into the %1.
    execution: |
      new result1 = (argument2.32[0] + argument3.32[0] + 1) >> 1;
    behavior: |
      (WRITE.result1
        (SHR
          (ADD
            (ADD
              (READ.32[0].argument3)
              (READ.32[0].argument2))
             (CONST.1))
          (CONST.1)))
  - ID: LANDW
    what: Logical And of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are AND-ed. The result is stored into the %1.
    execution: |
      new result1 = (argument3.32[0] != 0) & (argument2.32[0] != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (ANDL
            (I2B
              (READ.32[0].argument3))
            (I2B
              (READ.32[0].argument2)))))
  - ID: LNANDW
    what: Logical Not And of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are NOT AND-ed. The result is stored into the %1.
    execution: |
      new result1 = !((argument3.32[0] != 0) & (argument2.32[0] != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (ANDL
              (I2B
                (READ.32[0].argument3))
              (I2B
                (READ.32[0].argument2))))))
  - ID: LIORW
    what: Logical Or of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are OR-ed. The result is stored into the %1.
    execution: |
      new result1 = (argument3.32[0] != 0) | (argument2.32[0] != 0);
    behavior: |
      (WRITE.result1
        (B2I
          (IORL
            (I2B
              (READ.32[0].argument3))
            (I2B
              (READ.32[0].argument2)))))
  - ID: LNIORW
    what: Logical Not Or of Words
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    description: >
      The %3 and the %2 are converted to booleans, which are not OR-ed. The result is stored into the %1.
    execution: |
      new result1 = !((argument3.32[0] != 0) | (argument2.32[0] != 0));
    behavior: |
      (WRITE.result1
        (B2I
          (NOTL
            (IORL
              (I2B
                (READ.32[0].argument3))
              (I2B
                (READ.32[0].argument2))))))
  - ID: ADDWP
    what: Add Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument3.32[i] + argument2.32[i];
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument3)
            (READ.32[(INDEX.I)].argument2))))
  - ID: SBFWP
    what: Subtract Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument3.32[i] - argument2.32[i];
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument3)
            (READ.32[(INDEX.I)].argument2))))
  - ID: ABDWP
    what: Absolute Difference Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are subtracted from the %3 words. The absolute value of the
      two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ABS(_SX_32(argument3.32[i]) - _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ABS
            (SUB
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MINWP
    what: Minimum of Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The minimum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MIN(_SX_32(argument3.32[i]), _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MIN
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MINUWP
    what: Minimum of Unsigned Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The unsigned minimum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MIN(_ZX_32(argument3.32[i]), _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MIN
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MAXWP
    what: Maximum of Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The maximum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MAX(_SX_32(argument3.32[i]), _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MAX
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MAXUWP
    what: Maximum of Unsigned Words Packed
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The unsigned maximum of the %3 words and the %2 words are computed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _MAX(_ZX_32(argument3.32[i]), _ZX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MAX
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: ADDWC.C
    what: Add Conjugate Word Complex
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %3 and the %2 are considered as two word complex packed into 64 bits.
      The %3 word complex is added to the %2 word complex conjugate.
      The resulting word complex is packed into 64 bits and stored into the %1.
    execution: |
      result1.32[0] = _SX_32(argument3.32[0]) + _SX_32(argument2.32[0]);
      result1.32[1] = _SX_32(argument3.32[1]) - _SX_32(argument2.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (ADD
            (SX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2))))
        (WRITE.32[1].result1
          (SUB
            (SX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: SBFWC.C
    what: Subtract Conjugate Word Complex
    formats: [ ALU_WPWRR0, ALU_WPWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %3 and the %2 are considered as two word complex packed into 64 bits.
      The %2 word complex conjugate is subtracted from the %3 word complex.
      The resulting word complex is packed into 64 bits and stored into the %1.
    execution: |
      result1.32[0] = _SX_32(argument3.32[0]) - _SX_32(argument2.32[0]);
      result1.32[1] = _SX_32(argument3.32[1]) + _SX_32(argument2.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (SUB
            (SX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2))))
        (WRITE.32[1].result1
          (ADD
            (SX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: ADDSWP
    what: Add Saturated Words Packed
    formats: [ ALU_AWRRWP, ALU_AWRRWP.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added with saturation to 32 bits.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument3.32[i]) + _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SAT.32
            (ADD
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: SBFSWP
    what: Subtract Saturated Words Packed
    formats: [ ALU_AWRRWP, ALU_AWRRWP.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are subtracted with saturation to 32 bits from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument3.32[i]) - _SX_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SAT.32
            (SUB
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: ADDX2WP
    what: Add Integer to Integer Times 2 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by one bit and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: ADDX4WP
    what: Add Integer to Integer Times 4 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by two bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: ADDX8WP
    what: Add Integer to Integer Times 8 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by three bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: ADDX16WP
    what: Add Integer to Integer Times 16 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by four bits and added to the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) + (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: SBFX2WP
    what: Subtract Integer to Integer Times 2 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by one bit and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: SBFX4WP
    what: Subtract Integer to Integer Times 4 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by two bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: SBFX8WP
    what: Subtract Integer to Integer Times 8 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by three bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: SBFX16WP
    what: Subtract Integer to Integer Times 16 Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %2 words are shifted left by four bits and subtracted from the %3 words.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) - (_SX_32(argument2.32[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SHL
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: AVGWP
    what: Average of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is shifted right arithmetic one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_SX_32(argument3.32[i]) + _SX_32(argument2.32[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGUWP
    what: Average Unsigned of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is shifted right logical one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_ZX_32(argument3.32[i]) + _ZX_32(argument2.32[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGRWP
    what: Average Rounded of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is incremented and shifted right arithmetic one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_SX_32(argument3.32[i]) + _SX_32(argument2.32[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (SX.32 (READ.32[(INDEX.I)].argument3))
                (SX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: AVGRUWP
    what: Average Rounded Unsigned of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are added. Each sum is incremented and shifted right logical one bit.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (_ZX_32(argument3.32[i]) + _ZX_32(argument2.32[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (ZX.32 (READ.32[(INDEX.I)].argument3))
                (ZX.32 (READ.32[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: LANDWP
    what: Logical And of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are converted to booleans, which are AND-ed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (argument3.32[i] != 0) & (argument2.32[i] != 0);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (B2I
            (ANDL
              (I2B
                (READ.32[(INDEX.I)].argument3))
              (I2B
                (READ.32[(INDEX.I)].argument2))))))
  - ID: LNANDWP
    what: Logical Not And of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are converted to booleans, which are NOT AND-ed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = !((argument3.32[i] != 0) & (argument2.32[i] != 0));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (B2I
            (NOTL
              (ANDL
                (I2B
                  (READ.32[(INDEX.I)].argument3))
                (I2B
                  (READ.32[(INDEX.I)].argument2)))))))
  - ID: LIORWP
    what: Logical Or of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are converted to booleans, which are OR-ed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = (argument3.32[i] != 0) | (argument2.32[i] != 0);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (B2I
            (IORL
              (I2B
                (READ.32[(INDEX.I)].argument3))
              (I2B
                (READ.32[(INDEX.I)].argument2))))))
  - ID: LNIORWP
    what: Logical Not Or of Words Packed
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are converted to booleans, which are not OR-ed.
      The two resulting words are packed and stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = !((argument3.32[i] != 0) | (argument2.32[i] != 0));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (B2I
            (NOTL
              (IORL
                (I2B
                  (READ.32[(INDEX.I)].argument3))
                (I2B
                  (READ.32[(INDEX.I)].argument2)))))))
  - ID: ADDHQ
    what: Add Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument3.16[i] + argument2.16[i];
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (READ.16[(INDEX.I)].argument3)
            (READ.16[(INDEX.I)].argument2))))
  - ID: SBFHQ
    what: Subtract Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument3.16[i] - argument2.16[i];
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (READ.16[(INDEX.I)].argument3)
            (READ.16[(INDEX.I)].argument2))))
  - ID: ABDHQ
    what: Absolute Difference Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted from the %3 half words. The absolute value of
      the four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _ABS(_SX_16(argument3.16[i]) - _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ABS
            (SUB
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MINHQ
    what: Minimum of Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The minimum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MIN(_SX_16(argument3.16[i]), _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MIN
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MINUHQ
    what: Minimum of Unsigned Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The unsigned minimum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MIN(_ZX_16(argument3.16[i]), _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MIN
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MAXHQ
    what: Maximum of Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The maximum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MAX(_SX_16(argument3.16[i]), _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MAX
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MAXUHQ
    what: Maximum of Unsigned Half Words Quadruple
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The unsigned maximum of the %3 half words and the %2 half words are computed.
      The four resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _MAX(_ZX_16(argument3.16[i]), _ZX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MAX
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: ADDHCP.C
    what: Add Conjugate Half Word Complex Pair
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %3 and the %2 are considered as two pairs of half-word complex packed into 64 bits.
      Each %3 half word complex is added to the corresponding %2 half word complex conjugate.
      The resulting pair of half word word complex is stored into the %1.
    execution: |
      result1.16[0] = _SX_16(argument3.16[0]) + _SX_16(argument2.16[0]);
      result1.16[1] = _SX_16(argument3.16[1]) - _SX_16(argument2.16[1]);
      result1.16[2] = _SX_16(argument3.16[2]) + _SX_16(argument2.16[2]);
      result1.16[3] = _SX_16(argument3.16[3]) - _SX_16(argument2.16[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (ADD
            (SX.16 (READ.16[0].argument3))
            (SX.16 (READ.16[0].argument2))))
        (WRITE.16[1].result1
          (SUB
            (SX.16 (READ.16[1].argument3))
            (SX.16 (READ.16[1].argument2))))
        (WRITE.16[2].result1
          (ADD
            (SX.16 (READ.16[2].argument3))
            (SX.16 (READ.16[2].argument2))))
        (WRITE.16[3].result1
          (SUB
            (SX.16 (READ.16[3].argument3))
            (SX.16 (READ.16[3].argument2)))))
  - ID: SBFHCP.C
    what: Subtract Conjugate Half Word Complex Pair
    formats: [ ALU_HQWRR0, ALU_HQWRR0.M ]
    schedulings: [ ALU_LITE, ALU_LITE.X ]
    description: >
      The %3 and the %2 are considered as two pairs of half word complex packed into 64 bits.
      Each %2 half word complex conjugate is subtracted from the corresponding %3 half word complex.
      The resulting pair of half word complex is stored into the %1.
    execution: |
      result1.16[0] = _SX_16(argument3.16[0]) - _SX_16(argument2.16[0]);
      result1.16[1] = _SX_16(argument3.16[1]) + _SX_16(argument2.16[1]);
      result1.16[2] = _SX_16(argument3.16[2]) - _SX_16(argument2.16[2]);
      result1.16[3] = _SX_16(argument3.16[3]) + _SX_16(argument2.16[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (SUB
            (SX.16 (READ.16[0].argument3))
            (SX.16 (READ.16[0].argument2))))
        (WRITE.16[1].result1
          (ADD
            (SX.16 (READ.16[1].argument3))
            (SX.16 (READ.16[1].argument2))))
        (WRITE.16[2].result1
          (SUB
            (SX.16 (READ.16[2].argument3))
            (SX.16 (READ.16[2].argument2))))
        (WRITE.16[3].result1
          (ADD
            (SX.16 (READ.16[3].argument3))
            (SX.16 (READ.16[3].argument2)))))
  - ID: ADDSHQ
    what: Add Saturated Half Words Quadruple
    formats: [ ALU_AWRRHQ, ALU_AWRRHQ.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added with saturation to 16 bits.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument3.16[i]) + _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SAT.16
            (ADD
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: SBFSHQ
    what: Subtract Saturated Half Words Quadruple
    formats: [ ALU_AWRRHQ, ALU_AWRRHQ.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are subtracted with saturation to 16 bits from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument3.16[i]) - _SX_16(argument2.16[i]));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SAT.16
            (SUB
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: ADDX2HQ
    what: Add Integer to Integer Times 2 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by one bit and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: ADDX4HQ
    what: Add Integer to Integer Times 4 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by two bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: ADDX8HQ
    what: Add Integer to Integer Times 8 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by three bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: ADDX16HQ
    what: Add Integer to Integer Times 16 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by four bits and added to the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) + (_SX_16(argument2.16[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: SBFX2HQ
    what: Subtract Integer to Integer Times 2 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by one bit and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 1);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.1)))))
  - ID: SBFX4HQ
    what: Subtract Integer to Integer Times 4 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by two bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 2);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.2)))))
  - ID: SBFX8HQ
    what: Subtract Integer to Integer Times 8 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by three bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 3);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.3)))))
  - ID: SBFX16HQ
    what: Subtract Integer to Integer Times 16 Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %2 half words are shifted left by four bits and subtracted from the %3 half words.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) - (_SX_16(argument2.16[i]) << 4);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SHL
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (CONST.4)))))
  - ID: AVGHQ
    what: Average of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is shifted right arithmetic one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_SX_16(argument3.16[i]) + _SX_16(argument2.16[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGUHQ
    what: Average Unsigned of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is shifted right logical one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_ZX_16(argument3.16[i]) + _ZX_16(argument2.16[i])) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2)))
            (CONST.1))))
  - ID: AVGRHQ
    what: Average Rounded of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is incremented and shifted right arithmetic one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_SX_16(argument3.16[i]) + _SX_16(argument2.16[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (SX.16 (READ.16[(INDEX.I)].argument3))
                (SX.16 (READ.16[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: AVGRUHQ
    what: Average Rounded Unsigned of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are added. Each sum is incremented and shifted right logical one bit.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (_ZX_16(argument3.16[i]) + _ZX_16(argument2.16[i]) + 1) >> 1;
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SHR
            (ADD
              (ADD
                (ZX.16 (READ.16[(INDEX.I)].argument3))
                (ZX.16 (READ.16[(INDEX.I)].argument2)))
              (CONST.1))
            (CONST.1))))
  - ID: LANDHQ
    what: Logical And of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are converted to booleans, which are AND-ed.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (argument3.16[i] != 0) & (argument2.16[i] != 0);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (B2I
            (ANDL
              (I2B
                (READ.16[(INDEX.I)].argument3))
              (I2B
                (READ.16[(INDEX.I)].argument2))))))
  - ID: LNANDHQ
    what: Logical Not And of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are converted to booleans, which are NOT AND-ed.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = !((argument3.16[i] != 0) & (argument2.16[i] != 0));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (B2I
            (NOTL
              (ANDL
                (I2B
                  (READ.16[(INDEX.I)].argument3))
                (I2B
                  (READ.16[(INDEX.I)].argument2)))))))
  - ID: LIORHQ
    what: Logical Or of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are converted to booleans, which are OR-ed.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = (argument3.16[i] != 0) | (argument2.16[i] != 0);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (B2I
            (IORL
              (I2B
                (READ.16[(INDEX.I)].argument3))
              (I2B
                (READ.16[(INDEX.I)].argument2))))))
  - ID: LNIORHQ
    what: Logical Not Or of Half Words Quadruple
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are converted to booleans, which are not OR-ed.
      The resulting half words are packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = !((argument3.16[i] != 0) | (argument2.16[i] != 0));
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (B2I
            (NOTL
              (IORL
                (I2B
                  (READ.16[(INDEX.I)].argument3))
                (I2B
                  (READ.16[(INDEX.I)].argument2)))))))
  - ID: ADDX2WD
    what: Add Word Times 2 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.1))))
  - ID: ADDX4WD
    what: Add Word Times 4 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.2))))
  - ID: ADDX8WD
    what: Add Word Times 8 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.3))))
  - ID: ADDX16WD
    what: Add Word Times 16 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (_SX_32(argument2) << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.4))))
  - ID: SBFX2WD
    what: Subtract Word Times 2 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.1))))
  - ID: SBFX4WD
    what: Subtract Word Times 4 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.2))))
  - ID: SBFX8WD
    what: Subtract Word Times 8 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.3))))
  - ID: SBFX16WD
    what: Subtract Word Times 16 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is sign-extended from 32 bits, shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (_SX_32(argument2) << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (SX.32 (READ.argument2))
            (CONST.4))))
  - ID: ADDX2UWD
    what: Add Unsigned Word Times 2 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by one bit and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 1);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.1))))
  - ID: ADDX4UWD
    what: Add Unsigned Word Times 4 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by two bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 2);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.2))))
  - ID: ADDX8UWD
    what: Add Unsigned Word Times 8 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by three bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 3);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.3))))
  - ID: ADDX16UWD
    what: Add Unsigned Word Times 16 to Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by four bits and added to the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) + (argument2.32[0] << 4);
    behavior: |
      (WRITE.result1
        (ADD
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.4))))
  - ID: SBFX2UWD
    what: Subtract Unsigned Word Times 2 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by one bit and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 1);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.1))))
  - ID: SBFX4UWD
    what: Subtract Unsigned Word Times 4 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by two bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 2);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.2))))
  - ID: SBFX8UWD
    what: Subtract Unsigned Word Times 8 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by three bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 3);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.3))))
  - ID: SBFX16UWD
    what: Subtract Unsigned Word Times 16 from Double Word
    formats: [ ALU_WDWRR2, ALU_WDWRR2.W ]
    description: >
      The %2 is zero-extended from 32 bits, shifted left by four bits and subtracted from the %3. The result is stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) - (argument2.32[0] << 4);
    behavior: |
      (WRITE.result1
        (SUB
          (SX.64 (READ.argument3))
          (SHL
            (READ.32[0].argument2)
            (CONST.4))))
  - ID: ADDCD
    what: Add Double Word to Double Word with Carry
    formats: [ ALU_DCWRRC, ALU_DCWRRC.W ]
    description: >
      The %2 is added to the %3 and the \textbf{IC} bit of the \textbf{CS} register. The result is stored into the %1
      and the \textbf{IC} bit is updated.
    execution: |
      stage RR:
      new counter = CS.CC;
      new result1 = _ZX_64(argument2) + _ZX_64(argument3) + CS.IC;
      stage E1:
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64 (READ.argument2))
              (ZX.64 (READ.argument3)))
            (F2I.1 (LOAD.RR (AGGL.CS (CONST.CS_IC) (CONST.1))))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.RR (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: SBFCD
    what: Subtract Double Word from Double Word with Carry
    formats: [ ALU_DCWRRC, ALU_DCWRRC.W ]
    description: >
      The complement of the %2 is added to the %3 and the \textbf{IC} bit of the \textbf{CS} register.
      The result is stored into the %1 and the \textbf{IC} bit is updated.
    execution: |
      stage RR:
      new result1 = _ZX_64(~argument2) + _ZX_64(argument3) + CS.IC;
      new carry = (result1 >> 64) & 1;
      stage E1:
      CS.IC = carry;
      stage E2:
      new counter = CS.CC;
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64
                (NOT (READ.argument2)))
              (ZX.64 (READ.argument3)))
            (F2I.1 (LOAD.RR (AGGL.CS (CONST.CS_IC) (CONST.1))))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.E2 (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: ADDCD.I
    what: Add Double Word to Double Word with Carry Initial
    formats: [ ALU_DCWRRCI, ALU_DCWRRCI.W ]
    description: >
      The %2 is added to the %3. The result is stored into the %1 and the \textbf{IC} bit
      of the \textbf{CS} register is updated.
    execution: |
      stage RR:
      new counter = CS.CC;
      stage E1:
      new result1 = _ZX_64(argument2) + _ZX_64(argument3);
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ZX.64 (READ.argument2))
            (ZX.64 (READ.argument3))))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.RR (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: SBFCD.I
    what: Subtract Double Word from Double Word with Carry Initial
    formats: [ ALU_DCWRRCI, ALU_DCWRRCI.W ]
    description: >
      The complement of the %2 plus one is added to the %3.
      The result is stored into the %1 and the \textbf{IC} bit of the \textbf{CS} register is updated.
    execution: |
      stage E1:
      new result1 = _ZX_64(~argument2) + _ZX_64(argument3) + 1;
      new carry = (result1 >> 64) & 1;
      CS.IC = carry;
      stage E2:
      new counter = CS.CC;
      CS.CC = counter + carry;
    behavior: |
      (SEQ
        (WRITE.result1
          (ADD
            (ADD
              (ZX.64
                (NOT (READ.argument2)))
              (ZX.64 (READ.argument3)))
            (CONST.1)))
        (WRITE.carry
          (AND
            (SHR
              (READ.result1)
              (CONST.64))
           (CONST.1)))
        (STORE.E1 (AGGL.CS (CONST.CS_IC) (CONST.1))
          (I2F.1
            (READ.carry)))
        (WRITE.counter
          (F2I.16 (LOAD.E2 (AGGL.CS (CONST.CS_CC) (CONST.16)))))
        (STORE.E2 (AGGL.CS (CONST.CS_CC) (CONST.16))
          (I2F.16
            (ADD
              (READ.counter)
              (READ.carry)))))
  - ID: FNEGD
    what: Floating-Point Negate Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The negated value the %2, assuming binary 64 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000000000000000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000000000000000)))
  - ID: FABSD
    what: Floating-Point Absolute Value Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The absolute value the %2, assuming binary 64 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFFFFFFFFFFFFFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFFFFFFFFFFFFFF)))
  - ID: FSRECD
    what: Floating-Point Seed for Reciprocal Double Word
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming binary 64
      floating-point numbers, is stored into the %1. This instruction
      may raise division by zero, inexact, invalid or overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_fast_rec(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_fast_rec
          (READ.argument2)
        )
      )
  - ID: FSRSRD
    what: Floating-Point Seed for Reciprocal Square Root Double Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      binary 64 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f64_fast_rsqrt(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_fast_rsqrt
          (READ.argument2)
        )
      )
  - ID: FWIDENLWD
    what: Floating Point Widen Least Significant Word to Double
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 interpreted as a binary 32 floating-point number in the least significant word is
      converted to a binary 64 floating-point number and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f32_to_f64(argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f64
          (READ.32[0].argument2)
        )
      )
  - ID: FWIDENMWD
    what: Floating Point Widen Most Significant Word to Double
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The %2 interpreted as a binary 32 floating-point number in the most significant word is
      converted to a binary 64 floating-point number and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f32_to_f64(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f64
          (READ.32[1].argument2)
        )
      )
  - ID: FNARROWDW
    what: Floating Point Narrow Double Word to Word
    class: FPU
    formats: [ ALU_FWRW ]
    schedulings: [ ALU_FULL ]
    description: >
      The %2 interpreted as a binary 64 floating-point number is
      converted to a binary 32 floating-point number according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_to_f32(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_to_f32
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FNEGW
    what: Floating-Point Negate Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The negated value the %2, assuming binary 32 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = _ZX_32(argument2 ^ 0x80000000);
    behavior: |
      (WRITE.result1
        (ZX.32
          (XOR
            (READ.argument2)
            (CONST.0x80000000)
          )
        )
      )
  - ID: FABSW
    what: Floating-Point Absolute Value Word
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The absolute value the %2, assuming binary 32 floating-point number, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = _ZX_32(argument2 & 0x7FFFFFFF);
    behavior: |
      (WRITE.result1
        (ZX.32
          (AND
            (READ.argument2)
            (CONST.0x7FFFFFFF)
          )
        )
      )
  - ID: FRECW
    what: Floating-Point Reciprocal of Word
    class: FPU
    formats: [ ALU_FWRWLL ]
    description: >
      The reciprocal of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_div(RM, 0x3F800000, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_div
          (READ.RM)
          (CONST.0x3F800000)
          (READ.argument2)
        )
      )
  - ID: FRSRW
    what: Floating-Point Reciprocal of Square Root Word
    class: FPU
    formats: [ ALU_FWRWLL ]
    description: >
      The reciprocal of square root of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_rsqrt(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_rsqrt
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FSRECW
    what: Floating-Point Seed for Reciprocal Word
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new result1 = f32_fast_rec(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rec
          (READ.argument2)
        )
      )
  - ID: FSRSRW
    what: Floating-Point Seed for Reciprocal Square Root
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      binary 32 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f32_fast_rsqrt(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rsqrt
          (READ.argument2)
        )
      )
  - ID: FWIDENLHW
    what: Floating Point Widen Least Significant Half Word to Word
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The least significant half of the %2 interpreted as a binary 16 floating-point number is
      converted to a binary 32 floating-point number and stored into the least significant word of the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32(argument2.16[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32
          (READ.16[0].argument2)
        )
      )
  - ID: FWIDENMHW
    what: Floating Point Widen Most Significant Half Word to Word
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The most significant half of the %2 interpreted as a binary 16 floating-point number is
      converted to a binary 32 floating-point number and stored into the least significant word of the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32(_ZX_16(argument2 >> 16));
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32
          (ZX.16
            (SHR
              (READ.argument2)
              (CONST.16)
            )
          )
        )
      )
  - ID: FNARROWWH
    what: Floating Point Narrow Word to Half Word
    class: FPU
    formats: [ ALU_FWRW ]
    description: >
      The %2 interpreted as a binary 32 floating-point number is
      converted to a binary 16 floating-point number according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_to_f16(RM, argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f16
          (READ.RM)
          (READ.32[0].argument2)
        )
      )
  - ID: FNEGWP
    what: Floating-Point Negate Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The negated values of the %2, assuming a pair of binary 32 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000000080000000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000000080000000)))
  - ID: FABSWP
    what: Floating-Point Absolute Value Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The absolute values of the %2, assuming a pair of binary 32 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFFFFFF7FFFFFFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFFFFFF7FFFFFFF)))
  - ID: FSRECWP
    what: Floating-Point Seed for Reciprocal on Word Pair
    class: FPU
    formats: [ ALU_HQFWR ]
    description: >
      An approximation of the reciprocal of the %2, assuming a pair of binary 32
      floating-point numbers, is stored into the %1. This instruction
      may raise division by zero, inexact, invalid or overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_fast_rec_x2(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rec_x2
          (READ.argument2)
        )
      )
  - ID: FSRSRWP
    what: Floating-Point Seed for Reciprocal Square Root on Word Pair
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      An approximation of the reciprocal of square root of the %2, assuming
      a pair of binary 32 floating-point numbers, is stored into the %1.
    execution: |
      new result1 = f32_fast_rsqrt_x2(argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_fast_rsqrt_x2
          (READ.argument2)
        )
      )
  - ID: FWIDENLHWP
    what: Floating Point Widen Least Significant Half Words to Word Pair
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The least significant word of the %2 interpreted as a half word pair. Each
      half word is interpreted as a binary 16 floating-point number and
      converted to a binary 32 floating-point number. These words are paired and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32_x2(argument2.32[0]);
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32_x2
          (READ.32[0].argument2)
        )
      )
  - ID: FWIDENMHWP
    what: Floating Point Widen Most Significant Half Words to Word Pair
    class: FPU
    formats: [ ALU_FWR ]
    schedulings: [ ALU_LITE ]
    description: >
      The most significant word of the %2 interpreted as a half word pair. Each
      half word is interpreted as a binary 16 floating-point number and
      converted to a binary 32 floating-point number. These words are paired and stored into the %1.
      This instruction may raise invalid exception bit in the CS register.
    execution: |
      new result1 = f16_to_f32_x2(_ZX_32(argument2 >> 32));
    behavior: |
      (WRITE.result1
        (APPLY.f16_to_f32_x2
          (ZX.32
            (SHR (READ.argument2) (CONST.32))
          )
        )
      )
  - ID: FNARROWDWP
    what: Floating Point Narrow Double to Word Pair
    class: FPU
    formats: [ ALU_WPFWR ]
    schedulings: [ ALU_FULL ]
    description: >
      The %2 is interpreted as a pair of binary 64 floating-point numbers,
      which are converted to binary 32 floating-point numbers according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_to_f32_x2(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_to_f32_x2
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: FNEGHQ
    what: Floating-Point Negate Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The negated values of the %2, assuming a quadruple of binary 16 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 ^ 0x8000800080008000;
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument2)
          (CONST.0x8000800080008000)))
  - ID: FABSHQ
    what: Floating-Point Absolute Value Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWR ]
    description: >
      The absolute values of the %2, assuming a quadruple of binary 16 floating-point numbers, is stored into the %1.
      Implemented as a bitwise operation, does not raise FP exceptions.
    execution: |
      new result1 = argument2 & 0x7FFF7FFF7FFF7FFF;
    behavior: |
      (WRITE.result1
        (AND
          (READ.argument2)
          (CONST.0x7FFF7FFF7FFF7FFF)))
  - ID: FNARROWWHQ
    what: Floating Point Narrow Word to Half Word Quadruple
    class: FPU
    formats: [ ALU_WPFWR ]
    description: >
      The %2 is interpreted as a quadruple of binary 32 floating-point numbers,
      which are converted to binary 16 floating-point numbers according to the
      rounding mode set in the CS register and stored into the %1. This
      instruction may raise inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_to_f16_x4(RM, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_to_f16_x4
          (READ.RM)
          (READ.argument2)
        )
      )
  - ID: INSF
    what: Insert Bit Field into Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      A bit-mask is computed with ones set between the start bit position and the stop bit position inclusive.
      The %2 is shifted left by the start bit position and inserted into the %1 according to the bit-mask.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: |
      stage RR:
      new argument1 = %1;
      new result1 = ((argument2 << startbit) & mask) | (argument1 & ~mask);
    behavior: |
      (SEQ
        (WRITE.argument1 (ACCESS.RR.%1))
        (WRITE.result1
          (IOR
            (AND
              (SHL
                (READ.argument2)
                (READ.startbit))
              (READ.mask))
            (AND
              (READ.argument1)
              (NOT (READ.mask))))))
  - ID: EXTFZ
    what: Extract Bit Field and Zero Extend to Double Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      The bit-field of the %2 extending from the start bit position to the stop bit position is extracted,
      zero-extended after the stop bit position, shifted right by the start bit position and stored into the %1.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: &executionEXTFZ |
      new masked = argument2 & mask;
      new result1 = masked >> startbit;
    behavior: &behaviorEXTFZ |
      (SEQ
        (WRITE.masked
          (AND
            (READ.argument2)
            (READ.mask)))
        (WRITE.result1
          (SHR
            (READ.masked)
            (READ.startbit))))
  - ID: EXTFS
    what: Extract Bit Field and Sign Extend to Double Word
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      The bit-field of the %2 extending from the start bit position to the stop bit position is extracted,
      sign-extended from the stop bit position, shifted right by the start bit position and stored into the %1.
      Behavior is undefined if the start bit position is greater than the stop bit position.
    execution: &executionEXTFS |
      new masked1 = _ZX_64(argument2 & mask);
      new masked2 = _SX_64(argument2 | ~mask);
      new negative = argument2 & (mask & ~(mask >> 1));
      new masked = negative == 0 ? masked1 : masked2;
      new result1 = masked >> startbit;
    behavior: &behaviorEXTFS |
      (SEQ
        (WRITE.masked1
          (ZX.64
            (AND
              (READ.argument2)
              (READ.mask))))
        (WRITE.masked2
          (SX.64
            (IOR
              (READ.argument2)
              (NOT (READ.mask)))))
        (WRITE.negative
          (AND
            (READ.argument2)
            (AND
              (READ.mask)
              (NOT
                (SHR
                  (READ.mask)
                  (CONST.1))))))
        (WRITE.masked
          (SELECT
            (EQ
              (READ.negative)
              (CONST.0))
            (READ.masked1)
            (READ.masked2)))
        (WRITE.result1
          (SHR
            (READ.masked)
            (READ.startbit))))
  - ID: CLRF
    what: Clear Field
    formats: [ ALU_WRB ]
    description: >
      The start bit position and the stop bit position are extracted from the %4 and the %3 respectively.
      A bit mask is constructed with ones ranging from the start bit position to the stop bit position inclusive.
      If the start bit position is greater than the stop bit position, ones range from the start bit position
      to bit 63, then from bit 0 to stop bit position. The bitwise and of the %2 and the bit mask complement is stored into the %1.
    execution: |
      new result1 = ~mask & argument2;
    behavior: |
      (WRITE.result1
        (AND
          (NOT
            (READ.mask))
          (READ.argument2)))
  - ID: SATD
    what: Saturate Double Word
    formats: [ ALU_DSWRR, ALU_DSWRI ]
    description: >
      The %2 interpreted as signed integer is saturated so the result fits in the %3 number of bits.
      The result is stored into the %1.
    execution: |
      new shift = 64 - argument3.8[0];
      new result1 = shift > 0 ? _SAT_64(_SX_64(argument2) << shift) >> shift : _SX_64(argument2);
    behavior: |
      (SEQ
        (WRITE.shift
          (SUB
            (CONST.64)
            (READ.8[0].argument3)))
        (WRITE.result1
          (SELECT
            (GT (READ.shift) (CONST.0))
            (SHR
              (SAT.64
                (SHL
                  (SX.64 (READ.argument2))
                  (READ.shift)))
              (READ.shift))
            (SX.64 (READ.argument2)))))
  - ID: SRSD
    what: Shift Right Symmetric Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    description: >
      If non-negative, the %2 is shifted right by the %3 modulo 64.
      Else, the %2 biased by (2**(%3 modulo 64)) - 1 and shifted right by the %3 modulo 64.
      The result is stored into the %1.
      This instruction implements a signed division of the %2 double word by a power of two.
    execution: |
      new shift = _ZX_6(argument3);
      new bias = _SX_64(argument2) < 0 ? (1 << shift) - 1 : 0;
      new result1 = (_SX_64(argument2) + bias) >> shift;
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.6 (READ.argument3)))
        (WRITE.bias
          (SELECT
            (LT
              (SX.64 (READ.argument2))
              (CONST.0))
            (SUB
              (SHL
                (CONST.1)
                (READ.shift))
              (CONST.1))
            (CONST.0)))
        (WRITE.result1
          (SHR
            (ADD
              (SX.64 (READ.argument2))
              (READ.bias))
            (READ.shift))))
  - ID: SLLD
    what: Shift Left Logical Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted left by the %3 modulo 64. The vacant positions are filled in with zeros.
      The result is stored into the %1.
    execution: &executionSLLD |
      new result1 = _ZX_64(argument2) << _ZX_6(argument3);
    behavior: &behaviorSLLD |
      (WRITE.result1
        (SHL
          (ZX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SRAD
    what: Shift Right Arithmetic Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted right by the %3 modulo 64. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand. The result is stored into the %1.
    execution: &executionSRAD |
      new result1 = _SX_64(argument2) >> _ZX_6(argument3);
    behavior: &behaviorSRAD |
      (WRITE.result1
        (SHR
          (SX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SRLD
    what: Shift Right Logical Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    description: >
      The %2 is shifted right by the %3 modulo 64. The vacant positions are filled in with zeros.
      The result is stored into the %1.
    execution: &executionSRLD |
      new result1 = _ZX_64(argument2) >> _ZX_6(argument3);
    behavior: &behaviorSRLD |
      (WRITE.result1
        (SHR
          (ZX.64 (READ.argument2))
          (ZX.6 (READ.argument3))))
  - ID: SLSD
    what: Shift Left Saturated Double Word
    formats: [ ALU_DSWRI, ALU_DSWRR ]
    description: >
      The %2 is shifted left by the %3 modulo 64. The result is saturated to 64 bits and stored into the %1.
    execution: |
      new shift = _ZX_6(argument3);
      new result1 = _SAT_64(_SX_64(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.6 (READ.argument3)))
        (WRITE.result1
          (SAT.64
            (SHL
              (SX.64 (READ.argument2))
              (READ.shift)))))
  - ID: SRSW
    what: Shift Right Symmetric Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      If non-negative, the %2 is shifted right by the %3 modulo 32.
      Else, the %2 biased by (2**(%3 modulo 32)) - 1 and shifted right by the %3 modulo 32.
      The result with the 32 upper bits cleared is stored into the %1.
      This instruction implements a signed division of the %2 least significant word by a power of two.
    execution: |
      new shift = _ZX_5(argument3);
      new bias = _SX_32(argument2) < 0 ? (1 << shift) - 1 : 0;
      new result1 = ((_SX_32(argument2) + bias) >> shift) & 0xFFFFFFFF;
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.bias
          (SELECT
            (LT
              (SX.32 (READ.argument2))
              (CONST.0))
            (SUB
              (SHL
                (CONST.1)
                (READ.shift))
              (CONST.1))
            (CONST.0)))
        (WRITE.result1
          (SHR
            (ADD
              (SX.32 (READ.argument2))
              (READ.bias))
            (READ.shift))))
  - ID: SLLW
    what: Shift Left Logical Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted left by the %3 modulo 32. The vacant positions are filled in with zeros.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2.32[0] << _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHL
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SRAW
    what: Shift Right Arithmetic Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted right by the %3 modulo 32. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _SX_32(argument2) >> _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHR
          (SX.32 (READ.argument2))
          (ZX.5 (READ.argument3))))
  - ID: SRLW
    what: Shift Right Logical Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    schedulings: [ ALU_TINY, ALU_TINY ]
    properties: { '%2': Left, '%3': Right }
    description: >
      The %2 is shifted right by the %3 modulo 32. The vacant positions are filled in with zeros.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = argument2.32[0] >> _ZX_5(argument3);
    behavior: |
      (WRITE.result1
        (SHR
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SLSW
    what: Shift Left Saturated Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is shifted left by the %3 modulo 32 then is saturated to 32 bits.
      The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      new result1 = _SAT_32(_SX_32(argument2) << shift);
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.result1
          (SAT.32
            (SHL
              (SX.32 (READ.argument2))
              (READ.shift)))))
  - ID: ROLW
    what: Rotate Left Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is rotated left by the %3 modulo 32. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ROL_32(argument2.32[0], _ZX_5(argument3));
    behavior: |
      (WRITE.result1
        (ROL.32
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: RORW
    what: Rotate Right Word
    formats: [ ALU_WSWRR, ALU_WSWRI ]
    description: >
      The %2 is rotated right by the %3 modulo 32. The result with the 32 upper bits cleared is stored into the %1.
    execution: |
      new result1 = _ROR_32(argument2.32[0], _ZX_5(argument3));
    behavior: |
      (WRITE.result1
        (ROR.32
          (READ.32[0].argument2)
          (ZX.5 (READ.argument3))))
  - ID: SRSWPS
    what: Shift Right Symmetric Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      If non-negative, each %2 word is shifted right by the %3 modulo 32.
      Else, each %2 word is biased by (2**(%3 modulo 32)) - 1 and shifted right by the %3 modulo 32.
      Each result is stored into the corresponding %1 word.
      This instruction implements a signed division of the %2 words by the power of two given by the %3 modulo 32.
    execution: |
      new shift = _ZX_5(argument3);
      new bias = (1 << shift) - 1;
      for (i range 2) {
        result1.32[i] = (_SX_32(argument2.32[i]) +
                        (_SX_32(argument2.32[i]) < 0 ? bias : 0)) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (WRITE.bias
          (SUB
            (SHL
              (CONST.1)
              (READ.shift))
            (CONST.1)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (ADD
                (SX.32 (READ.32[(INDEX.I)].argument2))
                (SELECT
                  (LT
                    (SX.32 (READ.32[(INDEX.I)].argument2))
                    (CONST.0))
                  (READ.bias)
                  (CONST.0)))
              (READ.shift)))))
  - ID: SLLWPS
    what: Shift Left Logical Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted left by the %3 modulo 32. The vacant positions are filled in with zeros.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = argument2.32[i] << shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHL
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRAWPS
    what: Shift Right Arithmetic Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted right by the %3 modulo 32. The leftmost bit are replicated to fill
      in the vacant positions, thereby extending the signs of the shifted operands.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _SX_32(argument2.32[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (SX.32 (READ.32[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SRLWPS
    what: Shift Right Logical Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted right by the %3 modulo 32. The vacant positions are filled in with zeros.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ZX_32(argument2.32[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SHR
              (ZX.32 (READ.32[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SLSWPS
    what: Shift Left Saturated Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are shifted left by the %3 modulo 32.
      The resulting words are saturated to 32 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _SAT_32(_SX_32(argument2.32[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (SAT.32
              (SHL
                (SX.32 (READ.32[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: ROLWPS
    what: Rotate Left Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are rotated left by the %3 modulo 32.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ROL_32(argument2.32[i], shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (ROL.32
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: RORWPS
    what: Rotate Right Word Pair by Scalar
    formats: [ ALU_WPSWRI, ALU_WPSWRR ]
    description: >
      The %2 is considered as two words packed into 64 bits.
      The %2 words are rotated right by the %3 modulo 32.
      The resulting words are packed and stored into the %1.
    execution: |
      new shift = _ZX_5(argument3);
      for (i range 2) {
        result1.32[i] = _ROR_32(argument2.32[i], shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.5 (READ.argument3)))
        (FOR.I (RANGE.2)
          (WRITE.32[(INDEX.I)].result1
            (ROR.32
              (READ.32[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRSHQS
    what: Shift Right Symmetric Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      If non-negative, each %2 half word is shifted right by the %3 modulo 16.
      Else, each %2 half word is biased by (2**(%3 modulo 16)) - 1 and shifted right by the %3 modulo 16.
      Each result is stored into the corresponding %1 half word.
      This instruction implements a signed division of the half words of the %2 by the power of two given by %3 modulo 16.
    execution: |
      new shift = _ZX_4(argument3);
      new bias = (1 << shift) - 1;
      for (i range 4) {
        result1.16[i] = (_SX_16(argument2.16[i]) +
                        (_SX_16(argument2.16[i]) < 0 ? bias : 0)) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (WRITE.bias
          (SUB
            (SHL
              (CONST.1)
              (READ.shift))
            (CONST.1)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (ADD
                (SX.16 (READ.16[(INDEX.I)].argument2))
                (SELECT
                  (LT
                    (SX.16 (READ.16[(INDEX.I)].argument2))
                    (CONST.0))
                  (READ.bias)
                  (CONST.0)))
              (READ.shift)))))
  - ID: SLLHQS
    what: Shift Left Logical Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted left by the %3 modulo 16. The vacant positions are filled in with zeros.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = argument2.16[i] << shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHL
              (READ.16[(INDEX.I)].argument2)
              (READ.shift)))))
  - ID: SRAHQS
    what: Shift Right Arithmetic Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted right by the %3 modulo 16. The leftmost bit is replicated to fill in the vacant positions,
      thereby extending the sign of the shifted operand.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _SX_16(argument2.16[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (SX.16 (READ.16[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SRLHQS
    what: Shift Right Logical Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted right by the %3 modulo 16. The vacant positions are filled in with zeros.
      The resulting half words are packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _ZX_16(argument2.16[i]) >> shift;
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SHR
              (ZX.16 (READ.16[(INDEX.I)].argument2))
              (READ.shift)))))
  - ID: SLSHQS
    what: Shift Left Saturated Half Word Quadruple by Scalar
    formats: [ ALU_HQSWRI, ALU_HQSWRR ]
    description: >
      The %2 is considered as four half words packed into 64 bits.
      The %2 half words are shifted left by the %3 modulo 16.
      The resulting half words are saturated to 16 bits, packed and stored into the %1.
    execution: |
      new shift = _ZX_4(argument3);
      for (i range 4) {
        result1.16[i] = _SAT_16(_SX_16(argument2.16[i]) << shift);
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (ZX.4 (READ.argument3)))
        (FOR.I (RANGE.4)
          (WRITE.16[(INDEX.I)].result1
            (SAT.16
              (SHL
                (SX.16 (READ.16[(INDEX.I)].argument2))
                (READ.shift))))))
  - ID: COMPD
    what: Compare Double Words
    formats: [ ALU_CWRI, ALU_CWRI.X, ALU_CWRI.Y, ALU_CWRR ]
    description: >
      The %2 is compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_64(argument4, argument2, argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (READ.argument2)
            (READ.argument3))))
  - ID: COMPW
    what: Compare Words
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    schedulings: [ ALU_TINY, ALU_TINY.X ]
    description: >
      The %2 is compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_32(argument4, argument2, argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_32
            (READ.argument4)
            (READ.argument2)
            (READ.argument3))))
  - ID: COMPWD
    what: Compare Word to Double Word
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    description: >
      The %2 is sign-extended from 32 bits and compared to the %3 using condition %4. The boolean result is stored into the %1.
    execution: |
      new result1 = comparison_64(argument4, _SX_32(argument2), argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (SX.32 (READ.argument2))
            (READ.argument3))))
  - ID: COMPUWD
    what: Compare Unsigned Word to Double Word
    formats: [ ALU_DCWRR, ALU_DCWRR.W ]
    description: >
      The %2 is zero-extended from 32 bits and compared to the %3 using condition %4. The boolean result is stored into the %2.
    execution: |
      new result1 = comparison_64(argument4, argument2.32[0], argument3);
    behavior: |
      (WRITE.result1
        (B2I
          (TEST.comparison_64
            (READ.argument4)
            (READ.32[0].argument2)
            (READ.argument3))))
  - ID: COMPNWP
    what: Compare Negate Word Pair
    formats: [ ALU_WPCNWRR, ALU_WPCNWRR.M ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are compared to the %3 words using condition %4.
      The resulting booleans are negated, packed and stored into the %1.
    execution: |
      result1.32[0] = -comparison_32(argument4, argument2.32[0], argument3.32[0]);
      result1.32[1] = -comparison_32(argument4, argument2.32[1], argument3.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (NEG
            (B2I
              (TEST.comparison_32
                (READ.argument4)
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.32[1].result1
          (NEG
            (B2I
              (TEST.comparison_32
                (READ.argument4)
                (READ.32[1].argument2)
                (READ.32[1].argument3))))))
  - ID: COMPNHQ
    what: Compare Negate Half Words Quadruple
    formats: [ ALU_HQCWRR, ALU_HQCWRR.M ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are compared to the %3 half words using condition %4.
      The resulting booleans are negated, packed and stored into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = -comparison_16(argument4, argument2.16[i], argument3.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (NEG
            (B2I
              (TEST.comparison_16
                (READ.argument4)
                (READ.16[(INDEX.I)].argument2)
                (READ.16[(INDEX.I)].argument3))))))
  - ID: CMOVED
    what: Conditional Move Double Word
    formats: [ ALU_DCMWRI, ALU_DCMWRI.X, ALU_DCMWRI.Y, ALU_DCMWRR ]
    description: >
      The %2 is tested using the condition %4. If true, the %3 is stored into the %1.
      This instruction is used to replace conditional branches during if-conversion.
    execution: |
      stage E1:
      if (scalarcond(argument4, argument2)) {
        %1 = argument3;
      }
    behavior: |
      (IF
        (TEST.scalarcond (READ.argument4) (READ.argument2))
        (COMMIT.E1.%1 (READ.argument3))
        (SKIP))
  - ID: CMOVEWP
    what: Conditional Move Words Packed
    formats: [ ALU_WPCMWRR, ALU_WPCMWRR.M ]
    description: >
      The %1, %2 and the %3 are considered as words packed into 64 bits.
      The %2 words are tested using the condition %4. If true, the corresponding
      word of the %3 is stored into the corresponding word of the %1.
    execution: |
      stage E1:
      if (simdcond_32(argument4, argument2.32[0]))
        %1.32[0] = argument3;
      if (simdcond_32(argument4, argument2.32[1]))
        %1.32[1] = argument3;
    behavior: |
      (SEQ
        (IF
          (TEST.simdcond_32
            (READ.argument4)
            (READ.32[0].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.32[0]))
          (SKIP))
        (IF
          (TEST.simdcond_32
            (READ.argument4)
            (READ.32[1].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.32[1]))
          (SKIP)))
  - ID: MAKE
    what: Make Word from Immediate
    formats: [ ALU_MAKE, ALU_MAKE.X, ALU_MAKE.Y ]
    description: >
      The %2 is stored into the %1.
    execution: |
      new result1 = _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (SX.64
          (READ.argument2)))
  - ID: PCREL
    what: PC-Relative
    formats: [ ALU_PCREL, ALU_PCREL.X, ALU_PCREL.Y ]
    schedulings: [ ALU_FULL, ALU_FULL.X, ALU_FULL.Y ]
    description: >
      The %2 is is added to the bundle \textbf{PC} and the result is stored into the %1.
    execution: |
      new result1 = PC + _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (F2I.64 (LOAD.RR (AGGL.PC (CONST.0) (CONST.1))))
          (SX.64
            (READ.argument2))))
  - ID: CLZW
    what: Count Leading Zero of Word
    formats: [ ALU_BWRW ]
    description: >
      The leading zero count value of the %2 is stored into the %1. When applied to zero, the result is 32.
    execution: |
      new result1 = _ZX_32(_CLZ_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CLZ.32 (READ.argument2))))
  - ID: CLSW
    what: Count Leading Sign of Word
    formats: [ ALU_BWRW ]
    description: >
      The leading sign count value of the %2 is stored into the %1. When applied to zero or -1, the result is 31.
    execution: |
      new result1 = _ZX_32(_CLS_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CLS.32 (READ.argument2))))
  - ID: CBSW
    what: Count Bit Set of Word
    formats: [ ALU_BWRW ]
    description: >
      Bit set population count value of the %2 is stored into the %1.
    execution: |
      new result1 = _ZX_32(_CBS_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CBS.32 (READ.argument2))))
  - ID: CTZW
    what: Count Trailing Zero of Word
    formats: [ ALU_BWRW ]
    description: >
      The trailing zero count value of the %2 is stored into the %1. When applied to zero, the result is 32.
    execution: |
      new result1 = _ZX_32(_CTZ_32(argument2));
    behavior: |
      (WRITE.result1
        (ZX.32
          (CTZ.32 (READ.argument2))))
  - ID: CLZD
    what: Count Leading Zero of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The leading zero count value of the %2 is stored into the %1. When applied to zero, the result is 64.
    execution: |
      new result1 = _ZX_64(_CLZ_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CLZ.64 (READ.argument2))))
  - ID: CLSD
    what: Count Leading Sign of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The leading sign count value of the %2 is stored into the %1. When applied to zero or -1, the result is 63.
    execution: |
      new result1 = _ZX_64(_CLS_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CLS.64 (READ.argument2))))
  - ID: CBSD
    what: Count Bit Set of Double Word
    formats: [ ALU_BWRD ]
    description: >
      Bit set population count value of the %2 is stored into the %1.
    execution: |
      new result1 = _ZX_64(_CBS_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CBS.64 (READ.argument2))))
  - ID: CTZD
    what: Count Trailing Zero of Double Word
    formats: [ ALU_BWRD ]
    description: >
      The trailing zero count value of the %2 is stored into the %1. When applied to zero, the result is 64.
    execution: |
      new result1 = _ZX_64(_CTZ_64(argument2));
    behavior: |
      (WRITE.result1
        (ZX.64
          (CTZ.64 (READ.argument2))))
  - ID: CLZWP
    what: Count Leading Zeroes of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The leading zero count values of the %2 interpreted as a word pair are stored into the %1.
      When applied to zero at the word level, the result is 32.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CLZ_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CLZ.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CLSWP
    what: Count Leading Signs of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The leading sign count values of the %2 interpreted as word pair are stored into the %1.
      When applied to zero or -1 at the word level, the result is 31.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CLS_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CLS.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CBSWP
    what: Count Bit Sets of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      Bit set population count values of the %2 interpreted as word pair are stored into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CBS_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CBS.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: CTZWP
    what: Count Trailing Zeroes of Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The trailing zero count values of the %2 interpreted as word pair are stored into the %1.
      When applied to zero at the word level, the result is 32.
    execution: |
      for (i range 2) {
        result1.32[i] = _ZX_32(_CTZ_32(argument2.32[i]));
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ZX.32
            (CTZ.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: SXLHWP
    what: Sign Extend Least Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The %2 is considered as two half words packed into the least significant 32 bits.
      Each half word is sign-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _SX_16(argument2.16[0]);
      result1.32[1] = _SX_16(argument2.16[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (SX.16
            (READ.16[0].argument2)))
        (WRITE.32[1].result1
          (SX.16
            (READ.16[1].argument2))))
  - ID: SXMHWP
    what: Sign Extend Most Significant Half Words to Word Pair
    formats: [ ALU_BWRWP ]
    description: >
      The %2 is considered as two half words packed into the most significant 32 bits.
      Each half word is sign-extended to 32 bits and stored into one of the words of the %1.
    execution: |
      result1.32[0] = _SX_16(argument2.16[2]);
      result1.32[1] = _SX_16(argument2.16[3]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (SX.16
            (READ.16[2].argument2)))
        (WRITE.32[1].result1
          (SX.16
            (READ.16[3].argument2))))
  - ID: SXLBHQ
    what: Sign Extend Least Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    description: >
      The %2 is considered as four bytes packed into the least significant 32 bits.
      Each byte is sign-extended to 16-bit and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _SX_8(argument2.8[0]);
      result1.16[1] = _SX_8(argument2.8[1]);
      result1.16[2] = _SX_8(argument2.8[3]);
      result1.16[3] = _SX_8(argument2.8[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (SX.8
            (READ.8[0].argument2)))
        (WRITE.16[1].result1
          (SX.8
            (READ.8[1].argument2)))
        (WRITE.16[2].result1
          (SX.8
            (READ.8[2].argument2)))
        (WRITE.16[3].result1
          (SX.8
            (READ.8[3].argument2))))
  - ID: SXMBHQ
    what: Sign Extend Most Significant Bytes to Half Word Quadruple
    formats: [ ALU_LWRHQ ]
    description: >
      The %2 is considered as four bytes packed into the most significant 32 bits.
      Each byte is sign-extended to 16 bits and stored into one of the half words of the %1.
    execution: |
      result1.16[0] = _SX_8(argument2.8[4]);
      result1.16[1] = _SX_8(argument2.8[5]);
      result1.16[2] = _SX_8(argument2.8[6]);
      result1.16[3] = _SX_8(argument2.8[7]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (SX.8
            (READ.8[4].argument2)))
        (WRITE.16[1].result1
          (SX.8
            (READ.8[5].argument2)))
        (WRITE.16[2].result1
          (SX.8
            (READ.8[6].argument2)))
        (WRITE.16[3].result1
          (SX.8
            (READ.8[7].argument2))))
  - ID: CMOVEHQ
    what: Conditional Move Half Words Quadruple
    formats: [ ALU_CMWRRHQ, ALU_CMWRRHQ.M ]
    description: >
      The %1, %2 and the %3 are considered as half words packed into 64 bits.
      The %2 half words are tested using the condition %4. If true, the corresponding
      half word of the %3 is stored into the corresponding half word of the %1.
    execution: |
      stage E1:
      if (simdcond_16(argument4, argument2.16[0]))
        %1.16[0] = argument3;
      if (simdcond_16(argument4, argument2.16[1]))
        %1.16[1] = argument3;
      if (simdcond_16(argument4, argument2.16[2]))
        %1.16[2] = argument3;
      if (simdcond_16(argument4, argument2.16[3]))
        %1.16[3] = argument3;
    behavior: |
      (SEQ
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[0].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[0]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[1].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[1]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[2].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[2]))
          (SKIP))
        (IF
          (TEST.simdcond_16
            (READ.argument4)
            (READ.16[3].argument2))
          (COMMIT.E1.%1 (READ.argument3) (CONST.16[3]))
          (SKIP)))
  - ID: FCOMPW
    what: Floating-Point Compare Single
    class: FPU
    formats: [ ALU_FCWRRS, ALU_FCWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 32
      floating-point numbers. The boolean result is stored into the %1.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = floatcomp_32(argument4, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (B2I
            (TEST.floatcomp_32
              (READ.argument4)
              (READ.argument2)
              (READ.argument3)))))
  - ID: FCOMPD
    what: Floating-Point Compare Double
    class: FPU
    formats: [ ALU_FCWRRS, ALU_FCWRRS.W ]
    description: >
      The %2 is compared to the %3 using condition %4, assuming binary 64
      floating-point numbers. The boolean result is stored into the %1.
      This instruction does not raise an invalid exception when handling
      a signaling NaN.
    execution: |
      new result1 = floatcomp_64(argument4, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (B2I
            (TEST.floatcomp_64
              (READ.argument4)
              (READ.argument2)
              (READ.argument3)))))
  - ID: FCOMPNWP
    what: Floating-Point Compare Negate Word Pair
    class: FPU
    formats: [ ALU_WPFCWRR, ALU_WPFCWRR.M ]
    description: >
      The %2 and the %3 are considered as two words packed into 64 bits.
      The %2 words are compared to the %3 words using condition %4, assuming binary 32
      floating-point numbers. The resulting booleans are negated, packed and stored into the %1.
      This instruction does not raise an invalid exception when handling a signaling NaN.
    execution: |
      result1.32[0] = -floatcomp_32(argument4, argument2.32[0], argument3.32[0]);
      result1.32[1] = -floatcomp_32(argument4, argument2.32[1], argument3.32[1]);
    behavior: |
      (SEQ
        (WRITE.32[0].result1
          (NEG
            (B2I
              (TEST.floatcomp_32
                (READ.argument4)
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.32[1].result1
          (NEG
            (B2I
              (TEST.floatcomp_32
                (READ.argument4)
                (READ.32[1].argument2)
                (READ.32[1].argument3))))))
  - ID: FCOMPNHQ
    what: Floating-Point Compare Negate Half Word Quadruple
    class: FPU
    formats: [ ALU_HQFCWRR, ALU_HQFCWRR.M ]
    description: >
      The %2 and the %3 are considered as four half words packed into 64 bits.
      The %2 half words are compared to the %3 half words using condition %4, assuming binary 16
      floating-point numbers. The resulting booleans are negated, packed and stored into the %1.
      This instruction does not raise an invalid exception when handling a signaling NaN.
    execution: |
      result1.16[0] = -floatcomp_16(argument4, argument2.16[0], argument3.16[0]);
      result1.16[1] = -floatcomp_16(argument4, argument2.16[1], argument3.16[1]);
      result1.16[2] = -floatcomp_16(argument4, argument2.16[2], argument3.16[2]);
      result1.16[3] = -floatcomp_16(argument4, argument2.16[3], argument3.16[3]);
    behavior: |
      (SEQ
        (WRITE.16[0].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[0].argument2)
                (READ.16[0].argument3)))))
        (WRITE.16[1].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[1].argument2)
                (READ.16[1].argument3)))))
        (WRITE.16[2].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[2].argument2)
                (READ.16[2].argument3)))))
        (WRITE.16[3].result1
          (NEG
            (B2I
              (TEST.floatcomp_16
                (READ.argument4)
                (READ.16[3].argument2)
                (READ.16[3].argument3))))))
  - ID: FSDIVD
    what: Floating-Point Seed for Division Double Word
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      An approximate value of the division of the least significant half by the most significant half of the %2,
      interpreted as binary 64 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fsdiv_64(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fsdiv_64
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVD
    what: Floating-Point Cases for Division Double Word
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The value of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as binary 64 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fcdiv_64(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fcdiv_64
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FSDIVW
    what: Floating-Point Seed for Word Division
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      An approximate value of the division of the least significant half by the most significant half of the %2,
      interpreted as binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[2];
      new result1 = fsdiv_32(argument_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (READ.32[0].argument2))
        (WRITE.argument2_1
          (READ.32[2].argument2))
        (WRITE.result1
          (APPLY.fsdiv_32
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVW
    what: Floating-Point Cases for Word Division
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The value of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = argument2.32[0];
      new argument2_1 = argument2.32[2];
      new result1 = fcdiv_32(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (READ.32[0].argument2))
        (WRITE.argument2_1
          (READ.32[2].argument2))
        (WRITE.result1
          (APPLY.fcdiv_32
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FSDIVWP
    what: Floating-Point Seed for Division Word Pair
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The pair of values of the special case for the division of the least significant half by the most significant half of the %2,
      interpreted as pairs of binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fsdiv_32_x2(argument_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fsdiv_32_x2
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FCDIVWP
    what: Floating-Point Cases for Division Word Pair
    class: FPU
    formats: [ ALU_DFWRR ]
    description: >
      The pair of values of the special cases for the division of the least significant half by the most significant half of the %2,
      interpreted as pairs of binary 32 floating-point numbers, is stored into the %1.
      This instruction may raise division by zero, inexact, invalid or overflow exception bits in the CS register.
    execution: |
      new argument2_0 = _ZX_64(argument2);
      new argument2_1 = _ZX_64(argument2 >> 64);
      new result1 = fcdiv_32_x2(argument2_0, argument2_1);
    behavior: |
      (SEQ
        (WRITE.argument2_0
          (ZX.64 (READ.argument2)))
        (WRITE.argument2_1
          (ZX.64 (SHR (READ.argument2) (CONST.64))))
        (WRITE.result1
          (APPLY.fcdiv_32_x2
            (READ.argument2_0)
            (READ.argument2_1))))
  - ID: FMIND
    what: Floating-Point Minimum Double Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 64
      floating-point numbers. The minimum is stored into the %1.
    execution: |
      new result1 = fmin_64(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmin_64
        (READ.argument2)
        (READ.argument3)))
  - ID: FMAXD
    what: Floating-Point Maximum Double Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 64
      floating-point numbers. The maximum is stored into the %1.
    execution: |
      new result1 = fmax_64(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmax_64
        (READ.argument2)
        (READ.argument3)))
  - ID: FMINW
    what: Floating-Point Minimum Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 32 floating-point
      numbers. The minimum is stored into the %1.
    execution: |
      new result1 = fmin_32(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmin_32
          (READ.argument2)
          (READ.argument3)))
  - ID: FMAXW
    what: Floating-Point Maximum Word
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming binary 32 floating-point
      numbers. The maximum is stored into the %1.
    execution: |
      new result1 = fmax_32(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmax_32
          (READ.argument2)
          (READ.argument3)))
  - ID: FMINWP
    what: Floating-Point Minimum Word Pair
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming pairs of binary 32 floating-point
      numbers. The pair of minimum values is stored into the %1.
    execution: |
      new result1 = fmin_32_x2(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmin_32_x2
          (READ.argument2)
          (READ.argument3)))
  - ID: FMAXWP
    what: Floating-Point Maximum Word Pair
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming pairs of binary 32 floating-point
      numbers. The pair of maximum values is stored into the %1.
    execution: |
      new result1 = fmax_32_x2(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmax_32_x2
          (READ.argument2)
          (READ.argument3)))
  - ID: FMINHQ
    what: Floating-Point Minimum Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming quadruple of binary 16 floating-point
      numbers. The quadruple of minimum values is stored into the %1.
    execution: |
      new result1 = fmin_16_x4(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmin_16_x4
          (READ.argument2)
          (READ.argument3)))
  - ID: FMAXHQ
    what: Floating-Point Maximum Half Word Quadruple
    class: FPU
    formats: [ ALU_DFWRD ]
    description: >
      The %2 is compared to the %3, assuming quadruple of binary 16 floating-point
      numbers. The quadruple of maximum values is stored into the %1.
    execution: |
      new result1 = fmax_16_x4(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmax_16_x4
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATD
    what: Floating Point Conversion from Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit signed integer is converted to a
      64-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATWP
    what: Floating Point Conversion from Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit signed integer pair is converted to a
      32-bit floating-point number pair according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FLOATHQ
## what: Floating Point Conversion from Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit signed integer quadruple is converted to a
## 16-bit floating-point number quadruple according to the rounding mode %4 and
## then divided by (1<<%3). This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = float_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.float_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FLOATW
    what: Floating Point Conversion from Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit signed integer is converted to a
      32-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = float_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.float_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATUD
    what: Floating Point Conversion from Unsigned Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit unsigned integer is converted to a
      64-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FLOATUWP
    what: Floating Point Conversion from Unsigned Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit unsigned integer pair is converted to a
      32-bit floating-point number pair according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FLOATUHQ
## what: Floating Point Conversion from Unsigned Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit unsigned integer quadruple is converted to a
## 16-bit floating-point number quadruple according to the rounding mode %4 and
## then divided by (1<<%3). This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = floatu_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.floatu_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FLOATUW
    what: Floating Point Conversion from Unsigned Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit unsigned integer is converted to a
      32-bit floating-point number according to the rounding mode %4 and
      then divided by (1<<%3). This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = floatu_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.floatu_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDD
    what: Floating Point Conversion to Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit floating-point number is multiplied
      by (1<<%3) then converted to a 64-bit signed integer according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixed_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDWP
    what: Floating Point Conversion to Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number pair is multiplied
      by (1<<%3) then converted to a 32-bit signed integer pair according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixed_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
## - ID: FIXEDHQ
## what: Floating Point Conversion to Fixed-Point Half Word Quadruple
## class: FPU
## formats: [ MAU_FDD ]
## description: >
## The %2 interpreted as a 16-bit floating-point number quadruple is multiplied
## by (1<<%3) then converted to a 16-bit signed integer quadruple according to
## the rounding mode %4. This instruction may raise inexact or
## invalid exception bits in the CS register.
## execution: |
## new result1 = fixed_16_x4(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.fixed_16_x4
## (READ.RM)
## (READ.argument2)
## (READ.argument3)))
  - ID: FIXEDW
    what: Floating Point Conversion to Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number is multiplied
      by (1<<%3) then converted to a 32-bit signed integer according to
      the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register. As this instructions belongs to the 32-bit ISA subset,
      the 32 upper bits of the destination register are cleared even if the resulting word is negative.
    execution: |
      new result1 = fixed_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixed_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUD
    what: Floating Point Conversion to Unsigned Fixed-Point Double
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 64-bit floating-point number is multiplied
      by (1<<%3) then converted to a 64-bit unsigned integer according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUWP
    what: Floating Point Conversion to Unsigned Fixed-Point Word Pair
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number pair is multiplied
      by (1<<%3) then converted to a 32-bit unsigned integer pair according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FIXEDUW
    what: Floating Point Conversion to Unsigned Fixed-Point
    class: FPU
    formats: [ MAU_FDD ]
    description: >
      The %2 interpreted as a 32-bit floating-point number is multiplied
      by (1<<%3) then converted to a 32-bit unsigned integer according
      to the rounding mode %4. This instruction may raise inexact or
      invalid exception bits in the CS register.
    execution: |
      new result1 = fixedu_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fixedu_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: MADDD
    what: Multiply-Add Double Word
    formats: [ MAU_DDDI0, MAU_DDDI0.X, MAU_DDDI0.Y, MAU_DDDD0 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFD
    what: Multiply-Subtract Double Word
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDWP
    what: Multiply-Add Word Pair
    formats: [ MAU_DDDI0, MAU_DDDI0.X, MAU_DDDI0.Y, MAU_DDDD0 ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are added to the respective words of the %1.
      The resulting paired word is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument1.32[i] + _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFWP
    what: Multiply-Subtract Word Pair
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are subtracted from the respective words of the %1.
      The resulting paired word is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = argument1.32[i] - _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDHQ
    what: Multiply-Add Half Word Quadruple
    formats: [ MAU_DDDI0, MAU_DDDI0.X, MAU_DDDI0.Y, MAU_DDDD0 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are added to the respective half words of the %1.
      The resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument1.16[i] + _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (ADD
            (READ.16[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFHQ
    what: Multiply-Subtract Half Word Quadruple
    formats: [ MAU_DDDD0, MAU_DDDD0.M ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are subtracted from to the respective half words of the %1.
      The resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = argument1.16[i] - _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (SUB
            (READ.16[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDHWQ
    what: Multiply-Add Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFHWQ
    what: Multiply-Subtract Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.16[i] - _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (SX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDUHWQ
    what: Multiply-Add Unsigned Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFUHWQ
    what: Multiply-Subtract Unsigned Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (ZX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDSUHWQ
    what: Multiply-Add Signed by Unsigned Half Word to Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are added to the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] + _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (ADD
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MSBFSUHWQ
    what: Multiply-Subtract Signed by Unsigned Half Word from Word Quadruple
    formats: [ MAU_QQDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are subtracted from the respective words of the %1.
      The resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = argument1.32[i] - _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (SUB
            (READ.32[(INDEX.I)].argument1)
            (MUL
              (ZX.16 (READ.16[(INDEX.I)].argument3))
              (SX.16 (READ.16[(INDEX.I)].argument2))))))
  - ID: MADDDT
    what: Multiply-Add Double to Tetra Word
    formats: [ MAU_QQDI, MAU_QQDI.X, MAU_QQDI.Y, MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is added to the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_SX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDUDT
    what: Multiply-Add Unsigned Double to Tetra Word
    formats: [ MAU_QQDI, MAU_QQDI.X, MAU_QQDI.Y, MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is added to the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_ZX_64(argument3) * _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MADDSUDT
    what: Multiply-Add Signed by Unsigned Double to Tetra Word
    formats: [ MAU_QQDI, MAU_QQDI.X, MAU_QQDI.Y, MAU_QQDD1 ]
    description: >
      The %3 assuming unsigned 64-bit integer and the %2 assuming signed 64-bit integer are multiplied.
      The product is added to the 128 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 + (_ZX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MADDUZDT
    what: Multiply-Add Unsigned Double to Tetra Word
    formats: [ MAU_QQDI, MAU_QQDI.X, MAU_QQDI.Y, MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is added to the upper 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1 >> 64) + _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (ZX.64
            (SHR
              (READ.argument1)
              (CONST.64)))
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MSBFDT
    what: Multiply-Subtract Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers,
      and the product is subtracted from the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_SX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFUDT
    what: Multiply-Subtract Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is subtracted from the 128 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_ZX_64(argument3) * _ZX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MSBFSUDT
    what: Multiply-Subtract Signed by Unsigned Double to Tetra Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 assuming unsigned 64-bit integer and the %2 assuming signed 64-bit integer are multiplied.
      The product is subtracted from the 128 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 - (_ZX_64(argument3) * _SX_64(argument2));
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.64 (READ.argument3))
            (SX.64 (READ.argument2)))))
  - ID: MSBFUZDT
    what: Multiply-Subtract Unsigned Double to Quadruple Word
    formats: [ MAU_QQDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned 64-bit integers,
      and the product is subtracted from the upper 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1 >> 64) - _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (ZX.64
            (SHR
              (READ.argument1)
              (CONST.64)))
          (MUL
            (ZX.64 (READ.argument3))
            (ZX.64 (READ.argument2)))))
  - ID: MULD
    what: Multiply Double Word
    formats: [ MAU_DDI, MAU_DDI.X, MAU_DDI.Y, MAU_DDD0 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers. The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MULDT
    what: Multiply Double Word to Tetra Word
    formats: [ MAU_QDI, MAU_QDI.X, MAU_QDI.Y, MAU_QDD1 ]
    description: >
      The %3 is multiplied by the %2, assuming 64-bit integers. The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: MULUDT
    what: Multiply Unsigned Double Words to Tetra Word
    formats: [ MAU_QDI, MAU_QDI.X, MAU_QDI.Y, MAU_QDD1 ]
    description: >
      The %3 is multiplied by the %2 assuming unsigned double integers
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_64(argument3) * _ZX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.64 (READ.argument3))
          (ZX.64 (READ.argument2))))
  - ID: MULSUDT
    what: Multiply Signed by Unsigned Double Words to Tetra Word
    formats: [ MAU_QDI, MAU_QDI.X, MAU_QDI.Y, MAU_QDD1 ]
    description: >
      The %3 assuming unsigned double integer and the %2 assuming signed double integer are multiplied.
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_64(argument3) * _SX_64(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.64 (READ.argument3))
          (SX.64 (READ.argument2))))
  - ID: CMULDT
    what: Carryless Multiply Double Words to Tetra Word
    formats: [ MAU_QDI, MAU_QDI.X, MAU_QDI.Y, MAU_QDD1 ]
    description: >
      The %3 assuming double integer is carryless multiplied by the %2 assuming double integer.
      The 128 bits of the result are stored into the %1.
    execution: |
      new result1 = clm_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.clm_64_128
          (READ.argument2)
          (READ.argument3)))
  - ID: CMULXDT
    what: Carryless Multiply and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is carryless multiplied by the %2 assuming double integer.
      The final 128 bits of the result are XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ clm_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.clm_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGLXDT
    what: Carryless Multiply Galois Low and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is XOR-ed to itself left-shifted by 64 and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_bb_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_bb_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGMXDT
    what: Carryless Multiply Galois Middle and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is left-shifted by 64 and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_bt_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_bt_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CMULGHXDT
    what: Carryless Multiply Galois High and Xor Double Words to Tetra Word
    formats: [ MAU_QQDD2 ]
    description: >
      The %3 assuming double integer is reflected and then carryless multiplied by the reflection of the %2 assuming double integer.
      The 128 bits results is left-shifted by 128 and 64, shift results are XOR-ed together and then reduced modulo the GCM polynomial.
      The 128 bits of the result are reflected and XOR-ed with %1 and then stored into the %1.
    execution: |
      new result1 = argument1 ^ gcm_tt_64_128(argument2, argument3);
    behavior: |
      (WRITE.result1
        (XOR
          (READ.argument1)
          (APPLY.gcm_tt_64_128
            (READ.argument2)
            (READ.argument3))))
  - ID: CRCBELMW
    what: Cyclic Redundancy Check Big-Endian Least Significant with Most Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 most significant bytes
      of the %2 considered in reverse order. The result is reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3.
      The result is stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ _SWAP_16(_SWAP_8(argument2 >> 32));
      new result1 = crc32_be_u32(argument1_data.32[0], argument3.32[0]);
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (SWAP.16 (SWAP.8 (SHR (READ.argument2) (CONST.32))))))
        (WRITE.result1
          (APPLY.32.crc32_be_u32
            (READ.32[0].argument1_data)
            (READ.32[0].argument3))))
  - ID: CRCBELLW
    what: Cyclic Redundancy Check Big-Endian Least Significant with Least Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 least significant bytes
      of the %2 considered in reverse order. The result is reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3.
      The result is stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ _SWAP_16(_SWAP_8(argument2));
      new result1 = crc32_be_u32(argument1_data.32[0], argument3.32[0]);
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (SWAP.16 (SWAP.8 (READ.argument2) ))))
        (WRITE.result1
          (APPLY.32.crc32_be_u32
            (READ.32[0].argument1_data)
            (READ.32[0].argument3))))
  - ID: CRCLELMW
    what: Cyclic Redundancy Check Little-Endian Least Significant with Most Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 most significant bytes
      of the %2. The result is bit reversed and then reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3 bit reversed beforehand.
      The result is bit reversed and stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ argument2.32[1];
      new result1 = reflect_32(crc32_be_u32(reflect_32(argument1_data.32[0]), reflect_32(argument3.32[0])));
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (READ.32[1].argument2)))
        (WRITE.result1
          (APPLY.32.reflect_32
              (APPLY.32.crc32_be_u32
                (APPLY.32.reflect_32 (READ.32[0].argument1_data))
                (APPLY.32.reflect_32 (READ.32[0].argument3))))))
  - ID: CRCLELLW
    what: Cyclic Redundancy Check Little-Endian Least Significant with Least Significant Words
    formats: [ MAU_CRC, MAU_CRC.W ]
    description: >
      The 4 least significant bytes of the %1 are XOR-ed with the 4 least significant bytes
      of the %2. The result is bit reversed and then reduced modulo the 4-byte polynomial
      stored in the 4 least significant bytes of the %3 bit reversed beforehand.
      The result is bit reversed and stored back into the %1.
    execution: |
      new argument1_data = argument1.32[0] ^ argument2.32[0];
      new result1 = reflect_32(crc32_be_u32(reflect_32(argument1_data.32[0]), reflect_32(argument3.32[0])));
    behavior: |
      (SEQ
        (WRITE.argument1_data
          (XOR
            (READ.32[0].argument1)
            (READ.32[0].argument2)))
        (WRITE.result1
          (APPLY.32.reflect_32
              (APPLY.32.crc32_be_u32
                (APPLY.32.reflect_32 (READ.32[0].argument1_data))
                (APPLY.32.reflect_32 (READ.32[0].argument3))))))
  - ID: DOT2WD
    what: Dot product of 2x Word Vectors into Double Word
    formats: [ MAU_DPI, MAU_DPI.X, MAU_DPI.Y, MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming signed integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _SX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                  + _SX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (SX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2)))
          (MUL
            (SX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: DOT2UWD
    what: Dot product of 2x Unsigned Word Vectors into Double Word
    formats: [ MAU_DPI, MAU_DPI.X, MAU_DPI.Y, MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming unsigned integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0]) * _ZX_32(argument2.32[0])
                  + _ZX_32(argument3.32[1]) * _ZX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (ZX.32 (READ.32[0].argument3))
            (ZX.32 (READ.32[0].argument2)))
          (MUL
            (ZX.32 (READ.32[1].argument3))
            (ZX.32 (READ.32[1].argument2)))))
  - ID: DOT2SUWD
    what: Dot product of 2x Signed by Unsigned Word Vectors into Double Word
    formats: [ MAU_DPI, MAU_DPI.X, MAU_DPI.Y, MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming unsigned and signed integers.
      The resulting double word is stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                  + _ZX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ADD
          (MUL
            (ZX.32 (READ.32[0].argument3))
            (SX.32 (READ.32[0].argument2)))
          (MUL
            (ZX.32 (READ.32[1].argument3))
            (SX.32 (READ.32[1].argument2)))))
  - ID: DOT2W
    what: Dot product of 2x Word Vectors into Word
    formats: [ MAU_DPI, MAU_DPI.X, MAU_DPI.Y, MAU_DPP ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The dot-product of the %3 word pair and the %2 word pair is computed, assuming integers.
      The result is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0] * argument2.32[0]
                           + argument3.32[1] * argument2.32[1]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (ADD
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2))
            (MUL
              (READ.32[1].argument3)
              (READ.32[1].argument2)))))
  - ID: DOT2WDP
    what: Dot products of 2x Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming signed integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming signed integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _SX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                    + _SX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
      result1.64[1] = _SX_32(argument3.32[2]) * _SX_32(argument2.32[2])
                    + _SX_32(argument3.32[3]) * _SX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (SX.32 (READ.32[0].argument3))
              (SX.32 (READ.32[0].argument2)))
            (MUL
              (SX.32 (READ.32[1].argument3))
              (SX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (SX.32 (READ.32[2].argument3))
              (SX.32 (READ.32[2].argument2)))
            (MUL
              (SX.32 (READ.32[3].argument3))
              (SX.32 (READ.32[3].argument2))))))
  - ID: DOT2UWDP
    what: Dot products of 2x Unsigned Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming unsigned integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming unsigned integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0]) * _ZX_32(argument2.32[0])
                    + _ZX_32(argument3.32[1]) * _ZX_32(argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2]) * _ZX_32(argument2.32[2])
                    + _ZX_32(argument3.32[3]) * _ZX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[0].argument3))
              (ZX.32 (READ.32[0].argument2)))
            (MUL
              (ZX.32 (READ.32[1].argument3))
              (ZX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[2].argument3))
              (ZX.32 (READ.32[2].argument2)))
            (MUL
              (ZX.32 (READ.32[3].argument3))
              (ZX.32 (READ.32[3].argument2))))))
  - ID: DOT2SUWDP
    what: Dot products of 2x Signed by Unsigned Word Vectors into Double Word Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming unsigned and signed integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming unsigned and signed integers.
      The resulting pair of double words is packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0]) * _SX_32(argument2.32[0])
                    + _ZX_32(argument3.32[1]) * _SX_32(argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2]) * _SX_32(argument2.32[2])
                    + _ZX_32(argument3.32[3]) * _SX_32(argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[0].argument3))
              (SX.32 (READ.32[0].argument2)))
            (MUL
              (ZX.32 (READ.32[1].argument3))
              (SX.32 (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ADD
            (MUL
              (ZX.32 (READ.32[2].argument3))
              (SX.32 (READ.32[2].argument2)))
            (MUL
              (ZX.32 (READ.32[3].argument3))
              (SX.32 (READ.32[3].argument2))))))
  - ID: DOT2WZP
    what: Dot products of 2x Word Vectors into Word Zero Extended Pair
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming integers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming integers.
      The resulting pair of words are zero-extended to 64-bit, packed and stored back into the %1.
    execution: |
      result1.64[0] = _ZX_32(argument3.32[0] * argument2.32[0] + argument3.32[1] * argument2.32[1]);
      result1.64[1] = _ZX_32(argument3.32[2] * argument2.32[2] + argument3.32[3] * argument2.32[3]);
    behavior: |
      (SEQ
        (WRITE.64[0].result1
          (ZX.32
            (ADD
              (MUL
                (READ.32[0].argument3)
                (READ.32[0].argument2))
              (MUL
                (READ.32[1].argument3)
                (READ.32[1].argument2)))))
        (WRITE.64[1].result1
          (ZX.32
            (ADD
              (MUL
                (READ.32[2].argument3)
                (READ.32[2].argument2))
              (MUL
                (READ.32[3].argument3)
                (READ.32[3].argument2))))))
  - ID: MULWQ
    what: Multiply Word Quadruple
    formats: [ MAU_QQQ ]
    description: >
      The %3 and the %2 are considered as four words packed into 128 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The four resulting words are packed into 128 bits and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULWP
    what: Multiply Word Pair
    formats: [ MAU_DDI, MAU_DDI.X, MAU_DDI.Y, MAU_DDD0 ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming signed integers.
      The two resulting words are packed and stored back into the %1.
    execution: |
      for (i range 2) {
        result1.32[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULHQ
    what: Multiply Half Word Quadruple
    formats: [ MAU_DDI, MAU_DDI.X, MAU_DDI.Y, MAU_DDD0 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting half words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.16[i] = _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.16[(INDEX.I)].result1
          (MUL
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULWC
    what: Multiply Word Complex
    formats: [ MAU_DDI, MAU_DDI.X, MAU_DDI.Y, MAU_DDD0 ]
    description: >
      The %3 and the %2 are considered as word complex packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming complex signed integers.
      The two resulting words are paired and stored back into the %1.
    execution: |
      new argument3_l = argument3.32[0];
      new argument3_m = argument3.32[1];
      new argument2_l = argument2.32[0];
      new argument2_m = argument2.32[1];
      new result1_l = (_SX_32(argument2_l) * _SX_32(argument3_l)) - (_SX_32(argument2_m) * _SX_32(argument3_m));
      new result1_m = (_SX_32(argument2_l) * _SX_32(argument3_m)) + (_SX_32(argument2_m) * _SX_32(argument3_l));
      new result1 = (result1_m << 32) | result1_l.32[0];
    behavior: |
      (SEQ
        (WRITE.argument3_l (READ.32[0].argument3))
        (WRITE.argument3_m (READ.32[1].argument3))
        (WRITE.argument2_l (READ.32[0].argument2))
        (WRITE.argument2_m (READ.32[1].argument2))
        (WRITE.result1_l
          (SUB
            (MUL
              (SX.32 (READ.argument2_l))
              (SX.32 (READ.argument3_l)))
            (MUL
              (SX.32 (READ.argument2_m))
              (SX.32 (READ.argument3_m)))))
        (WRITE.result1_m
          (ADD
             (MUL
               (SX.32 (READ.argument2_l))
               (SX.32 (READ.argument3_m)))
             (MUL
               (SX.32 (READ.argument2_m))
               (SX.32 (READ.argument3_l)))))
        (WRITE.result1
          (IOR
            (SHL (READ.result1_m) (CONST.32))
            (READ.32[0].result1_l))))
  - ID: MULWC.C
    what: Multiply Word Complex Conjugate
    formats: [ MAU_DDD1 ]
    description: >
      The %3 and the %2 are considered as word complex packed into 64 bits.
      The %3 words and the %2 words conjugate are multiplied, assuming complex signed integers.
      The two resulting words are paired and stored back into the %1.
    execution: |
      new argument3_l = argument3.32[0];
      new argument3_m = argument3.32[1];
      new argument2_l = argument2.32[0];
      new argument2_m = argument2.32[1];
      new result1_l = (_SX_32(argument2_l) * _SX_32(argument3_l)) + (_SX_32(argument2_m) * _SX_32(argument3_m));
      new result1_m = (_SX_32(argument2_l) * _SX_32(argument3_m)) - (_SX_32(argument2_m) * _SX_32(argument3_l));
      new result1 = (result1_m << 32) | result1_l.32[0];
    behavior: |
      (SEQ
        (WRITE.argument3_l (READ.32[0].argument3))
        (WRITE.argument3_m (READ.32[1].argument3))
        (WRITE.argument2_l (READ.32[0].argument2))
        (WRITE.argument2_m (READ.32[1].argument2))
        (WRITE.result1_l
          (ADD
            (MUL
              (SX.32 (READ.argument2_l))
              (SX.32 (READ.argument3_l)))
            (MUL
              (SX.32 (READ.argument2_m))
              (SX.32 (READ.argument3_m)))))
        (WRITE.result1_m
          (SUB
             (MUL
               (SX.32 (READ.argument2_l))
               (SX.32 (READ.argument3_m)))
             (MUL
               (SX.32 (READ.argument2_m))
               (SX.32 (READ.argument3_l)))))
        (WRITE.result1
          (IOR
            (SHL (READ.result1_m) (CONST.32))
            (READ.32[0].result1_l))))
  - ID: MULWDC
    what: Multiply Word Complex to Double Word Complex
    formats: [ MAU_QDD2 ]
    description: >
      The %3 and the %2 are considered as word complex packed into 64 bits.
      The %3 words and the %2 words are multiplied, assuming complex signed integers.
      The two resulting double words are paired and stored back into the %1.
    execution: |
      new argument3_l = argument3.32[0];
      new argument3_m = argument3.32[1];
      new argument2_l = argument2.32[0];
      new argument2_m = argument2.32[1];
      new result1_l = (_SX_32(argument2_l) * _SX_32(argument3_l)) - (_SX_32(argument2_m) * _SX_32(argument3_m));
      new result1_m = (_SX_32(argument2_l) * _SX_32(argument3_m)) + (_SX_32(argument2_m) * _SX_32(argument3_l));
      new result1 = (result1_m << 64) | _ZX_64(result1_l);
    behavior: |
      (SEQ
        (WRITE.argument3_l (READ.32[0].argument3))
        (WRITE.argument3_m (READ.32[1].argument3))
        (WRITE.argument2_l (READ.32[0].argument2))
        (WRITE.argument2_m (READ.32[1].argument2))
        (WRITE.result1_l
          (SUB
            (MUL
              (SX.32 (READ.argument2_l))
              (SX.32 (READ.argument3_l)))
            (MUL
              (SX.32 (READ.argument2_m))
              (SX.32 (READ.argument3_m)))))
        (WRITE.result1_m
          (ADD
             (MUL
               (SX.32 (READ.argument2_l))
               (SX.32 (READ.argument3_m)))
             (MUL
               (SX.32 (READ.argument2_m))
               (SX.32 (READ.argument3_l)))))
        (WRITE.result1
          (IOR
            (SHL (READ.result1_m) (CONST.64))
            (ZX.64 (READ.result1_l)))))
  - ID: MULWDC.C
    what: Multiply Conjugate Word Complex to Double Word Complex
    formats: [ MAU_QDD2 ]
    description: >
      The %3 and the %2 are considered as word complex packed into 64 bits.
      The %3 words and the %2 words conjugate are multiplied, assuming complex signed integers.
      The two resulting double words are paired and stored back into the %1.
    execution: |
      new argument3_l = argument3.32[0];
      new argument3_m = argument3.32[1];
      new argument2_l = argument2.32[0];
      new argument2_m = argument2.32[1];
      new result1_l = (_SX_32(argument2_l) * _SX_32(argument3_l)) + (_SX_32(argument2_m) * _SX_32(argument3_m));
      new result1_m = (_SX_32(argument2_l) * _SX_32(argument3_m)) - (_SX_32(argument2_m) * _SX_32(argument3_l));
      new result1 = (result1_m << 64) | _ZX_64(result1_l);
    behavior: |
      (SEQ
        (WRITE.argument3_l (READ.32[0].argument3))
        (WRITE.argument3_m (READ.32[1].argument3))
        (WRITE.argument2_l (READ.32[0].argument2))
        (WRITE.argument2_m (READ.32[1].argument2))
        (WRITE.result1_l
          (ADD
            (MUL
              (SX.32 (READ.argument2_l))
              (SX.32 (READ.argument3_l)))
            (MUL
              (SX.32 (READ.argument2_m))
              (SX.32 (READ.argument3_m)))))
        (WRITE.result1_m
          (SUB
             (MUL
               (SX.32 (READ.argument2_l))
               (SX.32 (READ.argument3_m)))
             (MUL
               (SX.32 (READ.argument2_m))
               (SX.32 (READ.argument3_l)))))
        (WRITE.result1
          (IOR
            (SHL (READ.result1_m) (CONST.64))
            (ZX.64 (READ.result1_l)))))
  - ID: MULHWQ
    what: Multiply Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming signed integers.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _SX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (SX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULUHWQ
    what: Multiply Unsigned Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words and the %2 half words are multiplied, assuming unsigned integers.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _ZX_16(argument3.16[i]) * _ZX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (ZX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MULSUHWQ
    what: Multiply Signed by Unsigned Half Word to Word Quadruple
    formats: [ MAU_QDD3 ]
    description: >
      The %3 and the %2 are considered as four half words packed into 64 bits.
      The %3 half words assuming unsigned integers and the %2 half words assuming signed integers are multiplied.
      The four resulting words are packed and stored back into the %1.
    execution: |
      for (i range 4) {
        result1.32[i] = _ZX_16(argument3.16[i]) * _SX_16(argument2.16[i]);
      }
    behavior: |
      (FOR.I (RANGE.4)
        (WRITE.32[(INDEX.I)].result1
          (MUL
            (ZX.16 (READ.16[(INDEX.I)].argument3))
            (SX.16 (READ.16[(INDEX.I)].argument2)))))
  - ID: MADDWD
    what: Multiply-Add Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers, and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MADDUWD
    what: Multiply-Add Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers, and the product is added to the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 + _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: MADDSUWD
    what: Multiply-Add Signed by Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The product is added to the 64 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = argument1 + _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (ADD
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MADDW
    what: Multiply-Add Words
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied.
      The multiplication result is added to the value of the %1.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument1 + argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (ADD
            (READ.argument1)
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2)))))
  - ID: MSBFWD
    what: Multiply-Subtract Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers, and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (SX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MSBFUWD
    what: Multiply-Subtract Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers, and the product is subtracted from the 64 bits of the %1.
      The result is stored back into the %1.
    execution: |
      new result1 = argument1 - _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (READ.argument1)
          (MUL
            (ZX.32 (READ.argument3))
            (ZX.32 (READ.argument2)))))
  - ID: MSBFSUWD
    what: Multiply-Subtract Signed by Unsigned Words to Double Word
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The product is subtracted from the 64 bits of the %1 and the result is stored back into the %1.
    execution: |
      new result1 = _ZX_64(argument1) - _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (SUB
          (ZX.64 (READ.argument1))
          (MUL
            (ZX.32 (READ.argument3))
            (SX.32 (READ.argument2)))))
  - ID: MSBFW
    what: Multiply-Subtract Words
    formats: [ MAU_SSSS, MAU_SSSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied.
      The multiplication result is subtracted from the value of the %1.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument1 - argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (SUB
            (READ.argument1)
            (MUL
              (READ.32[0].argument3)
              (READ.32[0].argument2)))))
  - ID: MULWD
    what: Multiply Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming signed integers. The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _SX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (SX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MULUWD
    what: Multiply Unsigned Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 is multiplied by the %2, assuming unsigned integers.
      The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_32(argument3) * _ZX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.32 (READ.argument3))
          (ZX.32 (READ.argument2))))
  - ID: MULSUWD
    what: Multiply Signed by Unsigned Words to Double Word
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 assuming unsigned integer and the %2 assuming signed integer are multiplied.
      The 64 bits of the result are stored into the %1.
    execution: |
      new result1 = _ZX_32(argument3) * _SX_32(argument2);
    behavior: |
      (WRITE.result1
        (MUL
          (ZX.32 (READ.argument3))
          (SX.32 (READ.argument2))))
  - ID: MULW
    what: Multiply Words
    formats: [ MAU_SSS, MAU_SSS.W ]
    description: >
      The %3 least significant word and the %2 least significant word are multiplied, assuming signed integers.
      The resulting word is zero-extended and stored back into the %1.
    execution: |
      new result1 = _ZX_32(argument3.32[0] * argument2.32[0]);
    behavior: |
      (WRITE.result1
        (ZX.32
          (MUL
            (READ.32[0].argument3)
            (READ.32[0].argument2))))
  - ID: MADDWDP
    what: Multiply-Add Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming signed integers, and the product pair is added
      to the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDUWDP
    what: Multiply-Add Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming unsigned integers, and the product pair is added
      to the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MADDSUWDP
    what: Multiply-Add Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integer and the %2 words assuming signed integer are multiplied.
      The product pair is added to the 64-bit pair of the %1 and the resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] + _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (ADD
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MMA212W
    what: Matrix Multiply-Add 2x1x2 Word
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are added to the four words of the %1, and stored back into the %1.
    execution: |
      new argument1_x = argument1.32[0];
      new argument1_y = argument1.32[1];
      new argument1_z = argument1.32[2];
      new argument1_t = argument1.32[3];
      new result1_x = _ZX_32(argument1_x + argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument1_y + argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument1_z + argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument1_t + argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.argument1_x (READ.32[0].argument1))
        (WRITE.argument1_y (READ.32[1].argument1))
        (WRITE.argument1_z (READ.32[2].argument1))
        (WRITE.argument1_t (READ.32[3].argument1))
        (WRITE.result1_x
          (ZX.32
            (ADD
              (READ.argument1_x)
              (MUL
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_y
          (ZX.32
            (ADD
              (READ.argument1_y)
              (MUL
                (READ.32[0].argument2)
                (READ.32[1].argument3)))))
        (WRITE.result1_z
          (ZX.32
            (ADD
              (READ.argument1_z)
              (MUL
                (READ.32[1].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_t
          (ZX.32
            (ADD
              (READ.argument1_t)
              (MUL
                (READ.32[1].argument2)
                (READ.32[1].argument3)))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: MSBFWDP
    what: Multiply-Subtract Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming signed integers, and the product pair is subtracted
      from the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (SX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFUWDP
    what: Multiply-Subtract Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2, assuming unsigned integers, and the product pair is subtracted
      from the 64-bit pair of the %1. The resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (ZX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MSBFSUWDP
    what: Multiply-Subtract Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integer and the %2 words assuming signed integer are multiplied.
      The product pair is subtracted from the 64-bit pair of the %1 and the resulting pair is stored back into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = result1.64[i] - _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (SUB
            (READ.64[(INDEX.I)].argument1)
            (MUL
              (ZX.32 (READ.32[(INDEX.I)].argument3))
              (SX.32 (READ.32[(INDEX.I)].argument2))))))
  - ID: MMS212W
    what: Matrix Multiply-Subtract 2x1x2 Word
    formats: [ MAU_QQDD, MAU_QQDD.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are subtracted from the four words of the %1, and stored back into the %1.
    execution: |
      new argument1_x = argument1.32[0];
      new argument1_y = argument1.32[1];
      new argument1_z = argument1.32[2];
      new argument1_t = argument1.32[3];
      new result1_x = _ZX_32(argument1_x - argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument1_y - argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument1_z - argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument1_t - argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.argument1_x (READ.32[0].argument1))
        (WRITE.argument1_y (READ.32[1].argument1))
        (WRITE.argument1_z (READ.32[2].argument1))
        (WRITE.argument1_t (READ.32[3].argument1))
        (WRITE.result1_x
          (ZX.32
            (SUB
              (READ.argument1_x)
              (MUL
                (READ.32[0].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_y
          (ZX.32
            (SUB
              (READ.argument1_y)
              (MUL
                (READ.32[0].argument2)
                (READ.32[1].argument3)))))
        (WRITE.result1_z
          (ZX.32
            (SUB
              (READ.argument1_z)
              (MUL
                (READ.32[1].argument2)
                (READ.32[0].argument3)))))
        (WRITE.result1_t
          (ZX.32
            (SUB
              (READ.argument1_t)
              (MUL
                (READ.32[1].argument2)
                (READ.32[1].argument3)))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: MULWDP
    what: Multiply Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words , assuming signed integers.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _SX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (SX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULUWDP
    what: Multiply Unsigned Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words are multiplied by the %2 words, assuming unsigned integers.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _ZX_32(argument3.32[i]) * _ZX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (ZX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MULSUWDP
    what: Multiply Signed by Unsigned Words to Double Word Pair
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The %3 words assuming unsigned integers and the %2 words assuming signed integers are multiplied.
      The resulting 64-bit pair is stored into the %1.
    execution: |
      for (i range 2) {
        result1.64[i] = _ZX_32(argument3.32[i]) * _SX_32(argument2.32[i]);
      }
    behavior: |
      (FOR.I (RANGE.2)
        (WRITE.64[(INDEX.I)].result1
          (MUL
            (ZX.32 (READ.32[(INDEX.I)].argument3))
            (SX.32 (READ.32[(INDEX.I)].argument2)))))
  - ID: MM212W
    what: Matrix Multiply 2x1x2 Word Quadruple
    formats: [ MAU_QDD0, MAU_QDD0.M ]
    description: >
      The %3 and the %2 are considered as two words packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed, assuming integers.
      The four resulting words are stored back into the %1.
    execution: |
      new result1_x = _ZX_32(argument2.32[0] * argument3.32[0]);
      new result1_y = _ZX_32(argument2.32[0] * argument3.32[1]);
      new result1_z = _ZX_32(argument2.32[1] * argument3.32[0]);
      new result1_t = _ZX_32(argument2.32[1] * argument3.32[1]);
      result1.64[0] = result1_x | (result1_y << 32);
      result1.64[1] = result1_z | (result1_t << 32);
    behavior: |
      (SEQ
        (WRITE.result1_x
          (ZX.32
            (MUL
              (READ.32[0].argument2)
              (READ.32[0].argument3))))
        (WRITE.result1_y
          (ZX.32
            (MUL
              (READ.32[0].argument2)
              (READ.32[1].argument3))))
        (WRITE.result1_z
          (ZX.32
            (MUL
              (READ.32[1].argument2)
              (READ.32[0].argument3))))
        (WRITE.result1_t
          (ZX.32
            (MUL
              (READ.32[1].argument2)
              (READ.32[1].argument3))))
        (WRITE.64[0].result1
          (IOR
            (READ.result1_x)
            (SHL (READ.result1_y) (CONST.32))))
        (WRITE.64[1].result1
          (IOR
            (READ.result1_z)
            (SHL (READ.result1_t) (CONST.32)))))
  - ID: FFMAD
    what: Floating-Point Fused Multiply-Add Double
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 64 floating-point
      numbers, and the product is added to the %1. The result is rounded
      to the binary 64 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_mulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWP
    what: Floating-Point Fused Multiply-Add Word Pair
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number pairs, and the product pair is added to the %1. The resulting pair is rounded
      to the binary 32 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulAdd_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulAdd_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAHQ
    what: Floating-Point Fused Multiply-Add Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number quadruples, and the product quadruple is added to the %1. The resulting quadruple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulAdd_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulAdd_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSD
    what: Floating-Point Fused Multiply-Subtract Double
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 64 floating-point
      numbers, and the product is subtracted from the %1. The result is
      rounded to the binary 64 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_mulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWP
    what: Floating-Point Fused Multiply-Subtract Word Pair
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      number pairs, and the product pair is subtracted from the %1. The resulting pair is
      rounded to the binary 32 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulSub_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulSub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHQ
    what: Floating-Point Fused Multiply-Subtract Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      number quadruples, and the product quadruple is subtracted from the %1. The resulting quadruple is rounded
      to the binary 16 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f16_mulSub_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mulSub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FMULD
    what: Floating-Point Multiply Double Word
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 64 floating-point
      numbers. The result is rounded to the binary 64 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_mul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_mul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWP
    what: Floating-Point Multiply Word Pair
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number pairs. The resulting pair is rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULHQ
    what: Floating-Point Multiply Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point
      number quadruples. The results are rounded to the binary 16 floating-point
      format according to the rounding mode set in the CS register, packed and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f16_mul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_mul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWDP
    what: Floating-Point Multiply Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQDI, MAU_FQDI.X, MAU_FQDI.Y, MAU_FQDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number pairs. The resulting pair is rounded to the binary 64 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_widenMul_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMul_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULHWQ
    what: Floating-Point Multiply Half Word to Word Quadruple
    class: FPU
    formats: [ MAU_FQDI, MAU_FQDI.X, MAU_FQDI.Y, MAU_FQDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point
      number quadruples. The results are rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register, packed and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_widenMul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
## - ID: FMULDP
## what: Floating-Point Multiply Double Word Pair
## class: FPU
## formats: [ MAU_FQQQ0 ]
## description: >
## The %2 is multiplied by the %3, assuming binary 64 floating-point
## number pairs. The resulting pair is rounded to the binary 64 floating-point
## format according to the rounding mode set in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
## execution: |
## new result1 = f64_mul_x2(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.f64_mul_x2
## (READ.RM)
## (READ.argument2)
## (READ.argument3)
## (READ.argument3)
## )
## )
  - ID: FMULWQ
    what: Floating-Point Multiply Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point
      number quadruples. The resulting quadruple is rounded to the binary 32 floating-point
      format according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWC
    what: Floating-Point Multiply Word Complex
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      These numbers are multiplied according to the rounding mode set in the CS register.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmulc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmulc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FMULWDC
    what: Floating-Point Multiply Word to Double Complex
    class: FPU
    formats: [ MAU_FQDI, MAU_FQDI.X, MAU_FQDI.Y, MAU_FQDD ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      These numbers are multiplied according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmulc_32_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmulc_32_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FMULWC.C
    what: Floating-Point Multiply Word Complex Conjugate
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is multiplied by the %3, according to the rounding mode.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmulcc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmulcc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FMULWDC.C
    what: Floating-Point Multiply Conjugate Word to Double Complex
    class: FPU
    formats: [ MAU_FQDI, MAU_FQDI.X, MAU_FQDI.Y, MAU_FQDD ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is multiplied by the %3, according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fmulcc_32_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmulcc_32_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FADDD
    what: Floating-Point Add Double Word
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 64 floating-point numbers.
      The result is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_add(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_add
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWP
    what: Floating-Point Add Word Pair
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point number pairs.
      The resulting pair is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_add_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDHQ
    what: Floating-Point Add Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is added to the %3, assuming binary 16 floating-point number quadruples.
      The results are rounded to the binary 16 floating-point format
      according to the rounding mode set in the CS register, packed and stored
      into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f16_add_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f16_add_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDDP
    what: Floating-Point Add Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %2 is added to the %3, assuming binary 64 floating-point number pairs.
      The resulting pair is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_add_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_add_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWQ
    what: Floating-Point Add Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point number quadruples.
      The resulting quadruple is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f32_add_x4(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add_x4
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FADDWC.C
    what: Floating-Point Add Word Complex Conjugate
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is added to the %3, according to the rounding mode set in the CS register.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.faddcc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FADDDC.C
    what: Floating-Point Add Double Word Complex Conjugate
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %3 and the %2 are considered as binary 64 floating-point complex numbers.
      The conjugate of the %2 is added to the %3, according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_64_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.faddcc_64_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FADDWCP.C
    what: Floating-Point Add Word Complex Pair Conjugate
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The conjugate of the %2 pair is added to the %3 pair, according to the rounding mode set in the CS register.
      The resulting pair of binary 32 floating-point complex numbers is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = faddcc_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.faddcc_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFD
    what: Floating-Point Subtract From Double Word
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 64
      floating-point numbers. The result is rounded to the binary 64
      floating-point format according to the rounding mode set in the CS
      register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f64_sub(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_sub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWP
    what: Floating-Point Subtract From Word Pair
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32
      floating-point number pairs. The resulting pair is rounded to the binary 32
      floating-point format according to the rounding mode stored in the
      CS register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub_x2(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFHQ
    what: Floating-Point Subtract From Half Word Quadruple
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 16 floating-point number quadruples.
      The results are rounded to the binary 16 floating-point format
      according to the rounding mode set in the CS register, packed and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f16_sub_x4(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f16_sub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFDP
    what: Floating-Point Subtract Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 64 floating-point number pairs.
      The resulting pair is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored
      into the %1. This instruction may raise inexact, invalid, overflow
      exception bits in the CS register.
    execution: |
      new result1 = f64_sub_x2(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f64_sub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWQ
    what: Floating-Point Subtract From Word Quadruple
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32
      floating-point number quadruples. The resulting quadruple is rounded to the binary 32
      floating-point format according to the rounding mode stored in the
      CS register and stored into the %1. This instruction may raise
      inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub_x4(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FSBFWC.C
    what: Floating-Point Subtract From Word Complex Conjugate
    class: FPU
    formats: [ MAU_FDDI1, MAU_FDDI1.X, MAU_FDDI1.Y, MAU_FDDD1 ]
    description: >
      The %3 and the %2 are considered as binary 32 floating-point complex numbers.
      The conjugate of the %2 is subtracted from the %3, according to the rounding mode set in the CS register.
      The resulting binary 32 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fsbfcc_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFDC.C
    what: Floating-Point Subtract From Double Word Complex Conjugate
    class: FPU
    formats: [ MAU_FQQQ0 ]
    description: >
      The %3 and the %2 are considered as binary 64 floating-point complex numbers.
      The conjugate of the %2 is subtracted from the %3, according to the rounding mode set in the CS register.
      The resulting binary 64 floating-point complex number is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_64_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fsbfcc_64_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FSBFWCP.C
    what: Floating-Point Subtract From Word Complex Pair Conjugate
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as pairs of binary 32 floating-point complex numbers.
      The conjugate of the %2 pair is subtracted from the %3 pair, according to the rounding mode set in the CS register.
      The resulting pair of binary 32 floating-point complex numbers is stored back into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = fsbfcc_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.fsbfcc_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FFMAHW
    what: Floating-Point Fused Multiply-Add Half Words to Word
    class: FPU
    formats: [ MAU_FSSSI, MAU_FSSSI.X, MAU_FSSSI.Y, MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      numbers, and the product is added to the %1, assuming binary 32
      floating-point format. The result is rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAW
    what: Floating-Point Fused Multiply-Add Words
    class: FPU
    formats: [ MAU_FSSSI, MAU_FSSSI.X, MAU_FSSSI.Y, MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is added to the %1. The result is rounded
      to the binary 32 floating-point format according to the rounding
      mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWD
    what: Floating-Point Fused Multiply-Add Words to Double Word
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is added to the %1, assuming binary 64
      floating-point format. The result is rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulAdd(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulAdd
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAWDP
    what: Floating-Point Fused Multiply-Add Words to Double Word Pair
    class: FPU
    formats: [ MAU_FQQDI, MAU_FQQDI.X, MAU_FQQDI.Y, MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming pairs of binary 32 floating-point
      numbers, and the pair of products is added to the %1, assuming a pair of binary 64
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulAdd_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulAdd_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMAHWQ
    what: Floating-Point Fused Multiply-Add Half Words to Word Quadruple
    class: FPU
    formats: [ MAU_FQQDI, MAU_FQQDI.X, MAU_FQQDI.Y, MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming quadruples of binary 16 floating-point
      numbers, and the quadruples of products is added to the %1, assuming a quadruple of binary 32
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulAdd_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulAdd_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHW
    what: Floating-Point Fused Multiply-Subtract Half Words to Word
    class: FPU
    formats: [ MAU_FSSSI, MAU_FSSSI.X, MAU_FSSSI.Y, MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 16 floating-point
      numbers, and the product is subtracted from the %1, assuming
      binary 32 floating-point format. The result is rounded according
      to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSW
    what: Floating-Point Fused Multiply-Subtract Words
    class: FPU
    formats: [ MAU_FSSSI, MAU_FSSSI.X, MAU_FSSSI.Y, MAU_FSSSS ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is subtracted from the %1. The result is
      rounded to the binary 32 floating-point format according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_mulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWD
    what: Floating-Point Fused Multiply-Subtract Words to Double Word
    class: FPU
    formats: [ MAU_FDDDI, MAU_FDDDI.X, MAU_FDDDI.Y, MAU_FDDDD ]
    description: >
      The %3 is multiplied by the %2, assuming binary 32 floating-point
      numbers, and the product is subtracted from the %1, assuming
      binary 64 floating-point format. The result is rounded according
      to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 - (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulSub(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulSub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSWDP
    what: Floating-Point Fused Multiply-Subtract Words to Double Word Pair
    class: FPU
    formats: [ MAU_FQQDI, MAU_FQQDI.X, MAU_FQQDI.Y, MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming pairs of binary 32 floating-point
      numbers, and the pair of products is subtracted from the %1, assuming a pair of binary 64
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f64_widenMulSub_x2(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMulSub_x2
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
  - ID: FFMSHWQ
    what: Floating-Point Fused Multiply-Subtract Half Words to Word Quadruple
    class: FPU
    formats: [ MAU_FQQDI, MAU_FQQDI.X, MAU_FQQDI.Y, MAU_FQQDD ]
    description: >
      The %3 is multiplied by the %2, assuming quadruples of binary 16 floating-point
      numbers, and the quadruples of products is subtracted from the %1, assuming a quadruple of binary 32
      floating-point format. The results are rounded according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
      $$
      %1 = %1 + (%3 \cdot %2)
      $$
    execution: |
      new result1 = f32_widenMulSub_x4(RM, argument3, argument2, argument1);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMulSub_x4
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
          (READ.argument1)
        )
      )
## - ID: FADDH
## what: Floating-Point Add Half Words
## class: FPU
## formats: [ MAU_FSSS, MAU_FSSS.X ]
## description: >
## The %2 is added to the %3, assuming binary 16 floating-point numbers.
## The result is rounded to the binary 16 floating-point format
## according to the rounding mode set in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow exception bits in the CS register.
## execution: |
## new result1 = f16_add(RM, argument2, argument3);
## behavior: |
## (WRITE.result1
## (APPLY.f16_add
## (READ.RM)
## (READ.argument2)
## (READ.argument3)
## )
## )
  - ID: FADDW
    what: Floating-Point Add Words
    class: FPU
    formats: [ MAU_FSSI, MAU_FSSI.X, MAU_FSSI.Y, MAU_FSSS ]
    description: >
      The %2 is added to the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_add(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_add
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
## - ID: FSBFH
## what: Floating-Point Subtract From Half Words
## class: FPU
## formats: [ MAU_FSSS, MAU_FSSS.X ]
## description: >
## The %2 is subtracted from the %3, assuming binary 16 floating-point numbers.
## The result is rounded to the binary 16 floating-point format
## according to the rounding mode stored in the CS register and stored into the %1.
## This instruction may raise inexact, invalid, overflow exception bits in the CS register.
## execution: |
## new result1 = f16_sub(RM, argument3, argument2);
## behavior: |
## (WRITE.result1
## (APPLY.f16_sub
## (READ.RM)
## (READ.argument3)
## (READ.argument2)
## )
## )
  - ID: FSBFW
    what: Floating-Point Subtract From Words
    class: FPU
    formats: [ MAU_FSSI, MAU_FSSI.X, MAU_FSSI.Y, MAU_FSSS ]
    description: >
      The %2 is subtracted from the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode stored in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow exception bits in the CS register.
    execution: |
      new result1 = f32_sub(RM, argument3, argument2);
    behavior: |
      (WRITE.result1
        (APPLY.f32_sub
          (READ.RM)
          (READ.argument3)
          (READ.argument2)
        )
      )
  - ID: FMULHW
    what: Floating-Point Multiply Half Words to Word
    class: FPU
    formats: [ MAU_FSSI, MAU_FSSI.X, MAU_FSSI.Y, MAU_FSSS ]
    description: >
      The %2 is multiplied by the %3, assuming binary 16 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_widenMul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_widenMul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULW
    what: Floating-Point Multiply Words
    class: FPU
    formats: [ MAU_FSSI, MAU_FSSI.X, MAU_FSSI.Y, MAU_FSSS ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 32 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f32_mul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f32_mul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FMULWD
    what: Floating-Point Multiply Words to Double Word
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %2 is multiplied by the %3, assuming binary 32 floating-point numbers.
      The result is rounded to the binary 64 floating-point format
      according to the rounding mode set in the CS register and stored into the %1.
      This instruction may raise inexact, invalid, overflow or underflow exception bits in the CS register.
    execution: |
      new result1 = f64_widenMul(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.f64_widenMul
          (READ.RM)
          (READ.argument2)
          (READ.argument3)
        )
      )
  - ID: FDOT2W
    what: Floating-Point Dot Product x2 Word
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 32 floating-point number is stored back into the %1.
    execution: |
      new result1 = fdot2_32_32(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_32
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WD
    what: Floating-Point Dot Product x2 Word to Double Word
    class: FPU
    formats: [ MAU_FDDI, MAU_FDDI.X, MAU_FDDI.Y, MAU_FDDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 64 floating-point number is stored back into the %1.
    execution: |
      new result1 = fdot2_32_64(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_64
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WZP
    what: Floating-Point Dot Product x2 Word Zero Extended Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The dot product between the %2 words and the %3 words is computed. The result represented as
      binary 32 floating-point number is zero-extended to 64 bits and stored back into the %1.
    execution: |
      new result1 = fdot2_32_32_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.128.fdot2_32_32_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FDOT2WDP
    what: Floating-Point Dot Product x2 Word to Double Word Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    description: >
      The %3 and the %2 are considered each of four words packed into 128 bits.
      The dot-product of the %3 upper word pair and the %2 upper word pair is computed, assuming binary 32 floating-point numbers.
      The dot-product of the %3 lower word pair and the %2 lower word pair is computed, assuming binary 32 floating-point numbers.
      The resulting pair of binary 64 floating-point numbers is packed and stored back into the %1.
    execution: |
      new result1 = fdot2_32_64_x2(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fdot2_32_64_x2
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: FMMA212W
    what: Floating-Point Matrix Multiply 2x1x2 Add Word Quadruple
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed. The four results
      are added to the four words of the %1 assuming binary 32 floating-point numbers, and stored back into the %1.
      Assuming operand %2 is the 2-element column vector $(a_0, a_1)$ and operand %3 is the 2-element row vector $(b_0, b_1)$,
      the matrix multiplication result is a four-element vector $(c_{0,0}, c_{0,1}, c_{1,0}, c_{1,1})$ which is
      then added to the four-element vector $(d_{0,0}, d_{0,1}, d_{1,0}, d_{1,1})$ held in operand %1.
      (Figure~\ref{fig:FMMA212W-layout}).
      \begin{figure}
      \centering
        \includegraphics[width=100mm]{gemm_2x2_asm}
        \caption{FMMA212W operand layout.}
        \label{fig:FMMA212W-layout}
      \end{figure}
    execution: |
      new result1 = fmm2awq(RM, argument1, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (APPLY.fmm2awq
            (READ.RM)
            (READ.argument1)
            (READ.argument2)
            (READ.argument3))))
  - ID: FMMS212W
    what: Floating-Point Matrix Multiply 2x1x2 Subtract Word Quadruple
    class: FPU
    formats: [ MAU_FQQDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed. The four results
      are subtracted from the four words of the %1 assuming binary 32 floating-point numbers, and stored back into the %1.
      See description of FMMA212W (\S~\ref{instr:FMMA212W}) for matrix element layout in operands.
    execution: |
      new result1 = fmm2swq(RM, argument1, argument2, argument3);
    behavior: |
      (SEQ
        (WRITE.result1
          (APPLY.fmm2swq
            (READ.RM)
            (READ.argument1)
            (READ.argument2)
            (READ.argument3))))
  - ID: FMM212W
    what: Floating-Point Matrix Multiply 2x1x2 Word Quadruple
    class: FPU
    formats: [ MAU_FQDD ]
    description: >
      The %3 and the %2 are considered as two binary 32 floating-point numbers packed into 64 bits.
      The matrix multiplication between the %2 words and the %3 words is computed. The four results
      are stored back into the %1.
      See description of FMMA212W (\S~\ref{instr:FMMA212W}) for matrix element layout in operands.
    execution: |
      new result1 = fmm2wq(RM, argument2, argument3);
    behavior: |
      (WRITE.result1
        (APPLY.fmm2wq
          (READ.RM)
          (READ.argument2)
          (READ.argument3)))
  - ID: COPYQ
    what: Copy Quadruple Word
    formats: [ MAU_COPYQ ]
    description: >
      The %1 operand receives the concatenation of the %2 and %3 values.
    execution: |
      new result1 = _ZX_64(argument2) | (argument3 << 64);
    behavior: |
      (WRITE.result1
        (IOR
          (ZX.64 (READ.argument2))
          (SHL (READ.argument3) (CONST.64))))
  - ID: COPYO
    what: Copy Octuple Word
    formats: [ LSU_COPYO ]
    description: >
      The %1 operand receives the %2 value.
    execution: |
      new result1 = argument2;
    behavior: |
      (WRITE.result1
        (READ.argument2))
  - ID: MOVETQ
    what: Move To Coprocessor Quadruple Word
    formats: [ ALU_MTWQE, ALU_MTWQO ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the %2 value.
    execution: |
      new result1 = _ZX_64(argument2) | (argument3 << 64);
    behavior: |
      (WRITE.result1
        (IOR
          (ZX.64 (READ.argument2))
            (SHL (READ.argument3) (CONST.64))))
  - ID: ALIGNO
    what: Align Coprocessor Registers into Octuple Word
    formats: [ BCU_AOEOI, BCU_AOOEI, BCU_AOEOR, BCU_AOOER ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the concatenation of the %2 and the %3 values shifted right by the byte count in %4.
    execution: |
      new shift = (argument4 & 63) * 8;
      new result1 = argument2;
      if (shift >= 256) {
        result1 = _ZX_256(argument3) >> (shift - 256);
      } else if (shift) {
        result1 = (_ZX_256(argument2) >> shift) | _ZX_256(argument3 << (256 - shift));
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (MUL
            (AND
              (READ.argument4)
              (CONST.63))
            (CONST.8)))
        (WRITE.result1
          (READ.argument2))
        (IF
          (GE
            (READ.shift)
            (CONST.256))
          (WRITE.result1
            (SHR
              (ZX.256 (READ.argument3))
              (SUB
                (READ.shift)
                (CONST.256))))
          (IF
            (I2B (READ.shift))
            (WRITE.result1
              (IOR
                (SHR
                  (ZX.256 (READ.argument2))
                  (READ.shift))
                (ZX.256
                  (SHL
                    (READ.argument3)
                    (SUB
                      (CONST.256)
                      (READ.shift))))))
            (SKIP))))
  - ID: ALIGNV
    what: Align Coprocessor Registers
    formats: [ BCU_AVEOI, BCU_AVOEI, BCU_AVEOR, BCU_AVOER ]
    properties: { '%0': Extension }
    description: >
      The %1 operand receives the concatenation of the %2 and the %3 values shifted right by the byte count in %4.
    execution: |
      new shift = (argument4 & 63) * 8;
      new result1 = argument2;
      if (shift >= 256) {
        result1 = _ZX_256(argument3) >> (shift - 256);
      } else if (shift) {
        result1 = (_ZX_256(argument2) >> shift) | _ZX_256(argument3 << (256 - shift));
      }
    behavior: |
      (SEQ
        (WRITE.shift
          (MUL
            (AND
              (READ.argument4)
              (CONST.63))
            (CONST.8)))
        (WRITE.result1
          (READ.argument2))
        (IF
          (GE
            (READ.shift)
            (CONST.256))
          (WRITE.result1
            (SHR
              (ZX.256 (READ.argument3))
              (SUB
                (READ.shift)
                (CONST.256))))
          (IF
            (I2B (READ.shift))
            (WRITE.result1
              (IOR
                (SHR
                  (ZX.256 (READ.argument2))
                  (READ.shift))
                (ZX.256
                  (SHL
                    (READ.argument3)
                    (SUB
                      (CONST.256)
                      (READ.shift))))))
            (SKIP))))
  - ID: XMT44D
    what: Extension Matrix Transpose 4x4 Double Words
    class: EXT
    formats: [ EXT_MTD ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the transpose of the %2 interpreted as a 4x4 matrix of double words.
    execution: |
      new result1_0 = transpose_64_4x4_0(argument2_0, argument2_1, argument2_2, argument2_3);
      new result1_1 = transpose_64_4x4_1(argument2_0, argument2_1, argument2_2, argument2_3);
      new result1_2 = transpose_64_4x4_2(argument2_0, argument2_1, argument2_2, argument2_3);
      new result1_3 = transpose_64_4x4_3(argument2_0, argument2_1, argument2_2, argument2_3);
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.256.transpose_64_4x4_0
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.result1_1
          (APPLY.256.transpose_64_4x4_1
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.result1_2
          (APPLY.256.transpose_64_4x4_2
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3)))
        (WRITE.result1_3
          (APPLY.256.transpose_64_4x4_3
            (READ.argument2_0)
            (READ.argument2_1)
            (READ.argument2_2)
            (READ.argument2_3))))
  - ID: XMMA484BW
    what: Extension Matrix Multiply-Add 4x8x4 Bytes to Words
    class: EXT
    formats: [ EXT_MMABW0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %2 interpreted as a 4x4 matrix of words to the product
      of the %3 interpreted as a 4x8 matrix of signed bytes by the transposed %4 interpreted as a 4x8 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot8_8_32(argument3_0, argument4_0);
      new result1_0_1 = dot8_8_32(argument3_0, argument4_1);
      new result1_0_2 = dot8_8_32(argument3_0, argument4_2);
      new result1_0_3 = dot8_8_32(argument3_0, argument4_3);
      new result1_1_0 = dot8_8_32(argument3_1, argument4_0);
      new result1_1_1 = dot8_8_32(argument3_1, argument4_1);
      new result1_1_2 = dot8_8_32(argument3_1, argument4_2);
      new result1_1_3 = dot8_8_32(argument3_1, argument4_3);
      new result1_2_0 = dot8_8_32(argument3_2, argument4_0);
      new result1_2_1 = dot8_8_32(argument3_2, argument4_1);
      new result1_2_2 = dot8_8_32(argument3_2, argument4_2);
      new result1_2_3 = dot8_8_32(argument3_2, argument4_3);
      new result1_3_0 = dot8_8_32(argument3_3, argument4_0);
      new result1_3_1 = dot8_8_32(argument3_3, argument4_1);
      new result1_3_2 = dot8_8_32(argument3_3, argument4_2);
      new result1_3_3 = dot8_8_32(argument3_3, argument4_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument2_0, result1_0);
      result1_1 = add_32_32_x8(argument2_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8_8_32
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8_8_32
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8_8_32
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8_8_32
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8_8_32
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8_8_32
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8_8_32
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8_8_32
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8_8_32
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8_8_32
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8_8_32
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8_8_32
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8_8_32
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8_8_32
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8_8_32
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8_8_32
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument2_1)
            (READ.result1_1))))
  - ID: XMMA484UBW
    what: Extension Matrix Multiply-Add 4x8x4 Unsigned by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMABW1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %2 interpreted as a 4x4 matrix of words to the product
      of the %3 interpreted as a 4x8 matrix of unsigned bytes by the transposed %4 interpreted as a 4x8 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot8u_8_32(argument3_0, argument4_0);
      new result1_0_1 = dot8u_8_32(argument3_0, argument4_1);
      new result1_0_2 = dot8u_8_32(argument3_0, argument4_2);
      new result1_0_3 = dot8u_8_32(argument3_0, argument4_3);
      new result1_1_0 = dot8u_8_32(argument3_1, argument4_0);
      new result1_1_1 = dot8u_8_32(argument3_1, argument4_1);
      new result1_1_2 = dot8u_8_32(argument3_1, argument4_2);
      new result1_1_3 = dot8u_8_32(argument3_1, argument4_3);
      new result1_2_0 = dot8u_8_32(argument3_2, argument4_0);
      new result1_2_1 = dot8u_8_32(argument3_2, argument4_1);
      new result1_2_2 = dot8u_8_32(argument3_2, argument4_2);
      new result1_2_3 = dot8u_8_32(argument3_2, argument4_3);
      new result1_3_0 = dot8u_8_32(argument3_3, argument4_0);
      new result1_3_1 = dot8u_8_32(argument3_3, argument4_1);
      new result1_3_2 = dot8u_8_32(argument3_3, argument4_2);
      new result1_3_3 = dot8u_8_32(argument3_3, argument4_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument2_0, result1_0);
      result1_1 = add_32_32_x8(argument2_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8u_8_32
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8u_8_32
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8u_8_32
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8u_8_32
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8u_8_32
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8u_8_32
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8u_8_32
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8u_8_32
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8u_8_32
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8u_8_32
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8u_8_32
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8u_8_32
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8u_8_32
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8u_8_32
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8u_8_32
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8u_8_32
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument2_1)
            (READ.result1_1))))
  - ID: XMMA484SUBW
    what: Extension Matrix Multiply-Add 4x8x4 Signed by Unsigned Bytes to Words
    class: EXT
    formats: [ EXT_MMABW2 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %2 interpreted as a 4x4 matrix of words to the product
      of the %3 interpreted as a 4x8 matrix of signed bytes by the transposed %4 interpreted as a 4x8 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot8su_8_32(argument3_0, argument4_0);
      new result1_0_1 = dot8su_8_32(argument3_0, argument4_1);
      new result1_0_2 = dot8su_8_32(argument3_0, argument4_2);
      new result1_0_3 = dot8su_8_32(argument3_0, argument4_3);
      new result1_1_0 = dot8su_8_32(argument3_1, argument4_0);
      new result1_1_1 = dot8su_8_32(argument3_1, argument4_1);
      new result1_1_2 = dot8su_8_32(argument3_1, argument4_2);
      new result1_1_3 = dot8su_8_32(argument3_1, argument4_3);
      new result1_2_0 = dot8su_8_32(argument3_2, argument4_0);
      new result1_2_1 = dot8su_8_32(argument3_2, argument4_1);
      new result1_2_2 = dot8su_8_32(argument3_2, argument4_2);
      new result1_2_3 = dot8su_8_32(argument3_2, argument4_3);
      new result1_3_0 = dot8su_8_32(argument3_3, argument4_0);
      new result1_3_1 = dot8su_8_32(argument3_3, argument4_1);
      new result1_3_2 = dot8su_8_32(argument3_3, argument4_2);
      new result1_3_3 = dot8su_8_32(argument3_3, argument4_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument2_0, result1_0);
      result1_1 = add_32_32_x8(argument2_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8su_8_32
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8su_8_32
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8su_8_32
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8su_8_32
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8su_8_32
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8su_8_32
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8su_8_32
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8su_8_32
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8su_8_32
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8su_8_32
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8su_8_32
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8su_8_32
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8su_8_32
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8su_8_32
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8su_8_32
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8su_8_32
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument2_1)
            (READ.result1_1))))
  - ID: XMMA484USBW
    what: Extension Matrix Multiply-Add 4x8x4 Unsigned by Signed Bytes to Words
    class: EXT
    formats: [ EXT_MMABW3 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of words receives the sum of the %2 interpreted as a 4x4 matrix of words to the product
      of the %3 interpreted as a 4x8 matrix of unsigned bytes by the transposed %4 interpreted as a 4x8 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot8us_8_32(argument3_0, argument4_0);
      new result1_0_1 = dot8us_8_32(argument3_0, argument4_1);
      new result1_0_2 = dot8us_8_32(argument3_0, argument4_2);
      new result1_0_3 = dot8us_8_32(argument3_0, argument4_3);
      new result1_1_0 = dot8us_8_32(argument3_1, argument4_0);
      new result1_1_1 = dot8us_8_32(argument3_1, argument4_1);
      new result1_1_2 = dot8us_8_32(argument3_1, argument4_2);
      new result1_1_3 = dot8us_8_32(argument3_1, argument4_3);
      new result1_2_0 = dot8us_8_32(argument3_2, argument4_0);
      new result1_2_1 = dot8us_8_32(argument3_2, argument4_1);
      new result1_2_2 = dot8us_8_32(argument3_2, argument4_2);
      new result1_2_3 = dot8us_8_32(argument3_2, argument4_3);
      new result1_3_0 = dot8us_8_32(argument3_3, argument4_0);
      new result1_3_1 = dot8us_8_32(argument3_3, argument4_1);
      new result1_3_2 = dot8us_8_32(argument3_3, argument4_2);
      new result1_3_3 = dot8us_8_32(argument3_3, argument4_3);
      new result1_0 = join_32_x8(result1_0_0, result1_0_1, result1_1_0, result1_1_1, result1_2_0, result1_2_1, result1_3_0, result1_3_1);
      new result1_1 = join_32_x8(result1_0_2, result1_0_3, result1_1_2, result1_1_3, result1_2_2, result1_2_3, result1_3_2, result1_3_3);
      result1_0 = add_32_32_x8(argument2_0, result1_0);
      result1_1 = add_32_32_x8(argument2_1, result1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.dot8us_8_32
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.32.dot8us_8_32
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.32.dot8us_8_32
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.32.dot8us_8_32
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.32.dot8us_8_32
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.32.dot8us_8_32
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.32.dot8us_8_32
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.32.dot8us_8_32
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.32.dot8us_8_32
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.32.dot8us_8_32
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.32.dot8us_8_32
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.32.dot8us_8_32
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.32.dot8us_8_32
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.32.dot8us_8_32
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.32.dot8us_8_32
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.32.dot8us_8_32
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1)
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1)))
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3)
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_32_32_x8
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_32_32_x8
            (READ.argument2_1)
            (READ.result1_1))))
  - ID: MMA444HBD0
    what: Matrix Multiply-Add 4x4x4 Half Words by Bytes to Double Words 0
    class: EXT
    formats: [ EXT_MMAHBD0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot4_16_64(argument3_0, sxb_x4(argument4_0));
      new result1_0_1 = dot4_16_64(argument3_0, sxb_x4(argument4_1));
      new result1_0_2 = dot4_16_64(argument3_0, sxb_x4(argument4_2));
      new result1_0_3 = dot4_16_64(argument3_0, sxb_x4(argument4_3));
      new result1_1_0 = dot4_16_64(argument3_1, sxb_x4(argument4_0));
      new result1_1_1 = dot4_16_64(argument3_1, sxb_x4(argument4_1));
      new result1_1_2 = dot4_16_64(argument3_1, sxb_x4(argument4_2));
      new result1_1_3 = dot4_16_64(argument3_1, sxb_x4(argument4_3));
      new result1_2_0 = dot4_16_64(argument3_2, sxb_x4(argument4_0));
      new result1_2_1 = dot4_16_64(argument3_2, sxb_x4(argument4_1));
      new result1_2_2 = dot4_16_64(argument3_2, sxb_x4(argument4_2));
      new result1_2_3 = dot4_16_64(argument3_2, sxb_x4(argument4_3));
      new result1_3_0 = dot4_16_64(argument3_3, sxb_x4(argument4_0));
      new result1_3_1 = dot4_16_64(argument3_3, sxb_x4(argument4_1));
      new result1_3_2 = dot4_16_64(argument3_3, sxb_x4(argument4_2));
      new result1_3_3 = dot4_16_64(argument3_3, sxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444UHBD0
    what: Matrix Multiply-Add 4x4x4 Unsigned Half Words by Unsigned Bytes to Double Words 0
    class: EXT
    formats: [ EXT_MMAHBD0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of unsigned half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4u_16_64(argument3_0, zxb_x4(argument4_0));
      new result1_0_1 = dot4u_16_64(argument3_0, zxb_x4(argument4_1));
      new result1_0_2 = dot4u_16_64(argument3_0, zxb_x4(argument4_2));
      new result1_0_3 = dot4u_16_64(argument3_0, zxb_x4(argument4_3));
      new result1_1_0 = dot4u_16_64(argument3_1, zxb_x4(argument4_0));
      new result1_1_1 = dot4u_16_64(argument3_1, zxb_x4(argument4_1));
      new result1_1_2 = dot4u_16_64(argument3_1, zxb_x4(argument4_2));
      new result1_1_3 = dot4u_16_64(argument3_1, zxb_x4(argument4_3));
      new result1_2_0 = dot4u_16_64(argument3_2, zxb_x4(argument4_0));
      new result1_2_1 = dot4u_16_64(argument3_2, zxb_x4(argument4_1));
      new result1_2_2 = dot4u_16_64(argument3_2, zxb_x4(argument4_2));
      new result1_2_3 = dot4u_16_64(argument3_2, zxb_x4(argument4_3));
      new result1_3_0 = dot4u_16_64(argument3_3, zxb_x4(argument4_0));
      new result1_3_1 = dot4u_16_64(argument3_3, zxb_x4(argument4_1));
      new result1_3_2 = dot4u_16_64(argument3_3, zxb_x4(argument4_2));
      new result1_3_3 = dot4u_16_64(argument3_3, zxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444SUHBD0
    what: Matrix Multiply-Add 4x4x4 Signed Half Words by Unsigned Bytes to Double Words 0
    class: EXT
    formats: [ EXT_MMAHBD0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4su_16_64(argument3_0, zxb_x4(argument4_0));
      new result1_0_1 = dot4su_16_64(argument3_0, zxb_x4(argument4_1));
      new result1_0_2 = dot4su_16_64(argument3_0, zxb_x4(argument4_2));
      new result1_0_3 = dot4su_16_64(argument3_0, zxb_x4(argument4_3));
      new result1_1_0 = dot4su_16_64(argument3_1, zxb_x4(argument4_0));
      new result1_1_1 = dot4su_16_64(argument3_1, zxb_x4(argument4_1));
      new result1_1_2 = dot4su_16_64(argument3_1, zxb_x4(argument4_2));
      new result1_1_3 = dot4su_16_64(argument3_1, zxb_x4(argument4_3));
      new result1_2_0 = dot4su_16_64(argument3_2, zxb_x4(argument4_0));
      new result1_2_1 = dot4su_16_64(argument3_2, zxb_x4(argument4_1));
      new result1_2_2 = dot4su_16_64(argument3_2, zxb_x4(argument4_2));
      new result1_2_3 = dot4su_16_64(argument3_2, zxb_x4(argument4_3));
      new result1_3_0 = dot4su_16_64(argument3_3, zxb_x4(argument4_0));
      new result1_3_1 = dot4su_16_64(argument3_3, zxb_x4(argument4_1));
      new result1_3_2 = dot4su_16_64(argument3_3, zxb_x4(argument4_2));
      new result1_3_3 = dot4su_16_64(argument3_3, zxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444USHBD0
    what: Matrix Multiply-Add 4x4x4 Unsigned Half Words by Signed Bytes to Double Words 0
    class: EXT
    formats: [ EXT_MMAHBD0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4us_16_64(argument3_0, sxb_x4(argument4_0));
      new result1_0_1 = dot4us_16_64(argument3_0, sxb_x4(argument4_1));
      new result1_0_2 = dot4us_16_64(argument3_0, sxb_x4(argument4_2));
      new result1_0_3 = dot4us_16_64(argument3_0, sxb_x4(argument4_3));
      new result1_1_0 = dot4us_16_64(argument3_1, sxb_x4(argument4_0));
      new result1_1_1 = dot4us_16_64(argument3_1, sxb_x4(argument4_1));
      new result1_1_2 = dot4us_16_64(argument3_1, sxb_x4(argument4_2));
      new result1_1_3 = dot4us_16_64(argument3_1, sxb_x4(argument4_3));
      new result1_2_0 = dot4us_16_64(argument3_2, sxb_x4(argument4_0));
      new result1_2_1 = dot4us_16_64(argument3_2, sxb_x4(argument4_1));
      new result1_2_2 = dot4us_16_64(argument3_2, sxb_x4(argument4_2));
      new result1_2_3 = dot4us_16_64(argument3_2, sxb_x4(argument4_3));
      new result1_3_0 = dot4us_16_64(argument3_3, sxb_x4(argument4_0));
      new result1_3_1 = dot4us_16_64(argument3_3, sxb_x4(argument4_1));
      new result1_3_2 = dot4us_16_64(argument3_3, sxb_x4(argument4_2));
      new result1_3_3 = dot4us_16_64(argument3_3, sxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444HBD1
    what: Matrix Multiply-Add 4x4x4 Half Words by Bytes to Double Words 1
    class: EXT
    formats: [ EXT_MMAHBD1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of signed bytes.
    execution: |
      new result1_0_0 = dot4_16_64(argument3_0, sxb_x4(argument4_0));
      new result1_0_1 = dot4_16_64(argument3_0, sxb_x4(argument4_1));
      new result1_0_2 = dot4_16_64(argument3_0, sxb_x4(argument4_2));
      new result1_0_3 = dot4_16_64(argument3_0, sxb_x4(argument4_3));
      new result1_1_0 = dot4_16_64(argument3_1, sxb_x4(argument4_0));
      new result1_1_1 = dot4_16_64(argument3_1, sxb_x4(argument4_1));
      new result1_1_2 = dot4_16_64(argument3_1, sxb_x4(argument4_2));
      new result1_1_3 = dot4_16_64(argument3_1, sxb_x4(argument4_3));
      new result1_2_0 = dot4_16_64(argument3_2, sxb_x4(argument4_0));
      new result1_2_1 = dot4_16_64(argument3_2, sxb_x4(argument4_1));
      new result1_2_2 = dot4_16_64(argument3_2, sxb_x4(argument4_2));
      new result1_2_3 = dot4_16_64(argument3_2, sxb_x4(argument4_3));
      new result1_3_0 = dot4_16_64(argument3_3, sxb_x4(argument4_0));
      new result1_3_1 = dot4_16_64(argument3_3, sxb_x4(argument4_1));
      new result1_3_2 = dot4_16_64(argument3_3, sxb_x4(argument4_2));
      new result1_3_3 = dot4_16_64(argument3_3, sxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444UHBD1
    what: Matrix Multiply-Add 4x4x4 Unsigned Half Words by Unsigned Bytes to Double Words 1
    class: EXT
    formats: [ EXT_MMAHBD1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of unsigned half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4u_16_64(argument3_0, zxb_x4(argument4_0));
      new result1_0_1 = dot4u_16_64(argument3_0, zxb_x4(argument4_1));
      new result1_0_2 = dot4u_16_64(argument3_0, zxb_x4(argument4_2));
      new result1_0_3 = dot4u_16_64(argument3_0, zxb_x4(argument4_3));
      new result1_1_0 = dot4u_16_64(argument3_1, zxb_x4(argument4_0));
      new result1_1_1 = dot4u_16_64(argument3_1, zxb_x4(argument4_1));
      new result1_1_2 = dot4u_16_64(argument3_1, zxb_x4(argument4_2));
      new result1_1_3 = dot4u_16_64(argument3_1, zxb_x4(argument4_3));
      new result1_2_0 = dot4u_16_64(argument3_2, zxb_x4(argument4_0));
      new result1_2_1 = dot4u_16_64(argument3_2, zxb_x4(argument4_1));
      new result1_2_2 = dot4u_16_64(argument3_2, zxb_x4(argument4_2));
      new result1_2_3 = dot4u_16_64(argument3_2, zxb_x4(argument4_3));
      new result1_3_0 = dot4u_16_64(argument3_3, zxb_x4(argument4_0));
      new result1_3_1 = dot4u_16_64(argument3_3, zxb_x4(argument4_1));
      new result1_3_2 = dot4u_16_64(argument3_3, zxb_x4(argument4_2));
      new result1_3_3 = dot4u_16_64(argument3_3, zxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444SUHBD1
    what: Matrix Multiply-Add 4x4x4 Signed Half Words by Unsigned Bytes to Double Words 1
    class: EXT
    formats: [ EXT_MMAHBD1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4su_16_64(argument3_0, zxb_x4(argument4_0));
      new result1_0_1 = dot4su_16_64(argument3_0, zxb_x4(argument4_1));
      new result1_0_2 = dot4su_16_64(argument3_0, zxb_x4(argument4_2));
      new result1_0_3 = dot4su_16_64(argument3_0, zxb_x4(argument4_3));
      new result1_1_0 = dot4su_16_64(argument3_1, zxb_x4(argument4_0));
      new result1_1_1 = dot4su_16_64(argument3_1, zxb_x4(argument4_1));
      new result1_1_2 = dot4su_16_64(argument3_1, zxb_x4(argument4_2));
      new result1_1_3 = dot4su_16_64(argument3_1, zxb_x4(argument4_3));
      new result1_2_0 = dot4su_16_64(argument3_2, zxb_x4(argument4_0));
      new result1_2_1 = dot4su_16_64(argument3_2, zxb_x4(argument4_1));
      new result1_2_2 = dot4su_16_64(argument3_2, zxb_x4(argument4_2));
      new result1_2_3 = dot4su_16_64(argument3_2, zxb_x4(argument4_3));
      new result1_3_0 = dot4su_16_64(argument3_3, zxb_x4(argument4_0));
      new result1_3_1 = dot4su_16_64(argument3_3, zxb_x4(argument4_1));
      new result1_3_2 = dot4su_16_64(argument3_3, zxb_x4(argument4_2));
      new result1_3_3 = dot4su_16_64(argument3_3, zxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (APPLY.64.zxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444USHBD1
    what: Matrix Multiply-Add 4x4x4 Unsigned Half Words by Signed Bytes to Double Words 1
    class: EXT
    formats: [ EXT_MMAHBD1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned bytes.
    execution: |
      new result1_0_0 = dot4us_16_64(argument3_0, sxb_x4(argument4_0));
      new result1_0_1 = dot4us_16_64(argument3_0, sxb_x4(argument4_1));
      new result1_0_2 = dot4us_16_64(argument3_0, sxb_x4(argument4_2));
      new result1_0_3 = dot4us_16_64(argument3_0, sxb_x4(argument4_3));
      new result1_1_0 = dot4us_16_64(argument3_1, sxb_x4(argument4_0));
      new result1_1_1 = dot4us_16_64(argument3_1, sxb_x4(argument4_1));
      new result1_1_2 = dot4us_16_64(argument3_1, sxb_x4(argument4_2));
      new result1_1_3 = dot4us_16_64(argument3_1, sxb_x4(argument4_3));
      new result1_2_0 = dot4us_16_64(argument3_2, sxb_x4(argument4_0));
      new result1_2_1 = dot4us_16_64(argument3_2, sxb_x4(argument4_1));
      new result1_2_2 = dot4us_16_64(argument3_2, sxb_x4(argument4_2));
      new result1_2_3 = dot4us_16_64(argument3_2, sxb_x4(argument4_3));
      new result1_3_0 = dot4us_16_64(argument3_3, sxb_x4(argument4_0));
      new result1_3_1 = dot4us_16_64(argument3_3, sxb_x4(argument4_1));
      new result1_3_2 = dot4us_16_64(argument3_3, sxb_x4(argument4_2));
      new result1_3_3 = dot4us_16_64(argument3_3, sxb_x4(argument4_3));
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_0_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_0_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_0_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_1_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_1_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_1_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_1_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_2_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_2_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_2_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_2_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_3_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_0))))
        (WRITE.result1_3_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_1))))
        (WRITE.result1_3_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_2))))
        (WRITE.result1_3_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (APPLY.64.sxb_x4
              (READ.argument4_3))))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444HD
    what: Matrix Multiply-Add 4x4x4 Half Words to Double Words
    class: EXT
    formats: [ EXT_MMAHD ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of signed half words.
    execution: |
      new result1_0_0 = dot4_16_64(argument3_0, argument4_0);
      new result1_0_1 = dot4_16_64(argument3_0, argument4_1);
      new result1_0_2 = dot4_16_64(argument3_0, argument4_2);
      new result1_0_3 = dot4_16_64(argument3_0, argument4_3);
      new result1_1_0 = dot4_16_64(argument3_1, argument4_0);
      new result1_1_1 = dot4_16_64(argument3_1, argument4_1);
      new result1_1_2 = dot4_16_64(argument3_1, argument4_2);
      new result1_1_3 = dot4_16_64(argument3_1, argument4_3);
      new result1_2_0 = dot4_16_64(argument3_2, argument4_0);
      new result1_2_1 = dot4_16_64(argument3_2, argument4_1);
      new result1_2_2 = dot4_16_64(argument3_2, argument4_2);
      new result1_2_3 = dot4_16_64(argument3_2, argument4_3);
      new result1_3_0 = dot4_16_64(argument3_3, argument4_0);
      new result1_3_1 = dot4_16_64(argument3_3, argument4_1);
      new result1_3_2 = dot4_16_64(argument3_3, argument4_2);
      new result1_3_3 = dot4_16_64(argument3_3, argument4_3);
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.64.dot4_16_64
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.64.dot4_16_64
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.64.dot4_16_64
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.64.dot4_16_64
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444UHD
    what: Matrix Multiply-Add 4x4x4 Unsigned by Unsigned Half Words to Double Words
    class: EXT
    formats: [ EXT_MMAHD ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of unsigned half words by the transposed %4 interpreted as a 4x4 matrix of unsigned half words.
    execution: |
      new result1_0_0 = dot4u_16_64(argument3_0, argument4_0);
      new result1_0_1 = dot4u_16_64(argument3_0, argument4_1);
      new result1_0_2 = dot4u_16_64(argument3_0, argument4_2);
      new result1_0_3 = dot4u_16_64(argument3_0, argument4_3);
      new result1_1_0 = dot4u_16_64(argument3_1, argument4_0);
      new result1_1_1 = dot4u_16_64(argument3_1, argument4_1);
      new result1_1_2 = dot4u_16_64(argument3_1, argument4_2);
      new result1_1_3 = dot4u_16_64(argument3_1, argument4_3);
      new result1_2_0 = dot4u_16_64(argument3_2, argument4_0);
      new result1_2_1 = dot4u_16_64(argument3_2, argument4_1);
      new result1_2_2 = dot4u_16_64(argument3_2, argument4_2);
      new result1_2_3 = dot4u_16_64(argument3_2, argument4_3);
      new result1_3_0 = dot4u_16_64(argument3_3, argument4_0);
      new result1_3_1 = dot4u_16_64(argument3_3, argument4_1);
      new result1_3_2 = dot4u_16_64(argument3_3, argument4_2);
      new result1_3_3 = dot4u_16_64(argument3_3, argument4_3);
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.64.dot4u_16_64
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444SUHD
    what: Matrix Multiply-Add 4x4x4 Signed by Unsigned Half Words to Double Words
    class: EXT
    formats: [ EXT_MMAHD ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned half words.
    execution: |
      new result1_0_0 = dot4su_16_64(argument3_0, argument4_0);
      new result1_0_1 = dot4su_16_64(argument3_0, argument4_1);
      new result1_0_2 = dot4su_16_64(argument3_0, argument4_2);
      new result1_0_3 = dot4su_16_64(argument3_0, argument4_3);
      new result1_1_0 = dot4su_16_64(argument3_1, argument4_0);
      new result1_1_1 = dot4su_16_64(argument3_1, argument4_1);
      new result1_1_2 = dot4su_16_64(argument3_1, argument4_2);
      new result1_1_3 = dot4su_16_64(argument3_1, argument4_3);
      new result1_2_0 = dot4su_16_64(argument3_2, argument4_0);
      new result1_2_1 = dot4su_16_64(argument3_2, argument4_1);
      new result1_2_2 = dot4su_16_64(argument3_2, argument4_2);
      new result1_2_3 = dot4su_16_64(argument3_2, argument4_3);
      new result1_3_0 = dot4su_16_64(argument3_3, argument4_0);
      new result1_3_1 = dot4su_16_64(argument3_3, argument4_1);
      new result1_3_2 = dot4su_16_64(argument3_3, argument4_2);
      new result1_3_3 = dot4su_16_64(argument3_3, argument4_3);
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.64.dot4su_16_64
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: MMA444USHD
    what: Matrix Multiply-Add 4x4x4 Unsigned by Signed Half Words to Double Words
    class: EXT
    formats: [ EXT_MMAHD ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 4x4 matrix of double words receives the sum of the %2 interpreted as a 4x4 matrix of double words to the product
      of the %3 interpreted as a 4x4 matrix of signed half words by the transposed %4 interpreted as a 4x4 matrix of unsigned half words.
    execution: |
      new result1_0_0 = dot4us_16_64(argument3_0, argument4_0);
      new result1_0_1 = dot4us_16_64(argument3_0, argument4_1);
      new result1_0_2 = dot4us_16_64(argument3_0, argument4_2);
      new result1_0_3 = dot4us_16_64(argument3_0, argument4_3);
      new result1_1_0 = dot4us_16_64(argument3_1, argument4_0);
      new result1_1_1 = dot4us_16_64(argument3_1, argument4_1);
      new result1_1_2 = dot4us_16_64(argument3_1, argument4_2);
      new result1_1_3 = dot4us_16_64(argument3_1, argument4_3);
      new result1_2_0 = dot4us_16_64(argument3_2, argument4_0);
      new result1_2_1 = dot4us_16_64(argument3_2, argument4_1);
      new result1_2_2 = dot4us_16_64(argument3_2, argument4_2);
      new result1_2_3 = dot4us_16_64(argument3_2, argument4_3);
      new result1_3_0 = dot4us_16_64(argument3_3, argument4_0);
      new result1_3_1 = dot4us_16_64(argument3_3, argument4_1);
      new result1_3_2 = dot4us_16_64(argument3_3, argument4_2);
      new result1_3_3 = dot4us_16_64(argument3_3, argument4_3);
      new result1_0 = join_64_x4(result1_0_0, result1_1_0, result1_2_0, result1_3_0);
      new result1_1 = join_64_x4(result1_0_1, result1_1_1, result1_2_1, result1_3_1);
      new result1_2 = join_64_x4(result1_0_2, result1_1_2, result1_2_2, result1_3_2);
      new result1_3 = join_64_x4(result1_0_3, result1_1_3, result1_2_3, result1_3_3);
      result1_0 = add_64_64_x4(argument2_0, result1_0);
      result1_1 = add_64_64_x4(argument2_1, result1_1);
      result1_2 = add_64_64_x4(argument2_2, result1_2);
      result1_3 = add_64_64_x4(argument2_3, result1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (READ.argument4_0)))
        (WRITE.result1_0_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (READ.argument4_1)))
        (WRITE.result1_0_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (READ.argument4_2)))
        (WRITE.result1_0_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_0)
            (READ.argument4_3)))
        (WRITE.result1_1_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (READ.argument4_0)))
        (WRITE.result1_1_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (READ.argument4_1)))
        (WRITE.result1_1_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (READ.argument4_2)))
        (WRITE.result1_1_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_1)
            (READ.argument4_3)))
        (WRITE.result1_2_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (READ.argument4_0)))
        (WRITE.result1_2_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (READ.argument4_1)))
        (WRITE.result1_2_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (READ.argument4_2)))
        (WRITE.result1_2_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_2)
            (READ.argument4_3)))
        (WRITE.result1_3_0
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (READ.argument4_0)))
        (WRITE.result1_3_1
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (READ.argument4_1)))
        (WRITE.result1_3_2
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (READ.argument4_2)))
        (WRITE.result1_3_3
          (APPLY.64.dot4us_16_64
            (READ.argument3_3)
            (READ.argument4_3)))
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.result1_0_0) (READ.result1_1_0)
            (READ.result1_2_0) (READ.result1_3_0)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.result1_0_1) (READ.result1_1_1)
            (READ.result1_2_1) (READ.result1_3_1)))
        (WRITE.result1_2
          (APPLY.256.join_64_x4
            (READ.result1_0_2) (READ.result1_1_2)
            (READ.result1_2_2) (READ.result1_3_2)))
        (WRITE.result1_3
          (APPLY.256.join_64_x4
            (READ.result1_0_3) (READ.result1_1_3)
            (READ.result1_2_3) (READ.result1_3_3)))
        (WRITE.result1_0
          (APPLY.add_64_64_x4
            (READ.argument2_0)
            (READ.result1_0)))
        (WRITE.result1_1
          (APPLY.add_64_64_x4
            (READ.argument2_1)
            (READ.result1_1)))
        (WRITE.result1_2
          (APPLY.add_64_64_x4
            (READ.argument2_2)
            (READ.result1_2)))
        (WRITE.result1_3
          (APPLY.add_64_64_x4
            (READ.argument2_3)
            (READ.result1_3))))
  - ID: FMMA242HW0
    what: Floating-Point Matrix Multiply-Add 2x4x2 Half Words to Words 0
    class: EXT
    formats: [ EXT_FMMAHW0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 2x2 matrix of words receives the sum of the %2 interpreted as a 2x2 matrix of words to the product
      of the %3 interpreted as a 2x4 matrix of half words by the transposed %4 interpreted as a 2x4 matrix of half words.
      This instruction computes the quadrant 0 of the 4x4 result.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1_0_0 = fdot4add_16_32_reset(XRM, argument3_0, argument4_0, argument2_0_0);
      new result1_0_1 = fdot4add_16_32_noreset(XRM, argument3_0, argument4_1, argument2_0_1);
      new result1_1_0 = fdot4add_16_32_noreset(XRM, argument3_1, argument4_0, argument2_1_0);
      new result1_1_1 = fdot4add_16_32_noreset(XRM, argument3_1, argument4_1, argument2_1_1);
      new result1 = join_32_x4(result1_0_0, result1_0_1, result1_1_0, result1_1_1);
    behavior: |
      (SEQ
        (WRITE.result1_0_0
          (APPLY.32.fdot4add_16_32_reset
            (READ.XRM)
            (READ.argument3_0)
            (READ.argument4_0)
            (READ.argument2_0_0)))
        (WRITE.result1_0_1
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_0)
            (READ.argument4_1)
            (READ.argument2_0_1)))
        (WRITE.result1_1_0
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_1)
            (READ.argument4_0)
            (READ.argument2_1_0)))
        (WRITE.result1_1_1
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_1)
            (READ.argument4_1)
            (READ.argument2_1_1)))
        (WRITE.result1
          (APPLY.128.join_32_x4
            (READ.result1_0_0) (READ.result1_0_1)
            (READ.result1_1_0) (READ.result1_1_1))))
  - ID: FMMA242HW1
    what: Floating-Point Matrix Multiply-Add 2x4x2 Half Words to Words 1
    class: EXT
    formats: [ EXT_FMMAHW1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 2x2 matrix of words receives the sum of the %2 interpreted as a 2x2 matrix of words to the product
      of the %3 interpreted as a 2x4 matrix of half words by the transposed %4 interpreted as a 2x4 matrix of half words.
      This instruction computes the quadrant 1 of the 4x4 result.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1_2_0 = fdot4add_16_32_reset(XRM, argument3_2, argument4_0, argument2_2_0);
      new result1_2_1 = fdot4add_16_32_noreset(XRM, argument3_2, argument4_1, argument2_2_1);
      new result1_3_0 = fdot4add_16_32_noreset(XRM, argument3_3, argument4_0, argument2_3_0);
      new result1_3_1 = fdot4add_16_32_noreset(XRM, argument3_3, argument4_1, argument2_3_1);
      new result1 = join_32_x4(result1_2_0, result1_2_1, result1_3_0, result1_3_1);
    behavior: |
      (SEQ
        (WRITE.result1_2_0
          (APPLY.32.fdot4add_16_32_reset
            (READ.XRM)
            (READ.argument3_2)
            (READ.argument4_0)
            (READ.argument2_2_0)))
        (WRITE.result1_2_1
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_2)
            (READ.argument4_1)
            (READ.argument2_2_1)))
        (WRITE.result1_3_0
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_3)
            (READ.argument4_0)
            (READ.argument2_3_0)))
        (WRITE.result1_3_1
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_3)
            (READ.argument4_1)
            (READ.argument2_3_1)))
        (WRITE.result1
          (APPLY.128.join_32_x4
            (READ.result1_2_0) (READ.result1_2_1)
            (READ.result1_3_0) (READ.result1_3_1))))
  - ID: FMMA242HW2
    what: Floating-Point Matrix Multiply-Add 2x4x2 Half Words to Words 2
    class: EXT
    formats: [ EXT_FMMAHW2 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 2x2 matrix of words receives the sum of the %2 interpreted as a 2x2 matrix of words to the product
      of the %3 interpreted as a 2x4 matrix of half words by the transposed %4 interpreted as a 2x4 matrix of half words.
      This instruction computes the quadrant 2 of the 4x4 result.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1_0_2 = fdot4add_16_32_reset(XRM, argument3_0, argument4_2, argument2_0_2);
      new result1_0_3 = fdot4add_16_32_noreset(XRM, argument3_0, argument4_3, argument2_0_3);
      new result1_1_2 = fdot4add_16_32_noreset(XRM, argument3_1, argument4_2, argument2_1_2);
      new result1_1_3 = fdot4add_16_32_noreset(XRM, argument3_1, argument4_3, argument2_1_3);
      new result1 = join_32_x4(result1_0_2, result1_0_3, result1_1_2, result1_1_3);
    behavior: |
      (SEQ
        (WRITE.result1_0_2
          (APPLY.32.fdot4add_16_32_reset
            (READ.XRM)
            (READ.argument3_0)
            (READ.argument4_2)
            (READ.argument2_0_2)))
        (WRITE.result1_0_3
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_0)
            (READ.argument4_3)
            (READ.argument2_0_3)))
        (WRITE.result1_1_2
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_1)
            (READ.argument4_2)
            (READ.argument2_1_2)))
        (WRITE.result1_1_3
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_1)
            (READ.argument4_3)
            (READ.argument2_1_3)))
        (WRITE.result1
          (APPLY.128.join_32_x4
            (READ.result1_0_2) (READ.result1_0_3)
            (READ.result1_1_2) (READ.result1_1_3))))
  - ID: FMMA242HW3
    what: Floating-Point Matrix Multiply-Add 2x4x2 Half Words to Words 3
    class: EXT
    formats: [ EXT_FMMAHW3 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as a 2x2 matrix of words receives the sum of the %2 interpreted as a 2x2 matrix of words to the product
      of the %3 interpreted as a 2x4 matrix of half words by the transposed %4 interpreted as a 2x4 matrix of half words.
      This instruction computes the quadrant 3 of the 4x4 result.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1_2_2 = fdot4add_16_32_reset(XRM, argument3_2, argument4_2, argument2_2_2);
      new result1_2_3 = fdot4add_16_32_noreset(XRM, argument3_2, argument4_3, argument2_2_3);
      new result1_3_2 = fdot4add_16_32_noreset(XRM, argument3_3, argument4_2, argument2_3_2);
      new result1_3_3 = fdot4add_16_32_noreset(XRM, argument3_3, argument4_3, argument2_3_3);
      new result1 = join_32_x4(result1_2_2, result1_2_3, result1_3_2, result1_3_3);
    behavior: |
      (SEQ
        (WRITE.result1_2_2
          (APPLY.32.fdot4add_16_32_reset
            (READ.XRM)
            (READ.argument3_2)
            (READ.argument4_2)
            (READ.argument2_2_2)))
        (WRITE.result1_2_3
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_2)
            (READ.argument4_3)
            (READ.argument2_2_3)))
        (WRITE.result1_3_2
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_3)
            (READ.argument4_2)
            (READ.argument2_3_2)))
        (WRITE.result1_3_3
          (APPLY.32.fdot4add_16_32_noreset
            (READ.XRM)
            (READ.argument3_3)
            (READ.argument4_3)
            (READ.argument2_3_3)))
        (WRITE.result1
          (APPLY.128.join_32_x4
            (READ.result1_2_2) (READ.result1_2_3)
            (READ.result1_3_2) (READ.result1_3_3))))
  - ID: CONVDHV0
    what: Convert Double Word to Half Word Vector 0
    class: EXT
    formats: [ EXT_CDHVL ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 half words receives the result of converting half 0 of the %2
      considered as a 4x4 matrix of double words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_0 = join_64_x4(argument2_0_0, argument2_0_1, argument2_0_2, argument2_0_3);
      new result1_1 = join_64_x4(argument2_1_0, argument2_1_1, argument2_1_2, argument2_1_3);
      if (dropbits) {
        result1_0 = round_64_x4(roundint, dropbits, result1_0);
        result1_1 = round_64_x4(roundint, dropbits, result1_1);
      }
      if (saturate) {
        result1_0 = satu_64_16_x4(result1_0);
        result1_1 = satu_64_16_x4(result1_1);
      } else {
        result1_0 = sat_64_16_x4(result1_0);
        result1_1 = sat_64_16_x4(result1_1);
      }
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.argument2_0_0)
            (READ.argument2_0_1)
            (READ.argument2_0_2)
            (READ.argument2_0_3)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.argument2_1_0)
            (READ.argument2_1_1)
            (READ.argument2_1_2)
            (READ.argument2_1_3)))
        (IF
          (I2B (READ.dropbits))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.round_64_x4
                (READ.roundint)
                (READ.dropbits)
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.256.round_64_x4
                (READ.roundint)
                (READ.dropbits)
                (READ.result1_1))))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (SEQ
            (WRITE.result1_0
              (APPLY.64.satu_64_16_x4
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.64.satu_64_16_x4
                (READ.result1_1))))
          (SEQ
            (WRITE.result1_0
              (APPLY.64.sat_64_16_x4
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.64.sat_64_16_x4
                (READ.result1_1))))))
  - ID: CONVDHV1
    what: Convert Double Word to Half Word Vector 1
    class: EXT
    formats: [ EXT_CDHVH ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 half words receives the result of converting half 1 of the %2
      considered as a 4x4 matrix of double words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_0 = join_64_x4(argument2_2_0, argument2_2_1, argument2_2_2, argument2_2_3);
      new result1_1 = join_64_x4(argument2_3_0, argument2_3_1, argument2_3_2, argument2_3_3);
      if (dropbits) {
        result1_0 = round_64_x4(roundint, dropbits, result1_0);
        result1_1 = round_64_x4(roundint, dropbits, result1_1);
      }
      if (saturate) {
        result1_0 = satu_64_16_x4(result1_0);
        result1_1 = satu_64_16_x4(result1_1);
      } else {
        result1_0 = sat_64_16_x4(result1_0);
        result1_1 = sat_64_16_x4(result1_1);
      }
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.256.join_64_x4
            (READ.argument2_2_0)
            (READ.argument2_2_1)
            (READ.argument2_2_2)
            (READ.argument2_2_3)))
        (WRITE.result1_1
          (APPLY.256.join_64_x4
            (READ.argument2_3_0)
            (READ.argument2_3_1)
            (READ.argument2_3_2)
            (READ.argument2_3_3)))
        (IF
          (I2B (READ.dropbits))
          (SEQ
            (WRITE.result1_0
              (APPLY.256.round_64_x4
                (READ.roundint)
                (READ.dropbits)
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.256.round_64_x4
                (READ.roundint)
                (READ.dropbits)
                (READ.result1_1))))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (SEQ
            (WRITE.result1_0
              (APPLY.64.satu_64_16_x4
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.64.satu_64_16_x4
                (READ.result1_1))))
          (SEQ
            (WRITE.result1_0
              (APPLY.64.sat_64_16_x4
                (READ.result1_0)))
            (WRITE.result1_1
              (APPLY.64.sat_64_16_x4
                (READ.result1_1))))))
  - ID: CONVWBV0
    what: Convert Word to Byte Vector 0
    class: EXT
    formats: [ EXT_CWBV0 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 bytes receives the result of converting quarter 0 of the %2
      considered as a 4x8 matrix of words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_0 = join_32_x8(argument2_0_0, argument2_0_1, argument2_0_2, argument2_0_3, argument2_0_4, argument2_0_5, argument2_0_6, argument2_0_7);
      if (dropbits) {
        result1_0 = round_32_x8(roundint, dropbits, result1_0);
      }
      if (saturate) {
        result1_0 = satu_32_8_x8(result1_0);
      } else {
        result1_0 = sat_32_8_x8(result1_0);
      }
    behavior: |
      (SEQ
        (WRITE.result1_0
          (APPLY.256.join_32_x8
            (READ.argument2_0_0)
            (READ.argument2_0_1)
            (READ.argument2_0_2)
            (READ.argument2_0_3)
            (READ.argument2_0_4)
            (READ.argument2_0_5)
            (READ.argument2_0_6)
            (READ.argument2_0_7)))
        (IF
          (I2B (READ.dropbits))
          (WRITE.result1_0
            (APPLY.256.round_32_x8
              (READ.roundint)
              (READ.dropbits)
              (READ.result1_0)))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (WRITE.result1_0
            (APPLY.satu_32_8_x8
              (READ.result1_0)))
          (WRITE.result1_0
            (APPLY.sat_32_8_x8
              (READ.result1_0)))))
  - ID: CONVWBV1
    what: Convert Word to Byte Vector 1
    class: EXT
    formats: [ EXT_CWBV1 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 bytes receives the result of converting quarter 1 of the %2
      considered as a 4x8 matrix of words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_1 = join_32_x8(argument2_1_0, argument2_1_1, argument2_1_2, argument2_1_3, argument2_1_4, argument2_1_5, argument2_1_6, argument2_1_7);
      if (dropbits) {
        result1_1 = round_32_x8(roundint, dropbits, result1_1);
      }
      if (saturate) {
        result1_1 = satu_32_8_x8(result1_1);
      } else {
        result1_1 = sat_32_8_x8(result1_1);
      }
    behavior: |
      (SEQ
        (WRITE.result1_1
          (APPLY.256.join_32_x8
            (READ.argument2_1_0)
            (READ.argument2_1_1)
            (READ.argument2_1_2)
            (READ.argument2_1_3)
            (READ.argument2_1_4)
            (READ.argument2_1_5)
            (READ.argument2_1_6)
            (READ.argument2_1_7)))
        (IF
          (I2B (READ.dropbits))
          (WRITE.result1_1
            (APPLY.256.round_32_x8
              (READ.roundint)
              (READ.dropbits)
              (READ.result1_1)))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (WRITE.result1_1
            (APPLY.satu_32_8_x8
              (READ.result1_1)))
          (WRITE.result1_1
            (APPLY.sat_32_8_x8
              (READ.result1_1)))))
  - ID: CONVWBV2
    what: Convert Word to Byte Vector 2
    class: EXT
    formats: [ EXT_CWBV2 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 bytes receives the result of converting quarter 2 of the %2
      considered as a 4x8 matrix of words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_2 = join_32_x8(argument2_2_0, argument2_2_1, argument2_2_2, argument2_2_3, argument2_2_4, argument2_2_5, argument2_2_6, argument2_2_7);
      if (dropbits) {
        result1_2 = round_32_x8(roundint, dropbits, result1_2);
      }
      if (saturate) {
        result1_2 = satu_32_8_x8(result1_2);
      } else {
        result1_2 = sat_32_8_x8(result1_2);
      }
    behavior: |
      (SEQ
        (WRITE.result1_2
          (APPLY.256.join_32_x8
            (READ.argument2_2_0)
            (READ.argument2_2_1)
            (READ.argument2_2_2)
            (READ.argument2_2_3)
            (READ.argument2_2_4)
            (READ.argument2_2_5)
            (READ.argument2_2_6)
            (READ.argument2_2_7)))
        (IF
          (I2B (READ.dropbits))
          (WRITE.result1_2
            (APPLY.256.round_32_x8
              (READ.roundint)
              (READ.dropbits)
              (READ.result1_2)))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (WRITE.result1_2
            (APPLY.satu_32_8_x8
              (READ.result1_2)))
          (WRITE.result1_2
            (APPLY.sat_32_8_x8
              (READ.result1_2)))))
  - ID: CONVWBV3
    what: Convert Word to Byte Vector 3
    class: EXT
    formats: [ EXT_CWBV3 ]
    properties: { '%0': Extension }
    description: >
      The %1 interpreted as 8 bytes receives the result of converting quarter 3 of the %2
      considered as a 4x8 matrix of words. The conversion applies right-shifting by \textbf{CS.XMF} bits,
      rounding as specified by the %3, and applying signed or unsigned saturation depending on the %4.
    execution: |
      new result1_3 = join_32_x8(argument2_3_0, argument2_3_1, argument2_3_2, argument2_3_3, argument2_3_4, argument2_3_5, argument2_3_6, argument2_3_7);
      if (dropbits) {
        result1_3 = round_32_x8(roundint, dropbits, result1_3);
      }
      if (saturate) {
        result1_3 = satu_32_8_x8(result1_3);
      } else {
        result1_3 = sat_32_8_x8(result1_3);
      }
    behavior: |
      (SEQ
        (WRITE.result1_3
          (APPLY.256.join_32_x8
            (READ.argument2_3_0)
            (READ.argument2_3_1)
            (READ.argument2_3_2)
            (READ.argument2_3_3)
            (READ.argument2_3_4)
            (READ.argument2_3_5)
            (READ.argument2_3_6)
            (READ.argument2_3_7)))
        (IF
          (I2B (READ.dropbits))
          (WRITE.result1_3
            (APPLY.256.round_32_x8
              (READ.roundint)
              (READ.dropbits)
              (READ.result1_3)))
          (SKIP))
        (IF
          (I2B (READ.saturate))
          (WRITE.result1_3
            (APPLY.satu_32_8_x8
              (READ.result1_3)))
          (WRITE.result1_3
            (APPLY.sat_32_8_x8
              (READ.result1_3)))))
  - ID: FSCALEWV
    what: Floating Point Scale Word Vector
    class: EXT
    formats: [ EXT_FSWV ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a vector of 8 binary 32 floating-point numbers,
      which are scaled by the power of 2 given in CS.xpow2 bitfield. Optionally, a maximum with 0
      corresponding to a ReLU activation is the applied to the result.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new result1 = fpow2scale_32_32_x8(XRM, pow2scale, argument2);
      if (rectify) {
        result1 = frelu_32_32_x8_noreset(result1);
      }
    behavior: |
      (SEQ
        (WRITE.result1
          (APPLY.256.fpow2scale_32_32_x8
            (READ.XRM)
            (READ.pow2scale)
            (READ.argument2)))
        (IF
          (I2B (READ.rectify))
          (WRITE.result1
            (APPLY.frelu_32_32_x8_noreset
               (READ.result1)))
          (SKIP)))
  - ID: FNARROW44WH
    what: Floating Point Narrow Word to Half Word Vector
    class: EXT
    formats: [ EXT_FNWHV ]
    properties: { '%0': Extension }
    description: >
      The %2 is interpreted as a vector of 16 binary 32 floating-point numbers,
      which are converted to binary 16 floating-point numbers according to the
      rounding mode set in the CS register and stored into the %1.
      This instruction may raise extension inexact, invalid, overflow or underflow
      exception bits in the CS register.
    execution: |
      new argument_0 = join_32_x8(argument2_0_0, argument2_0_1, argument2_0_2, argument2_0_3, argument2_1_0, argument2_1_1, argument2_1_2, argument2_1_3);
      new argument_1 = join_32_x8(argument2_2_0, argument2_2_1, argument2_2_2, argument2_2_3, argument2_3_0, argument2_3_1, argument2_3_2, argument2_3_3);
      new result1_0 = f32_to_f16_x8(XRM, argument_0);
      new result1_1 = f32_to_f16_x8_noreset(XRM, argument_1);
    behavior: |
      (SEQ
        (WRITE.argument_0
          (APPLY.256.join_32_x8
            (READ.argument2_0_0)
            (READ.argument2_0_1)
            (READ.argument2_0_2)
            (READ.argument2_0_3)
            (READ.argument2_1_0)
            (READ.argument2_1_1)
            (READ.argument2_1_2)
            (READ.argument2_1_3)
          )
        )
        (WRITE.argument_1
          (APPLY.256.join_32_x8
            (READ.argument2_2_0)
            (READ.argument2_2_1)
            (READ.argument2_2_2)
            (READ.argument2_2_3)
            (READ.argument2_3_0)
            (READ.argument2_3_1)
            (READ.argument2_3_2)
            (READ.argument2_3_3)
          )
        )
        (WRITE.result1_0
          (APPLY.128.f32_to_f16_x8
            (READ.XRM)
            (READ.argument_0)
          )
        )
        (WRITE.result1_1
          (APPLY.128.f32_to_f16_x8_noreset
            (READ.XRM)
            (READ.argument_1)
          )
        )
      )
Modifier:
  - ID: exunum
    what: Execution Unit Number in Immediate Extensions
    members: [ ALU0, ALU1, MAU, LSU ]
    execution: "_ZX_2(%0)"
    cases:
      - ALU 0
      - ALU 1
      - MAU
      - LSU
  - ID: scalarcond
    what: Scalar Condition
    members: [ .DNEZ, .DEQZ, .DLTZ, .DGEZ, .DLEZ, .DGTZ, .ODD, .EVEN, .WNEZ, .WEQZ, .WLTZ, .WGEZ, .WLEZ, .WGTZ ]
    cases:
      - Double Not Equal to Zero
      - Double Equal to Zero
      - Double Less Than Zero
      - Double Greater Than or Equal to Zero
      - Double Less Than or Equal to Zero
      - Double Greater Than Zero
      - Odd (LSB Set)
      - Even (LSB Clear)
      - Word Not Equal to Zero
      - Word Equal to Zero
      - Word Less Than Zero
      - Word Greater Than or Equal to Zero
      - Word Less Than or Equal to Zero
      - Word Greater Than Zero
    execution: "_ZX_4(%0)"
  - ID: simdcond
    what: SIMD Condition
    members: [ .NEZ, .EQZ, .LTZ, .GEZ, .LEZ, .GTZ, .ODD, .EVEN ]
    cases:
      - Not Equal to Zero
      - Equal to Zero
      - Less Than Zero
      - Greater Than or Equal to Zero
      - Less Than or Equal to Zero
      - Greater Than Zero
      - Odd (LSB Set)
      - Even (LSB Clear)
    execution: "_ZX_3(%0)"
  - ID: comparison
    what: Integer and Bit Comparison
    members: [ .NE, .EQ, .LT, .GE, .LE, .GT, .LTU, .GEU, .LEU, .GTU, .ALL, .NALL, .ANY, .NONE ]
    cases:
      - Not Equal
      - Equal
      - Less Than
      - Greater Than or Equal
      - Less Than or Equal
      - Greater Than
      - Less Than Unsigned
      - Greater Than or Equal Unsigned
      - Less Than or Equal Unsigned
      - Greater Than Unsigned
      - All Bits Set in Mask
      - Not All Bits Set in Mask
      - Any Bits Set in Mask
      - Not Any Bits Set in Mask
    execution: "_ZX_4(%0)"
  - ID: floatcomp
    what: Floating-Point Comparison
    members: [ .ONE, .UEQ, .OEQ, .UNE, .OLT, .UGE, .OGE, .ULT ]
    cases:
      - Ordered and Not Equal
      - Unordered or Equal
      - Ordered and Equal
      - Unordered or Not Equal
      - Ordered and Less Than
      - Unordered or Greater Than or Equal
      - Ordered and Greater Than or Equal
      - Unordered or Less Than
    execution: "_ZX_3(%0)"
  - ID: rounding
    what: Floating-Point Rounding Mode
    members: [ .RN, .RU, .RD, .RZ, .R4, .R5, .RO, . ]
    cases:
      - Round to Nearest, ties to Even
      - Round Upward
      - Round Downward
      - Round toward Zero
      - Reserved 4
      - Reserved 5
      - Reserved 6
      - Use CS rounding
    execution: "_ZX_3(%0)"
  - ID: silent
    what: Floating-Point Effects on CS
    members: [ ., .S ]
    cases:
      - Effects on CS
      - Silent on CS
    execution: "_ZX_1(%0)"
    properties:
      '%CS.S': NoWrite
  - ID: roundint
    what: Integer Rounding Mode
    members: [ .RN, .RU, .RD, .RZ, .RHU ]
    cases:
      - Round to Nearest, ties to Even
      - Round Upward
      - Round Downward
      - Round toward Zero
      - Round Half Up
    execution: "_ZX_3(%0)"
  - ID: saturate
    what: Saturation
    members: [ .SAT, .SATU ]
    cases:
      - Signed
      - Unsigned
    execution: "_ZX_1(%0)"
  - ID: rectify
    what: Rectification
    members: [ ., .RELU ]
    cases:
      - No rectification
      - Rectified Linear Unit
    execution: "_ZX_1(%0)"
  - ID: variant
    what: Load Variants
    members: [ ., .S, .U, .US ]
    cases:
      - Cached
      - Speculative
      - Uncached
      - Uncached Speculative
    execution: "_ZX_2(%0)"
    properties:
      '%0.S': Dismissible,
      '%0.U': MemoryLevel=2
      '%0.US': MemoryLevel=2;Dismissible
  - ID: speculate
    what: Speculative Load
    members: [ .U, .US ]
    cases:
      - Uncached
      - Uncached Speculative
    execution: "_ZX_1(%0)"
    properties:
      '%0.U': MemoryLevel=2
      '%0.US': MemoryLevel=2;Dismissible
  - ID: column
    what: Column Selector
    members: [ .C0, .C1, .C2, .C3 ]
    cases:
      - Column 0
      - Column 1
      - Column 2
      - Column 3
    execution: "_ZX_2(%0)"
  - ID: doscale
    what: Enable Scaling for Indexed Addressing
    members: [ ., .XS ]
    cases:
      - Scale by 1
      - Scale by sizeof
    execution: "_ZX_1(%0)"
  - ID: qindex
    what: Quarter Index
    members: [ .Q0, .Q1, .Q2, .Q3 ]
    cases:
      - Quarter 0
      - Quarter 1
      - Quarter 2
      - Quarter 3
    execution: "_ZX_2(%0)"
  - ID: splat32
    what: Splat 32-bit Immediate
    members: [ ., ".@" ]
    cases:
      - No splat
      - Splat x2
    execution: "_ZX_1(%0)"
NativeType:
  - ID: Void
    align: 0
    printf: ".void"
    sizeof: 0
    width: 0
    type: Void
  - ID: Bool
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 1
    type: Bool
  - ID: Int8
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 8
    type: Signed
  - ID: Int16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Signed
  - ID: Int32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Signed
  - ID: Int64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Signed
  - ID: Int128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Signed
  - ID: Int128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Signed
  - ID: Int128x4
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 64
    slice: 32
    width: 512
    type: Signed
  - ID: Int128x8
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 128
    slice: 32
    width: 1024
    type: Signed
  - ID: Int128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Signed
  - ID: UInt8
    align: 1
    printf: ".byte 0x%x"
    sizeof: 1
    width: 8
    type: Unsigned
  - ID: UInt16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Unsigned
  - ID: UInt32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Unsigned
  - ID: UInt64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Unsigned
  - ID: UInt128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Unsigned
  - ID: UInt128x2
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 32
    slice: 32
    width: 256
    type: Unsigned
  - ID: UInt128x4
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 64
    slice: 32
    width: 512
    type: Unsigned
  - ID: UInt128x8
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 128
    slice: 32
    width: 1024
    type: Unsigned
  - ID: Float16
    align: 2
    printf: ".hword 0x%x"
    sizeof: 2
    width: 16
    type: Float
  - ID: Float32
    align: 4
    printf: ".word 0x%x"
    sizeof: 4
    width: 32
    type: Float
  - ID: Float64
    align: 8
    printf: ".word 0x%x, 0x%x"
    sizeof: 8
    slice: 32
    width: 64
    type: Float
  - ID: Float128
    align: 16
    printf: ".word 0x%x, 0x%x, 0x%x, 0x%x"
    sizeof: 16
    slice: 32
    width: 128
    type: Float
Platform:
  - ID: kv3_32
    charWidth: 8
    addrWidth: 32
    endian: Little
    alignText: 8
    alignData: 8
    alignHeap: 8
    alignStack: 8
    nativeInt: Int32
    nativeUInt: UInt32
    nativeFloat: Float64
    nativePtr: UInt32
  - ID: kv3_64
    charWidth: 8
    addrWidth: 32
    endian: Little
    alignText: 8
    alignData: 8
    alignHeap: 8
    alignStack: 8
    nativeInt: Int32
    nativeUInt: UInt32
    nativeFloat: Float64
    nativePtr: UInt64
Processor:
  - ID: cpu
    minTaken: 1
    interlocks: 1
    pipeline: [ ID, RR, E1, E2, CR, E3, E4, E5, WB, SF, SR ]
    stages: [ 0, 1, 2, 3, 4, 4, 5, 6, 6, 16, 24 ]
RegClass:
  - ID: aloneReg
    what: RegClas Implying Alone in Bundle
    registers: [ MMC, PS, SYOW, HTOW, ITOW, DOW, MOW, PSOW, SPS, SPS_PL0, SPS_PL1, SPS_PL2, SPS_PL3 ]
    execution: "SFR[%0]"
  - ID: onlyraReg
    what: Singleton RegClas with RA
    registers: [ RA ]
    execution: "SFR[%0]"
  - ID: onlygetReg
    what: Only GET System Registers
    include: systemReg
    exclude: [ RES31, [ RES<i>, 38..39 ], [ RES<i>, 47..63 ], [ RES<i>, 88..95 ], SYOW, HTOW, ITOW, DOW, MOW, PSOW, [ RES<i>, 102..127 ], [ RES<i>, 102..127 ], [ RES<i>, 129..131 ], [ RES<i>, 133..135 ], [ RES<i>, 137..139 ], [ RES<i>, 141..143 ], [ RES<i>, 145..147 ], [ RES<i>, 149..3839 ] ]
    execution: "SFR[%0]"
  - ID: onlysetReg
    what: Only SET System Registers without PS
    include: systemReg
    exclude: [ PC, RES31, [ RES<i>, 38..39 ], [ RES<i>, 47..63 ], [ RES<i>, 88..95 ], SYO, HTO, ITO, DO, MO, PSO, SYOW, HTOW, ITOW, DOW, MOW, PSOW, [ RES<i>, 102..127 ], [ RES<i>, 102..127 ], [ RES<i>, 129..131 ], [ RES<i>, 133..135 ], [ RES<i>, 137..139 ], [ RES<i>, 141..143 ], [ RES<i>, 145..147 ], [ RES<i>, 149..3839 ] ]
    execution: "SFR[%0]"
  - ID: onlyfxReg
    what: Only FX System Registers without PS
    registers: [ PCR, CS, CSIT, IPE, MEN, PMC, TCR, ILE, ILL, ILR, MMC, TEL, TEH, DC, MES, WS, [ SPS_PL<i>, 0..3 ], [ ES_PL<r>, 0..3 ], SPS, ES ]
    execution: "SFR[%0]"
  - ID: onlyswapReg
    what: Only SWAP System Registers without PS
    include: systemReg
    exclude: [ PS ]
    execution: "SFR[%0]"
  - ID: xworddReg
    what: Extension Word Double Registers
    registers: C0..C255
    shortName: c
    execution: "XCR[%0]"
  - ID: xwordqReg
    what: Extension Word Quadruple Registers
    multi: [ xworddReg, xworddReg ]
    registers: B0..B127
    shortName: b
    execution: "XBR[%0]"
  - ID: xwordoReg
    multi: [ xworddReg, xworddReg, xworddReg, xworddReg ]
    what: Extension Word Octuple Registers
    registers: A0..A63
    shortName: a
    execution: "XVR[%0]"
  - ID: xwordxReg
    what: Extension Word Hexadecuple Register
    multi: [ xwordoReg, xwordoReg ]
    registers: T0..T31
    shortName: x
    execution: "XTR[%0]"
  - ID: xwordvReg
    what: Extension Word Vector Registers
    multi: [ xwordoReg, xwordoReg, xwordoReg, xwordoReg ]
    registers: M0..M15
    shortName: m
    execution: "XMR[%0]"
  - ID: xwordoRegE
    what: Accelerator Registers Even Numbered
    registers: [ A0, A2, A4, A6, A8, A10, A12, A14, A16, A18, A20, A22, A24, A26, A28, A30, A32, A34, A36, A38, A40, A42, A44, A46, A48, A50, A52, A54, A56, A58, A60, A62 ]
    execution: "XVR[%0<<1]"
  - ID: xwordoRegO
    what: Accelerator Registers Odd Numbered
    registers: [ A1, A3, A5, A7, A9, A11, A13, A15, A17, A19, A21, A23, A25, A27, A29, A31, A33, A35, A37, A39, A41, A43, A45, A47, A49, A51, A53, A55, A57, A59, A61, A63 ]
    execution: "XVR[(%0<<1)+1]"
  - ID: xwordqRegE
    what: Block Registers Even Numbered
    registers: [ B0, B2, B4, B6, B8, B10, B12, B14, B16, B18, B20, B22, B24, B26, B28, B30, B32, B34, B36, B38, B40, B42, B44, B46, B48, B50, B52, B54, B56, B58, B60, B62, B64, B66, B68, B70, B72, B74, B76, B78, B80, B82, B84, B86, B88, B90, B92, B94, B96, B98, B100, B102, B104, B106, B108, B110, B112, B114, B116, B118, B120, B122, B124, B126 ]
    execution: "XBR[%0<<1]"
  - ID: xwordqRegO
    what: Block Registers Odd Numbered
    registers: [ B1, B3, B5, B7, B9, B11, B13, B15, B17, B19, B21, B23, B25, B27, B29, B31, B33, B35, B37, B39, B41, B43, B45, B47, B49, B51, B53, B55, B57, B59, B61, B63, B65, B67, B69, B71, B73, B75, B77, B79, B81, B83, B85, B87, B89, B91, B93, B95, B97, B99, B101, B103, B105, B107, B109, B111, B113, B115, B117, B119, B121, B123, B125, B127 ]
    execution: "XBR[(%0<<1)+1]"
  - ID: xwordqReg0M4
    what: Block Registers 0 Modulo 4
    registers: [ B0, B4, B8, B12, B16, B20, B24, B28, B32, B36, B40, B44, B48, B52, B56, B60, B64, B68, B72, B76, B80, B84, B88, B92, B96, B100, B104, B108, B112, B116, B120, B124 ]
    execution: "XBR[%0<<2]"
  - ID: xwordqReg1M4
    what: Block Registers 1 Modulo 4
    registers: [ B1, B5, B9, B13, B17, B21, B25, B29, B33, B37, B41, B45, B49, B53, B57, B61, B65, B69, B73, B77, B81, B85, B89, B93, B97, B101, B105, B109, B113, B117, B121, B125 ]
    execution: "XBR[(%0<<2)+1]"
  - ID: xwordqReg2M4
    what: Block Registers 2 Modulo 4
    registers: [ B2, B6, B10, B14, B18, B22, B26, B30, B34, B38, B42, B46, B50, B54, B58, B62, B66, B70, B74, B78, B82, B86, B90, B94, B98, B102, B106, B110, B114, B118, B122, B126 ]
    execution: "XBR[(%0<<2)+2]"
  - ID: xwordqReg3M4
    what: Block Registers 3 Modulo 4
    registers: [ B3, B7, B11, B15, B19, B23, B27, B31, B35, B39, B43, B47, B51, B55, B59, B63, B67, B71, B75, B79, B83, B87, B91, B95, B99, B103, B107, B111, B115, B119, B123, B127 ]
    execution: "XBR[(%0<<2)+3]"
  - ID: xworddReg0M4
    what: Coprocessor Registers 0 Modulo 4
    registers: [ C0, C4, C8, C12, C16, C20, C24, C28, C32, C36, C40, C44, C48, C52, C56, C60, C64, C68, C72, C76, C80, C84, C88, C92, C96, C100, C104, C108, C112, C116, C120, C124, C128, C132, C136, C140, C144, C148, C152, C156, C160, C164, C168, C172, C176, C180, C184, C188, C192, C196, C200, C204, C208, C212, C216, C220, C224, C228, C232, C236, C240, C244, C248, C252, ]
    execution: "XCR[%0<<2]"
  - ID: xworddReg1M4
    what: Coprocessor Registers 1 Modulo 4
    registers: [ C1, C5, C9, C13, C17, C21, C25, C29, C33, C37, C41, C45, C49, C53, C57, C61, C65, C69, C73, C77, C81, C85, C89, C93, C97, C101, C105, C109, C113, C117, C121, C125, C129, C133, C137, C141, C145, C149, C153, C157, C161, C165, C169, C173, C177, C181, C185, C189, C193, C197, C201, C205, C209, C213, C217, C221, C225, C229, C233, C237, C241, C245, C249, C253, ]
    execution: "XCR[(%0<<2)+1]"
  - ID: xworddReg2M4
    what: Coprocessor Registers 2 Modulo 4
    registers: [ C2, C6, C10, C14, C18, C22, C26, C30, C34, C38, C42, C46, C50, C54, C58, C62, C66, C70, C74, C78, C82, C86, C90, C94, C98, C102, C106, C110, C114, C118, C122, C126, C130, C134, C138, C142, C146, C150, C154, C158, C162, C166, C170, C174, C178, C182, C186, C190, C194, C198, C202, C206, C210, C214, C218, C222, C226, C230, C234, C238, C242, C246, C250, C254, ]
    execution: "XCR[(%0<<2)+2]"
  - ID: xworddReg3M4
    what: Coprocessor Registers 3 Modulo 4
    registers: [ C3, C7, C11, C15, C19, C23, C27, C31, C35, C39, C43, C47, C51, C55, C59, C63, C67, C71, C75, C79, C83, C87, C91, C95, C99, C103, C107, C111, C115, C119, C123, C127, C131, C135, C139, C143, C147, C151, C155, C159, C163, C167, C171, C175, C179, C183, C187, C191, C195, C199, C203, C207, C211, C215, C219, C223, C227, C231, C235, C239, C243, C247, C251, C255, ]
    execution: "XCR[(%0<<2)+3]"
RegField:
################ MEN ################
  - ID: MEN_MEN
    what: Miscellaneous External Notifications
    location: [ MEN, 0..15 ]
    owners: [ MO_MEN ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MEN
    reset: 0
################ SYO ################
  - ID: SYO_Q0
    what: Quarter 0 syscalls 0 to 1023 owner
    location: [ SYO, 0..1 ]
    reset: 0
  - ID: SYO_Q1
    what: Quarter 1 syscalls 1024 to 2047 owner
    location: [ SYO, 2..3 ]
    reset: 0
  - ID: SYO_Q2
    what: Quarter 2 syscalls 2048 to 3071 owner
    location: [ SYO, 4..5 ]
    reset: 0
  - ID: SYO_Q3
    what: Quarter 3 syscalls 3072 to 4095 owner
    location: [ SYO, 6..7 ]
    reset: 0
################ SYOW ################
  - ID: SYOW_Q0
    what: Quarter 0 syscalls 0 to 1023 owner
    location: [ SYO, 0..1 ]
    owners: [ SYO_Q0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q1
    what: Quarter 1 syscalls 1024 to 2047 owner
    location: [ SYO, 2..3 ]
    owners: [ SYO_Q1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q2
    what: Quarter 2 syscalls 2048 to 3071 owner
    location: [ SYO, 4..5 ]
    owners: [ SYO_Q2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
  - ID: SYOW_Q3
    what: Quarter 3 syscalls 3072 to 4095 owner
    location: [ SYO, 6..7 ]
    owners: [ SYO_Q3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: SYOW
    reset: 0
################ HTO ################
  - ID: HTO_OPC
    what: OPCode trap owner
    location: [ HTO, 0..1 ]
    reset: 0
  - ID: HTO_DMIS
    what: Data MISalign access trap owner
    location: [ HTO, 2..3 ]
    reset: 0
  - ID: HTO_PSYS
    what: Program System Error trap owner
    location: [ HTO, 4..5 ]
    reset: 0
  - ID: HTO_DSYS
    what: Data System Error trap owner
    location: [ HTO, 6..7 ]
    reset: 0
  - ID: HTO_DECCG
    what: Double ECC traps group owner
    location: [ HTO, 8..9 ]
    reset: 0
  - ID: HTO_SECCG
    what: Single ECC traps group owner
    location: [ HTO, 10..11 ]
    reset: 0
  - ID: HTO_NOMAP
    what: No mapping trap owner
    location: [ HTO, 12..13 ]
    reset: 0
  - ID: HTO_PROT
    what: PROTection trap owner
    location: [ HTO, 14..15 ]
    reset: 0
  - ID: HTO_W2CL
    what: Write to clean trap owner
    location: [ HTO, 16..17 ]
    reset: 0
  - ID: HTO_A2CL
    what: Atomic to clean trap owner
    location: [ HTO, 18..19 ]
    reset: 0
  - ID: HTO_DE
    what: Double Exception trap owner
    location: [ HTO, 20..21 ]
    reset: 0
  - ID: HTO_VSFR
    what: Virtual SFR trap owner
    location: [ HTO, 22..23 ]
    reset: 0
  - ID: HTO_PLO
    what: Privilege Level Overflow trap owner
    location: [ HTO, 24..25 ]
    reset: 0
################ HTOW ################
  - ID: HTOW_OPC
    what: OPCode trap owner
    location: [ HTO, 0..1 ]
    owners: [ HTO_OPC ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DMIS
    what: Data MISalign access trap owner
    location: [ HTO, 2..3 ]
    owners: [ HTO_DMIS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PSYS
    what: Program System Error trap owner
    location: [ HTO, 4..5 ]
    owners: [ HTO_PSYS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DSYS
    what: Data System Error trap owner
    location: [ HTO, 6..7 ]
    owners: [ HTO_DSYS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DECCG
    what: Double ECC traps group owner
    location: [ HTO, 8..9 ]
    owners: [ HTO_DECCG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_SECCG
    what: Single ECC traps group owner
    location: [ HTO, 10..11 ]
    owners: [ HTO_SECCG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_NOMAP
    what: No mapping trap owner
    location: [ HTO, 12..13 ]
    owners: [ HTO_NOMAP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PROT
    what: PROTection trap owner
    location: [ HTO, 14..15 ]
    owners: [ HTO_PROT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_W2CL
    what: Write to clean trap owner
    location: [ HTO, 16..17 ]
    owners: [ HTO_W2CL ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_A2CL
    what: Atomic to clean trap owner
    location: [ HTO, 18..19 ]
    owners: [ HTO_A2CL ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_DE
    what: Double Exception trap owner
    location: [ HTO, 20..21 ]
    owners: [ HTO_DE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_VSFR
    what: Virtual SFR trap owner
    location: [ HTO, 22..23 ]
    owners: [ HTO_VSFR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
  - ID: HTOW_PLO
    what: Privilege Level Overflow trap owner
    location: [ HTO, 24..25 ]
    owners: [ HTO_PLO ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: HTOW
    reset: 0
################ ITO ################
  - ID: ITO_IT0
    what: Interrupt 0 owner
    location: [ ITO, 0..1 ]
    reset: 0
  - ID: ITO_IT1
    what: Interrupt 1 owner
    location: [ ITO, 2..3 ]
    reset: 0
  - ID: ITO_IT2
    what: Interrupt 2 owner
    location: [ ITO, 4..5 ]
    reset: 0
  - ID: ITO_IT3
    what: Interrupt 3 owner
    location: [ ITO, 6..7 ]
    reset: 0
  - ID: ITO_IT4
    what: Interrupt 4 owner
    location: [ ITO, 8..9 ]
    reset: 0
  - ID: ITO_IT5
    what: Interrupt 5 owner
    location: [ ITO, 10..11 ]
    reset: 0
  - ID: ITO_IT6
    what: Interrupt 6 owner
    location: [ ITO, 12..13 ]
    reset: 0
  - ID: ITO_IT7
    what: Interrupt 7 owner
    location: [ ITO, 14..15 ]
    reset: 0
  - ID: ITO_IT8
    what: Interrupt 8 owner
    location: [ ITO, 16..17 ]
    reset: 0
  - ID: ITO_IT9
    what: Interrupt 9 owner
    location: [ ITO, 18..19 ]
    reset: 0
  - ID: ITO_IT10
    what: Interrupt 10 owner
    location: [ ITO, 20..21 ]
    reset: 0
  - ID: ITO_IT11
    what: Interrupt 11 owner
    location: [ ITO, 22..23 ]
    reset: 0
  - ID: ITO_IT12
    what: Interrupt 12 owner
    location: [ ITO, 24..25 ]
    reset: 0
  - ID: ITO_IT13
    what: Interrupt 13 owner
    location: [ ITO, 26..27 ]
    reset: 0
  - ID: ITO_IT14
    what: Interrupt 14 owner
    location: [ ITO, 28..29 ]
    reset: 0
  - ID: ITO_IT15
    what: Interrupt 15 owner
    location: [ ITO, 30..31 ]
    reset: 0
  - ID: ITO_IT16
    what: Interrupt 16 owner
    location: [ ITO, 32..33 ]
    reset: 0
  - ID: ITO_IT17
    what: Interrupt 17 owner
    location: [ ITO, 34..35 ]
    reset: 0
  - ID: ITO_IT18
    what: Interrupt 18 owner
    location: [ ITO, 36..37 ]
    reset: 0
  - ID: ITO_IT19
    what: Interrupt 19 owner
    location: [ ITO, 38..39 ]
    reset: 0
  - ID: ITO_IT20
    what: Interrupt 20 owner
    location: [ ITO, 40..41 ]
    reset: 0
  - ID: ITO_IT21
    what: Interrupt 21 owner
    location: [ ITO, 42..43 ]
    reset: 0
  - ID: ITO_IT22
    what: Interrupt 22 owner
    location: [ ITO, 44..45 ]
    reset: 0
  - ID: ITO_IT23
    what: Interrupt 23 owner
    location: [ ITO, 46..47 ]
    reset: 0
  - ID: ITO_IT24
    what: Interrupt 24 owner
    location: [ ITO, 48..49 ]
    reset: 0
  - ID: ITO_IT25
    what: Interrupt 25 owner
    location: [ ITO, 50..51 ]
    reset: 0
  - ID: ITO_IT26
    what: Interrupt 26 owner
    location: [ ITO, 52..53 ]
    reset: 0
  - ID: ITO_IT27
    what: Interrupt 27 owner
    location: [ ITO, 54..55 ]
    reset: 0
  - ID: ITO_IT28
    what: Interrupt 28 owner
    location: [ ITO, 56..57 ]
    reset: 0
  - ID: ITO_IT29
    what: Interrupt 29 owner
    location: [ ITO, 58..59 ]
    reset: 0
  - ID: ITO_IT30
    what: Interrupt 30 owner
    location: [ ITO, 60..61 ]
    reset: 0
  - ID: ITO_IT31
    what: Interrupt 31 owner
    location: [ ITO, 62..63 ]
    reset: 0
################ ILE ################
  - ID: ILE_IT0
    what: Interrupt 0 owner
    location: [ ILE, 0 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT1
    what: Interrupt 1 owner
    location: [ ILE, 1 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT2
    what: Interrupt 2 owner
    location: [ ILE, 2 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT3
    what: Interrupt 3 owner
    location: [ ILE, 3 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT4
    what: Interrupt 4 owner
    location: [ ILE, 4 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT5
    what: Interrupt 5 owner
    location: [ ILE, 5 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT6
    what: Interrupt 6 owner
    location: [ ILE, 6 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT7
    what: Interrupt 7 owner
    location: [ ILE, 7 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT8
    what: Interrupt 8 owner
    location: [ ILE, 8 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT9
    what: Interrupt 9 owner
    location: [ ILE, 9 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT10
    what: Interrupt 10 owner
    location: [ ILE, 10 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT11
    what: Interrupt 11 owner
    location: [ ILE, 11 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT12
    what: Interrupt 12 owner
    location: [ ILE, 12 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT13
    what: Interrupt 13 owner
    location: [ ILE, 13 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT14
    what: Interrupt 14 owner
    location: [ ILE, 14 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT15
    what: Interrupt 15 owner
    location: [ ILE, 15 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT16
    what: Interrupt 16 owner
    location: [ ILE, 16 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT17
    what: Interrupt 17 owner
    location: [ ILE, 17 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT18
    what: Interrupt 18 owner
    location: [ ILE, 18 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT19
    what: Interrupt 19 owner
    location: [ ILE, 19 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT20
    what: Interrupt 20 owner
    location: [ ILE, 20 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT21
    what: Interrupt 21 owner
    location: [ ILE, 21 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT22
    what: Interrupt 22 owner
    location: [ ILE, 22 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT23
    what: Interrupt 23 owner
    location: [ ILE, 23 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT24
    what: Interrupt 24 owner
    location: [ ILE, 24 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT25
    what: Interrupt 25 owner
    location: [ ILE, 25 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT26
    what: Interrupt 26 owner
    location: [ ILE, 26 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT27
    what: Interrupt 27 owner
    location: [ ILE, 27 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT28
    what: Interrupt 28 owner
    location: [ ILE, 28 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT29
    what: Interrupt 29 owner
    location: [ ILE, 29 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT30
    what: Interrupt 30 owner
    location: [ ILE, 30 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILE_IT31
    what: Interrupt 31 owner
    location: [ ILE, 31 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ILL ################
  - ID: ILL_IT0
    what: Interrupt 0 owner
    location: [ ILL, 0..1 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT1
    what: Interrupt 1 owner
    location: [ ILL, 2..3 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT2
    what: Interrupt 2 owner
    location: [ ILL, 4..5 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT3
    what: Interrupt 3 owner
    location: [ ILL, 6..7 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT4
    what: Interrupt 4 owner
    location: [ ILL, 8..9 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT5
    what: Interrupt 5 owner
    location: [ ILL, 10..11 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT6
    what: Interrupt 6 owner
    location: [ ILL, 12..13 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT7
    what: Interrupt 7 owner
    location: [ ILL, 14..15 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT8
    what: Interrupt 8 owner
    location: [ ILL, 16..17 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT9
    what: Interrupt 9 owner
    location: [ ILL, 18..19 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT10
    what: Interrupt 10 owner
    location: [ ILL, 20..21 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT11
    what: Interrupt 11 owner
    location: [ ILL, 22..23 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT12
    what: Interrupt 12 owner
    location: [ ILL, 24..25 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT13
    what: Interrupt 13 owner
    location: [ ILL, 26..27 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT14
    what: Interrupt 14 owner
    location: [ ILL, 28..29 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT15
    what: Interrupt 15 owner
    location: [ ILL, 30..31 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT16
    what: Interrupt 16 owner
    location: [ ILL, 32..33 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT17
    what: Interrupt 17 owner
    location: [ ILL, 34..35 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT18
    what: Interrupt 18 owner
    location: [ ILL, 36..37 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT19
    what: Interrupt 19 owner
    location: [ ILL, 38..39 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT20
    what: Interrupt 20 owner
    location: [ ILL, 40..41 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT21
    what: Interrupt 21 owner
    location: [ ILL, 42..43 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT22
    what: Interrupt 22 owner
    location: [ ILL, 44..45 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT23
    what: Interrupt 23 owner
    location: [ ILL, 46..47 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT24
    what: Interrupt 24 owner
    location: [ ILL, 48..49 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT25
    what: Interrupt 25 owner
    location: [ ILL, 50..51 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT26
    what: Interrupt 26 owner
    location: [ ILL, 52..53 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT27
    what: Interrupt 27 owner
    location: [ ILL, 54..55 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT28
    what: Interrupt 28 owner
    location: [ ILL, 56..57 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT29
    what: Interrupt 29 owner
    location: [ ILL, 58..59 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT30
    what: Interrupt 30 owner
    location: [ ILL, 60..61 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILL_IT31
    what: Interrupt 31 owner
    location: [ ILL, 62..63 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ILR ################
  - ID: ILR_IT0
    what: Interrupt 0 owner
    location: [ ILR, 0 ]
    owners: [ ITO_IT0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT1
    what: Interrupt 1 owner
    location: [ ILR, 1 ]
    owners: [ ITO_IT1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT2
    what: Interrupt 2 owner
    location: [ ILR, 2 ]
    owners: [ ITO_IT2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT3
    what: Interrupt 3 owner
    location: [ ILR, 3 ]
    owners: [ ITO_IT3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT4
    what: Interrupt 4 owner
    location: [ ILR, 4 ]
    owners: [ ITO_IT4 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT5
    what: Interrupt 5 owner
    location: [ ILR, 5 ]
    owners: [ ITO_IT5 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT6
    what: Interrupt 6 owner
    location: [ ILR, 6 ]
    owners: [ ITO_IT6 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT7
    what: Interrupt 7 owner
    location: [ ILR, 7 ]
    owners: [ ITO_IT7 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT8
    what: Interrupt 8 owner
    location: [ ILR, 8 ]
    owners: [ ITO_IT8 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT9
    what: Interrupt 9 owner
    location: [ ILR, 9 ]
    owners: [ ITO_IT9 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT10
    what: Interrupt 10 owner
    location: [ ILR, 10 ]
    owners: [ ITO_IT10 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT11
    what: Interrupt 11 owner
    location: [ ILR, 11 ]
    owners: [ ITO_IT11 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT12
    what: Interrupt 12 owner
    location: [ ILR, 12 ]
    owners: [ ITO_IT12 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT13
    what: Interrupt 13 owner
    location: [ ILR, 13 ]
    owners: [ ITO_IT13 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT14
    what: Interrupt 14 owner
    location: [ ILR, 14 ]
    owners: [ ITO_IT14 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT15
    what: Interrupt 15 owner
    location: [ ILR, 15 ]
    owners: [ ITO_IT15 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT16
    what: Interrupt 16 owner
    location: [ ILR, 16 ]
    owners: [ ITO_IT16 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT17
    what: Interrupt 17 owner
    location: [ ILR, 17 ]
    owners: [ ITO_IT17 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT18
    what: Interrupt 18 owner
    location: [ ILR, 18 ]
    owners: [ ITO_IT18 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT19
    what: Interrupt 19 owner
    location: [ ILR, 19 ]
    owners: [ ITO_IT19 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT20
    what: Interrupt 20 owner
    location: [ ILR, 20 ]
    owners: [ ITO_IT20 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT21
    what: Interrupt 21 owner
    location: [ ILR, 21 ]
    owners: [ ITO_IT21 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT22
    what: Interrupt 22 owner
    location: [ ILR, 22 ]
    owners: [ ITO_IT22 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT23
    what: Interrupt 23 owner
    location: [ ILR, 23 ]
    owners: [ ITO_IT23 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT24
    what: Interrupt 24 owner
    location: [ ILR, 24 ]
    owners: [ ITO_IT24 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT25
    what: Interrupt 25 owner
    location: [ ILR, 25 ]
    owners: [ ITO_IT25 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT26
    what: Interrupt 26 owner
    location: [ ILR, 26 ]
    owners: [ ITO_IT26 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT27
    what: Interrupt 27 owner
    location: [ ILR, 27 ]
    owners: [ ITO_IT27 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT28
    what: Interrupt 28 owner
    location: [ ILR, 28 ]
    owners: [ ITO_IT28 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT29
    what: Interrupt 29 owner
    location: [ ILR, 29 ]
    owners: [ ITO_IT29 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT30
    what: Interrupt 30 owner
    location: [ ILR, 30 ]
    owners: [ ITO_IT30 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: ILR_IT31
    what: Interrupt 31 owner
    location: [ ILR, 31 ]
    owners: [ ITO_IT31 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ITOW ################
  - ID: ITOW_IT0
    what: Interrupt 0 owner
    location: [ ITO, 0..1 ]
    owners: [ ITO_IT0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT1
    what: Interrupt 1 owner
    location: [ ITO, 2..3 ]
    owners: [ ITO_IT1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT2
    what: Interrupt 2 owner
    location: [ ITO, 4..5 ]
    owners: [ ITO_IT2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT3
    what: Interrupt 3 owner
    location: [ ITO, 6..7 ]
    owners: [ ITO_IT3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT4
    what: Interrupt 4 owner
    location: [ ITO, 8..9 ]
    owners: [ ITO_IT4 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT5
    what: Interrupt 5 owner
    location: [ ITO, 10..11 ]
    owners: [ ITO_IT5 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT6
    what: Interrupt 6 owner
    location: [ ITO, 12..13 ]
    owners: [ ITO_IT6 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT7
    what: Interrupt 7 owner
    location: [ ITO, 14..15 ]
    owners: [ ITO_IT7 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT8
    what: Interrupt 8 owner
    location: [ ITO, 16..17 ]
    owners: [ ITO_IT8 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT9
    what: Interrupt 9 owner
    location: [ ITO, 18..19 ]
    owners: [ ITO_IT9 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT10
    what: Interrupt 10 owner
    location: [ ITO, 20..21 ]
    owners: [ ITO_IT10 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT11
    what: Interrupt 11 owner
    location: [ ITO, 22..23 ]
    owners: [ ITO_IT11 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT12
    what: Interrupt 12 owner
    location: [ ITO, 24..25 ]
    owners: [ ITO_IT12 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT13
    what: Interrupt 13 owner
    location: [ ITO, 26..27 ]
    owners: [ ITO_IT13 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT14
    what: Interrupt 14 owner
    location: [ ITO, 28..29 ]
    owners: [ ITO_IT14 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT15
    what: Interrupt 15 owner
    location: [ ITO, 30..31 ]
    owners: [ ITO_IT15 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT16
    what: Interrupt 16 owner
    location: [ ITO, 32..33 ]
    owners: [ ITO_IT16 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT17
    what: Interrupt 17 owner
    location: [ ITO, 34..35 ]
    owners: [ ITO_IT17 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT18
    what: Interrupt 18 owner
    location: [ ITO, 36..37 ]
    owners: [ ITO_IT18 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT19
    what: Interrupt 19 owner
    location: [ ITO, 38..39 ]
    owners: [ ITO_IT19 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT20
    what: Interrupt 20 owner
    location: [ ITO, 40..41 ]
    owners: [ ITO_IT20 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT21
    what: Interrupt 21 owner
    location: [ ITO, 42..43 ]
    owners: [ ITO_IT21 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT22
    what: Interrupt 22 owner
    location: [ ITO, 44..45 ]
    owners: [ ITO_IT22 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT23
    what: Interrupt 23 owner
    location: [ ITO, 46..47 ]
    owners: [ ITO_IT23 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT24
    what: Interrupt 24 owner
    location: [ ITO, 48..49 ]
    owners: [ ITO_IT24 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT25
    what: Interrupt 25 owner
    location: [ ITO, 50..51 ]
    owners: [ ITO_IT25 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT26
    what: Interrupt 26 owner
    location: [ ITO, 52..53 ]
    owners: [ ITO_IT26 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT27
    what: Interrupt 27 owner
    location: [ ITO, 54..55 ]
    owners: [ ITO_IT27 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT28
    what: Interrupt 28 owner
    location: [ ITO, 56..57 ]
    owners: [ ITO_IT28 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT29
    what: Interrupt 29 owner
    location: [ ITO, 58..59 ]
    owners: [ ITO_IT29 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT30
    what: Interrupt 30 owner
    location: [ ITO, 60..61 ]
    owners: [ ITO_IT30 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
  - ID: ITOW_IT31
    what: Interrupt 31 owner
    location: [ ITO, 62..63 ]
    owners: [ ITO_IT31 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: ITOW
    reset: 0
################ DO ################
  - ID: DO_B0
    what: Breakpoint 0 owner.
    location: [ DO, 0..1 ]
    reset: 0
  - ID: DO_B1
    what: Breakpoint 1 owner.
    location: [ DO, 2..3 ]
    reset: 0
  - ID: DO_W0
    what: Watchpoint 0 owner.
    location: [ DO, 4..5 ]
    reset: 0
  - ID: DO_W1
    what: Watchpoint 1 owner.
    location: [ DO, 6..7 ]
    reset: 0
################ DBA0 ################
  - ID: DBA0_DBA0
    what: Debug Breakpoint Address 0
    location: [ DBA0, 0..63 ]
    owners: [ DO_B0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA0
    reset: 0
################ DBA1 ################
  - ID: DBA1_DBA1
    what: Debug Breakpoint Address 1
    location: [ DBA1, 0..63 ]
    owners: [ DO_B1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DBA1
    reset: 0
################ DWA0 ################
  - ID: DWA0_DWA0
    what: Debug Breakpoint Address 0
    location: [ DWA0, 0..63 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA0
    reset: 0
################ DWA1 ################
  - ID: DWA1_DWA1
    what: Debug Breakpoint Address 1
    location: [ DWA1, 0..63 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DWA1
    reset: 0
################ DOW ################
  - ID: DOW_B0
    what: Breakpoint 0 owner.
    location: [ DO, 0..1 ]
    owners: [ DO_B0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_B1
    what: Breakpoint 1 owner.
    location: [ DO, 2..3 ]
    owners: [ DO_B1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W0
    what: Watchpoint 0 owner.
    location: [ DO, 4..5 ]
    owners: [ DO_W0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
  - ID: DOW_W1
    what: Watchpoint 1 owner.
    location: [ DO, 6..7 ]
    owners: [ DO_W1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: DOW
    reset: 0
################ MO ################
  - ID: MO_MMI
    what: Memory Management Instructions owner.
    location: [ MO, 0..1 ]
    reset: 0
  - ID: MO_RFE
    what: RFE instruction owner.
    location: [ MO, 2..3 ]
    reset: 0
  - ID: MO_STOP
    what: STOP instruction owner.
    location: [ MO, 4..5 ]
    reset: 0
  - ID: MO_SYNC
    what: SYNCGROUP instruction owner.
    location: [ MO, 6..7 ]
    reset: 0
  - ID: MO_PCR
    what: PCR register owner.
    location: [ MO, 8..9 ]
    reset: 0
  - ID: MO_MSG
    what: MMU SFR GROUP registers owner.
    location: [ MO, 10..11 ]
    reset: 0
  - ID: MO_MEN
    what: Miscellaneous External Notifications register owner.
    location: [ MO, 12..13 ]
    reset: 0
  - ID: MO_MES
    what: Memory Error Status register owner.
    location: [ MO, 14..15 ]
    reset: 0
  - ID: MO_CSIT
    what: Compute Status Artithmetic Interrupt register owner.
    location: [ MO, 16..17 ]
    reset: 0
  - ID: MO_T0
    what: Timer 0 register group owner
    location: [ MO, 18..19 ]
    reset: 0
  - ID: MO_T1
    what: Timer 1 register group owner
    location: [ MO, 20..21 ]
    reset: 0
  - ID: MO_WD
    what: Watch Dog register group owner.
    location: [ MO, 22..23 ]
    reset: 0
  - ID: MO_PM0
    what: Performance Monitor 0 register owner.
    location: [ MO, 24..25 ]
    reset: 0
  - ID: MO_PM1
    what: Performance Monitor 1 register owner.
    location: [ MO, 26..27 ]
    reset: 0
  - ID: MO_PM2
    what: Performance Monitor 2 register owner.
    location: [ MO, 28..29 ]
    reset: 0
  - ID: MO_PM3
    what: Performance Monitor 3 register owner.
    location: [ MO, 30..31 ]
    reset: 0
  - ID: MO_PMIT
    what: Performance Monitor Interrupt register group owner.
    location: [ MO, 32..33 ]
    reset: 0
################ MOW ################
  - ID: MOW_MMI
    what: Memory Management Instructions owner.
    location: [ MO, 0..1 ]
    owners: [ MO_MMI ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_RFE
    what: RFE instruction owner.
    location: [ MO, 2..3 ]
    owners: [ MO_RFE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_STOP
    what: STOP instruction owner.
    location: [ MO, 4..5 ]
    owners: [ MO_STOP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_SYNC
    what: SYNCGROUP instruction owner.
    location: [ MO, 6..7 ]
    owners: [ MO_SYNC ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PCR
    what: PCR register owner.
    location: [ MO, 8..9 ]
    owners: [ MO_PCR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MSG
    what: MMU SFR GROUP registers owner.
    location: [ MO, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MEN
    what: Miscellaneous External Notifications register owner.
    location: [ MO, 12..13 ]
    owners: [ MO_MEN ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_MES
    what: Memory Error Status register owner.
    location: [ MO, 14..15 ]
    owners: [ MO_MES ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_CSIT
    what: Compute Status Artithmetic Interrupt register owner.
    location: [ MO, 16..17 ]
    owners: [ MO_CSIT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_T0
    what: Timer 0 register group owner
    location: [ MO, 18..19 ]
    owners: [ MO_T0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_T1
    what: Timer 1 register group owner
    location: [ MO, 20..21 ]
    owners: [ MO_T1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_WD
    what: Watch Dog register group owner.
    location: [ MO, 22..23 ]
    owners: [ MO_WD ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM0
    what: Performance Monitor 0 register owner.
    location: [ MO, 24..25 ]
    owners: [ MO_PM0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM1
    what: Performance Monitor 1 register owner.
    location: [ MO, 26..27 ]
    owners: [ MO_PM1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM2
    what: Performance Monitor 2 register owner.
    location: [ MO, 28..29 ]
    owners: [ MO_PM2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PM3
    what: Performance Monitor 3 register owner.
    location: [ MO, 30..31 ]
    owners: [ MO_PM3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
  - ID: MOW_PMIT
    what: Performance Monitor Interrupt register group owner.
    location: [ MO, 32..33 ]
    owners: [ MO_PMIT ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: MOW
    reset: 0
################ PS ################
  - ID: PS_PL
    what: Current Privilege Level
    location: [ PS, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_ET
    what: Exception Taken
    location: [ PS, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
  - ID: PS_HTD
    what: Hardware Trap Disable
    location: [ PS, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_IE
    what: Interrupt Enable
    location: [ PS, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_HLE
    what: Hardware Loop Enable
    location: [ PS, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SRE
    what: Software REserved
    location: [ PS, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_DAUS
    what: Data Accesses Use SPS settings
    location: [ PS, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_ICE
    what: Instruction Cache Enable
    location: [ PS, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_USE
    what: Uncached Streaming Enable
    location: [ PS, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_DCE
    what: Data Cache Enable
    location: [ PS, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_MME
    what: Memory Management Enable
    location: [ PS, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_IL
    what: Interrupt Level
    location: [ PS, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_VS
    what: Virtual Space
    location: [ PS, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_V64
    what: Virtual 64 bits mode.
    location: [ PS, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_L2E
    what: L2 cache Enable.
    location: [ PS, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SME
    what: Step Mode Enabled
    location: [ PS, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_SMR
    what: Step Mode Ready
    location: [ PS, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: PS_PMJ
    what: Page Mask in JTLB.
    location: [ PS, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: PS_MMUP
    what: Privileged on MMU.
    location: [ PS, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x1
################ SPS ################
  - ID: SPS_PL
    what: Current Privilege Level
    location: [ SPS, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_ET
    what: Exception Taken
    location: [ SPS, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_HTD
    what: Hardware Trap Disable
    location: [ SPS, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_IE
    what: Interrupt Enable
    location: [ SPS, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_HLE
    what: Hardware Loop Enable
    location: [ SPS, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SRE
    what: Software REserved
    location: [ SPS, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_ICE
    what: Instruction Cache Enable
    location: [ SPS, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_USE
    what: Uncached Streaming Enable
    location: [ SPS, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_DCE
    what: Data Cache Enable
    location: [ SPS, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_MME
    what: Memory Management Enable
    location: [ SPS, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_IL
    what: Interrupt Level
    location: [ SPS, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_VS
    what: Virtual Space
    location: [ SPS, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_V64
    what: Virtual 64 bits mode.
    location: [ SPS, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_L2E
    what: L2 cache Enable.
    location: [ SPS, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SME
    what: Step Mode Enabled
    location: [ SPS, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_SMR
    what: Step Mode Ready
    location: [ SPS, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PMJ
    what: Page Mask in JTLB.
    location: [ SPS, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_MMUP
    what: Privileged on MMU.
    location: [ SPS, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL0 ################
  - ID: SPS_PL0_PL
    what: Current Privilege Level
    location: [ SPS_PL0, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_ET
    what: Exception Taken
    location: [ SPS_PL0, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL0, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_IE
    what: Interrupt Enable
    location: [ SPS_PL0, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL0, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SRE
    what: Software REserved
    location: [ SPS_PL0, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL0, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL0, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL0, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_DCE
    what: Data Cache Enable
    location: [ SPS_PL0, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_MME
    what: Memory Management Enable
    location: [ SPS_PL0, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_IL
    what: Interrupt Level
    location: [ SPS_PL0, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_VS
    what: Virtual Space
    location: [ SPS_PL0, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL0, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_L2E
    what: L2 cache Enable.
    location: [ SPS_PL0, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SME
    what: Step Mode Enabled
    location: [ SPS_PL0, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_SMR
    what: Step Mode Ready
    location: [ SPS_PL0, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL0_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL0, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL0_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL0, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL1 ################
  - ID: SPS_PL1_PL
    what: Current Privilege Level
    location: [ SPS_PL1, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_ET
    what: Exception Taken
    location: [ SPS_PL1, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL1, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_IE
    what: Interrupt Enable
    location: [ SPS_PL1, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL1, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SRE
    what: Software REserved
    location: [ SPS_PL1, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL1, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL1, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL1, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_DCE
    what: Data Cache Enable
    location: [ SPS_PL1, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_MME
    what: Memory Management Enable
    location: [ SPS_PL1, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_IL
    what: Interrupt Level
    location: [ SPS_PL1, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_VS
    what: Virtual Space
    location: [ SPS_PL1, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL1, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_L2E
    what: L2 cache Enable.
    location: [ SPS_PL1, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SME
    what: Step Mode Enabled
    location: [ SPS_PL1, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_SMR
    what: Step Mode Ready
    location: [ SPS_PL1, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL1_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL1, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL1_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL1, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL2 ################
  - ID: SPS_PL2_PL
    what: Current Privilege Level
    location: [ SPS_PL2, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_ET
    what: Exception Taken
    location: [ SPS_PL2, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL2, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_IE
    what: Interrupt Enable
    location: [ SPS_PL2, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL2, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SRE
    what: Software REserved
    location: [ SPS_PL2, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL2, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL2, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL2, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_DCE
    what: Data Cache Enable
    location: [ SPS_PL2, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_MME
    what: Memory Management Enable
    location: [ SPS_PL2, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_IL
    what: Interrupt Level
    location: [ SPS_PL2, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_VS
    what: Virtual Space
    location: [ SPS_PL2, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL2, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_L2E
    what: L2 cache Enable.
    location: [ SPS_PL2, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SME
    what: Step Mode Enabled
    location: [ SPS_PL2, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_SMR
    what: Step Mode Ready
    location: [ SPS_PL2, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL2_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL2, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL2_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL2, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ SPS_PL3 ################
  - ID: SPS_PL3_PL
    what: Current Privilege Level
    location: [ SPS_PL3, 0..1 ]
    owners: [ PSO_PL0, PSO_PL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_ET
    what: Exception Taken
    location: [ SPS_PL3, 2 ]
    owners: [ PSO_ET ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_HTD
    what: Hardware Trap Disable
    location: [ SPS_PL3, 3 ]
    owners: [ PSO_HTD ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_IE
    what: Interrupt Enable
    location: [ SPS_PL3, 4 ]
    owners: [ PSO_IE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_HLE
    what: Hardware Loop Enable
    location: [ SPS_PL3, 5 ]
    owners: [ PSO_HLE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SRE
    what: Software REserved
    location: [ SPS_PL3, 6 ]
    owners: [ PSO_SRE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_DAUS
    what: Data Accesses Use SPS settings
    location: [ SPS_PL3, 7 ]
    owners: [ PSO_DAUS ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_ICE
    what: Instruction Cache Enable
    location: [ SPS_PL3, 8 ]
    owners: [ PSO_ICE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_USE
    what: Uncached Streaming Enable
    location: [ SPS_PL3, 9 ]
    owners: [ PSO_USE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_DCE
    what: Data Cache Enable
    location: [ SPS_PL3, 10 ]
    owners: [ PSO_DCE ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_MME
    what: Memory Management Enable
    location: [ SPS_PL3, 11 ]
    owners: [ PSO_MME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_IL
    what: Interrupt Level
    location: [ SPS_PL3, 12..13 ]
    owners: [ PSO_IL0, PSO_IL1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_VS
    what: Virtual Space
    location: [ SPS_PL3, 14..15 ]
    owners: [ PSO_VS0, PSO_VS1 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_V64
    what: Virtual 64 bits mode.
    location: [ SPS_PL3, 16 ]
    owners: [ PSO_V64 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_L2E
    what: L2 cache Enable.
    location: [ SPS_PL3, 17 ]
    owners: [ PSO_L2E ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SME
    what: Step Mode Enabled
    location: [ SPS_PL3, 18 ]
    owners: [ PSO_SME ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_SMR
    what: Step Mode Ready
    location: [ SPS_PL3, 19 ]
    owners: [ PSO_SMR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: SPS_PL3_PMJ
    what: Page Mask in JTLB.
    location: [ SPS_PL3, 20..23 ]
    owners: [ PSO_PMJ0, PSO_PMJ1, PSO_PMJ2, PSO_PMJ3 ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Configure the HW to look-up the corresponding page sizes when searching the JTLB.
  - ID: SPS_PL3_MMUP
    what: Privileged on MMU.
    location: [ SPS_PL3, 24 ]
    owners: [ PSO_MMUP ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ PSO ################
  - ID: PSO_PL0
    what: Current Privilege Level bit 0 owner
    location: [ PSO, 0..1 ]
    reset: 0
  - ID: PSO_PL1
    what: Current Privilege Level bit 1 owner
    location: [ PSO, 2..3 ]
    reset: 0
  - ID: PSO_ET
    what: Exception Taken owner
    location: [ PSO, 4..5 ]
    reset: 0
  - ID: PSO_HTD
    what: Hardware Trap Disable owner
    location: [ PSO, 6..7 ]
    reset: 0
  - ID: PSO_IE
    what: Interrupt Enable owner
    location: [ PSO, 8..9 ]
    reset: 0
  - ID: PSO_HLE
    what: Hardware Loop Enable owner
    location: [ PSO, 10..11 ]
    reset: 0
  - ID: PSO_SRE
    what: Software REserved owner
    location: [ PSO, 12..13 ]
    reset: 0
  - ID: PSO_DAUS
    what: Data Accesses Use SPS settings owner
    location: [ PSO, 14..15 ]
    reset: 0
  - ID: PSO_ICE
    what: Instruction Cache Enable owner
    location: [ PSO, 16..17 ]
    reset: 0
  - ID: PSO_USE
    what: Uncached Streaming Enable owner
    location: [ PSO, 18..19 ]
    reset: 0
  - ID: PSO_DCE
    what: Data Cache Enable owner
    location: [ PSO, 20..21 ]
    reset: 0
  - ID: PSO_MME
    what: Memory Management Enable owner
    location: [ PSO, 22..23 ]
    reset: 0
  - ID: PSO_IL0
    what: Interrupt Level bit 0 owner
    location: [ PSO, 24..25 ]
    reset: 0
  - ID: PSO_IL1
    what: Interrupt Level bit 1 owner
    location: [ PSO, 26..27 ]
    reset: 0
  - ID: PSO_VS0
    what: Virtual Space bit 0 owner
    location: [ PSO, 28..29 ]
    reset: 0
  - ID: PSO_VS1
    what: Virtual Space bit 1 owner
    location: [ PSO, 30..31 ]
    reset: 0
  - ID: PSO_V64
    what: Virtual 64 bits mode owner
    location: [ PSO, 32..33 ]
    reset: 0
  - ID: PSO_L2E
    what: L2 cache Enable owner
    location: [ PSO, 34..35 ]
    reset: 0
  - ID: PSO_SME
    what: Step Mode Enabled owner
    location: [ PSO, 36..37 ]
    reset: 0
  - ID: PSO_SMR
    what: Step Mode Ready owner
    location: [ PSO, 38..39 ]
    reset: 0
  - ID: PSO_PMJ0
    what: Page Mask in JTLB bit 0 owner
    location: [ PSO, 40..41 ]
    reset: 0
  - ID: PSO_PMJ1
    what: Page Mask in JTLB bit 1 owner
    location: [ PSO, 42..43 ]
    reset: 0
  - ID: PSO_PMJ2
    what: Page Mask in JTLB bit 2 owner
    location: [ PSO, 44..45 ]
    reset: 0
  - ID: PSO_PMJ3
    what: Page Mask in JTLB bit 3 owner
    location: [ PSO, 46..47 ]
    reset: 0
  - ID: PSO_MMUP
    what: Privileged on MMU owner.
    location: [ PSO, 48..49 ]
    reset: 0
################ PSOW ################
  - ID: PSOW_PL0
    what: Current Privilege Level bit 0 owner
    location: [ PSO, 0..1 ]
    owners: [ PSO_PL0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PL1
    what: Current Privilege Level bit 1 owner
    location: [ PSO, 2..3 ]
    owners: [ PSO_PL1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_ET
    what: Exception Taken owner
    location: [ PSO, 4..5 ]
    owners: [ PSO_ET ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_HTD
    what: Hardware Trap Disable owner
    location: [ PSO, 6..7 ]
    owners: [ PSO_HTD ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IE
    what: Interrupt Enable owner
    location: [ PSO, 8..9 ]
    owners: [ PSO_IE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_HLE
    what: Hardware Loop Enable owner
    location: [ PSO, 10..11 ]
    owners: [ PSO_HLE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SRE
    what: Software REserved owner
    location: [ PSO, 12..13 ]
    owners: [ PSO_SRE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_DAUS
    what: Data Accesses Use SPS settings owner
    location: [ PSO, 14..15 ]
    owners: [ PSO_DAUS ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_ICE
    what: Instruction Cache Enable owner
    location: [ PSO, 16..17 ]
    owners: [ PSO_ICE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_USE
    what: Uncached Streaming Enable owner
    location: [ PSO, 18..19 ]
    owners: [ PSO_USE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_DCE
    what: Data Cache Enable owner
    location: [ PSO, 20..21 ]
    owners: [ PSO_DCE ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_MME
    what: Memory Management Enable owner
    location: [ PSO, 22..23 ]
    owners: [ PSO_MME ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IL0
    what: Interrupt Level bit 0 owner
    location: [ PSO, 24..25 ]
    owners: [ PSO_IL0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_IL1
    what: Interrupt Level bit 1 owner
    location: [ PSO, 26..27 ]
    owners: [ PSO_IL1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_VS0
    what: Virtual Space bit 0 owner
    location: [ PSO, 28..29 ]
    owners: [ PSO_VS0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_VS1
    what: Virtual Space bit 1 owner
    location: [ PSO, 30..31 ]
    owners: [ PSO_VS1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_V64
    what: Virtual 64 bits mode owner
    location: [ PSO, 32..33 ]
    owners: [ PSO_V64 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_L2E
    what: L2 cache Enable owner
    location: [ PSO, 34..35 ]
    owners: [ PSO_L2E ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SME
    what: Step Mode Enabled owner
    location: [ PSO, 36..37 ]
    owners: [ PSO_SME ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_SMR
    what: Step Mode Ready owner
    location: [ PSO, 38..39 ]
    owners: [ PSO_SMR ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ0
    what: Page Mask in JTLB bit 0 owner
    location: [ PSO, 40..41 ]
    owners: [ PSO_PMJ0 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ1
    what: Page Mask in JTLB bit 1 owner
    location: [ PSO, 42..43 ]
    owners: [ PSO_PMJ1 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ2
    what: Page Mask in JTLB bit 2 owner
    location: [ PSO, 44..45 ]
    owners: [ PSO_PMJ2 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_PMJ3
    what: Page Mask in JTLB bit 3 owner
    location: [ PSO, 46..47 ]
    owners: [ PSO_PMJ3 ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
  - ID: PSOW_MMUP
    what: Privileged on MMU owner.
    location: [ PSO, 48..49 ]
    owners: [ PSO_MMUP ]
    rerrors: [ TRAP_PRIVILEGE ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PSOW
    reset: 0
################ CS ################
  - ID: CS_IC
    what: Integer Carry
    location: [ CS, 0 ]
    reset: 0
  - ID: CS_IO
    what: IEEE 754 Invalid Operation
    location: [ CS, 1 ]
    reset: 0
  - ID: CS_DZ
    what: IEEE 754 Divide by Zero
    location: [ CS, 2 ]
    reset: 0
  - ID: CS_OV
    what: IEEE 754 Overflow
    location: [ CS, 3 ]
    reset: 0
  - ID: CS_UN
    what: IEEE 754 Underflow
    location: [ CS, 4 ]
    reset: 0
  - ID: CS_IN
    what: IEEE 754 Inexact
    location: [ CS, 5 ]
    reset: 0
  - ID: CS_XIO
    what: Extension IEEE 754 Invalid Operation
    location: [ CS, 9 ]
    reset: 0
  - ID: CS_XDZ
    what: Extension IEEE 754 Divide by Zero
    location: [ CS, 10 ]
    reset: 0
  - ID: CS_XOV
    what: Extension IEEE 754 Overflow
    location: [ CS, 11 ]
    reset: 0
  - ID: CS_XUN
    what: Extension IEEE 754 Underflow
    location: [ CS, 12 ]
    reset: 0
  - ID: CS_XIN
    what: Extension IEEE 754 Inexact
    location: [ CS, 13 ]
    reset: 0
  - ID: CS_RM
    what: IEEE 754 Rounding Mode
    location: [ CS, 16..17 ]
    reset: 0
  - ID: CS_XRM
    what: Extension IEEE 754 Rounding Mode
    location: [ CS, 20..21 ]
    reset: 0
  - ID: CS_XMF
    what: eXtension ModiFied
    location: [ CS, 24 ]
    reset: 0
  - ID: CS_CC
    what: Carry Counter
    location: [ CS, 32..47 ]
    reset: 0
  - ID: CS_XDROP
    what: Extension Conversion Drop Bits
    location: [ CS, 48..53 ]
    reset: 0
  - ID: CS_XPOW2
    what: Extension FScale Power of Two
    location: [ CS, 54..59 ]
    reset: 0
################ AESPC ################
  - ID: AESPC_AESPC
    what: Arithmetic Exception Saved PC
    location: [ AESPC, 0..63 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: AESPC
    reset: 0
################ CSIT ################
  - ID: CSIT_ICIE
    what: Integer Carry Interrupt Enable
    location: [ CSIT, 0 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_IOIE
    what: IEEE 754 Invalid Operation Interrupt Enable
    location: [ CSIT, 1 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_DZIE
    what: IEEE 754 Divide by Zero Interrupt Enable
    location: [ CSIT, 2 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_OVIE
    what: IEEE 754 Overflow Interrupt Enable
    location: [ CSIT, 3 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_UNIE
    what: IEEE 754 Underflow Interrupt Enable
    location: [ CSIT, 4 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_INIE
    what: IEEE 754 Inexact Interrupt Enable
    location: [ CSIT, 5 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XIOIE
    what: Extension IEEE 754 Invalid Operation Interrupt Enable
    location: [ CSIT, 9 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XDZIE
    what: Extension IEEE 754 Divide by Zero Interrupt Enable
    location: [ CSIT, 10 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XOVIE
    what: Extension IEEE 754 Overflow Interrupt Enable
    location: [ CSIT, 11 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XUNIE
    what: Extension IEEE 754 Underflow Interrupt Enable
    location: [ CSIT, 12 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_XINIE
    what: Extension IEEE 754 Inexact Interrupt Enable
    location: [ CSIT, 13 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_AEIR
    what: Arithmetic Exception Interrupt Raised
    location: [ CSIT, 16 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_AEC
    what: Arithmetic Exception Code
    location: [ CSIT, 17..19 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: CSIT_SPCV
    what: SPC Valid
    location: [ CSIT, 20 ]
    owners: [ MO_CSIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ ES ################
## Those are common to all ECs
  - ID: ES_EC
    what: Exception Class
    location: [ ES, 0..3 ]
    reset: 4
  - ID: ES_ED
    what: Exception Details
    location: [ ES, 4..63 ]
    reset: 0
  - ID: ES_OAPL
    what: Origin Absolute PL
    location: [ ES, 4..5 ]
    reset: 0
  - ID: ES_ORPL
    what: Origin Relative PL
    location: [ ES, 6..7 ]
    reset: 0
  - ID: ES_PTAPL
    what: Primary Target Absolute PL
    location: [ ES, 8..9 ]
    reset: 0
  - ID: ES_PTRPL
    what: Primary Target Relative PL
    location: [ ES, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_ITN
    what: InTerrupt Number
    location: [ ES, 12..16 ]
    reset: 0
  - ID: ES_ITL
    what: InTerrupt Level
    location: [ ES, 17..18 ]
    reset: 0
  - ID: ES_ITI
    what: InTerrupt Info
    location: [ ES, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_SN
    what: Syscall Number
    location: [ ES, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_HTC
    what: Hardware Trap Cause
    location: [ ES, 12..16 ]
    reset: 0
  - ID: ES_SFRT
    what: SFR Trap
    location: [ ES, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_SFRI
    what: SFR Instruction
    location: [ ES, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_GPRP
    what: GPR Pointer
    location: [ ES, 21..26 ]
    reset: 0
  - ID: ES_SFRP
    what: SFR Pointer
    location: [ ES, 27..35 ]
    reset: 0
  - ID: ES_DHT
    what: Disabled Hardware Trap
    location: [ ES, 36 ]
    reset: 0
  - ID: ES_RWX
    what: Read Write Execute
    location: [ ES, 39..41 ]
    reset: 0
  - ID: ES_NTA
    what: Non-Trapping Access
    location: [ ES, 42 ]
    reset: 0
  - ID: ES_UCA
    what: Un-Cached Access
    location: [ ES, 43 ]
    reset: 0
  - ID: ES_AS
    what: Access Size
    location: [ ES, 44..49 ]
    reset: 0
  - ID: ES_BS
    what: Bundle Size
    location: [ ES, 50..53 ]
    reset: 0
  - ID: ES_DRI
    what: Data Register Index
    location: [ ES, 54..59 ]
    reset: 0
  - ID: ES_PIC
    what: Privileged Instruction Code
    location: [ ES, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_DC
    what: Debug Cause
    location: [ ES, 12..13 ]
    reset: 0
  - ID: ES_BN
    what: Breakpoint Number
    location: [ ES, 14 ]
    reset: 0
  - ID: ES_WN
    what: Watchpoint Number
    location: [ ES, 15 ]
    reset: 0
## common with hwtraps => described only once
## - ID: ES_SFRI
## what: SFR Instruction
## location: [ ES, 18..20 ]
## reset: 0
## description: >
## Encoding of the SFR access instruction
## - ID: ES_GPRP
## what: GPR Pointer
## location: [ ES, 21..26 ]
## reset: 0
## - ID: ES_SFRP
## what: SFR Pointer
## location: [ ES, 27..35 ]
## reset: 0
## - ID: ES_DHT
## what: Disabled Hardware Trap
## location: [ ES, 36 ]
## reset: 0
## - ID: ES_RWX
## what: Read Write Execute
## location: [ ES, 39..41 ]
## reset: 0
## - ID: ES_NTA
## what: Non-Trapping Access
## location: [ ES, 42 ]
## reset: 0
## - ID: ES_UCA
## what: Un-Cached Access
## location: [ ES, 43 ]
## reset: 0
## - ID: ES_AS
## what: Access Size
## location: [ ES, 44..49 ]
## reset: 0
## - ID: ES_BS
## what: Bundle Size
## location: [ ES, 50..53 ]
## reset: 0
## - ID: ES_DRI
## what: Data Register Index
## location: [ ES, 54..59 ]
## reset: 0
## - ID: ES_PIC
## what: Privileged Instruction Code
## location: [ ES, 60..63 ]
## reset: 0
################ ES_PL0 ################
## Those are common to all ECs
  - ID: ES_PL0_EC
    what: Exception Class
    location: [ ES_PL0, 0..3 ]
    reset: 4
  - ID: ES_PL0_ED
    what: Exception Details
    location: [ ES_PL0, 4..63 ]
    reset: 0
  - ID: ES_PL0_OAPL
    what: Origin Absolute PL
    location: [ ES_PL0, 4..5 ]
    reset: 0
  - ID: ES_PL0_ORPL
    what: Origin Relative PL
    location: [ ES_PL0, 6..7 ]
    reset: 0
  - ID: ES_PL0_PTAPL
    what: Target Absolute PL
    location: [ ES_PL0, 8..9 ]
    reset: 0
  - ID: ES_PL0_PTRPL
    what: Target Relative PL
    location: [ ES_PL0, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL0_ITN
    what: InTerrupt Number
    location: [ ES_PL0, 12..16 ]
    reset: 0
  - ID: ES_PL0_ITL
    what: InTerrupt Level
    location: [ ES_PL0, 17..18 ]
    reset: 0
  - ID: ES_PL0_ITI
    what: InTerrupt Info
    location: [ ES_PL0, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL0_SN
    what: Syscall Number
    location: [ ES_PL0, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL0_HTC
    what: Hardware Trap Cause
    location: [ ES_PL0, 12..16 ]
    reset: 0
  - ID: ES_PL0_SFRT
    what: SFR Trap
    location: [ ES_PL0, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL0_SFRI
    what: SFR Instruction
    location: [ ES_PL0, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL0_GPRP
    what: GPR Pointer
    location: [ ES_PL0, 21..26 ]
    reset: 0
  - ID: ES_PL0_SFRP
    what: SFR Pointer
    location: [ ES_PL0, 27..35 ]
    reset: 0
  - ID: ES_PL0_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL0, 36 ]
    reset: 0
  - ID: ES_PL0_RWX
    what: Read Write Execute
    location: [ ES_PL0, 39..41 ]
    reset: 0
  - ID: ES_PL0_NTA
    what: Non-Trapping Access
    location: [ ES_PL0, 42 ]
    reset: 0
  - ID: ES_PL0_UCA
    what: Un-Cached Access
    location: [ ES_PL0, 43 ]
    reset: 0
  - ID: ES_PL0_AS
    what: Access Size
    location: [ ES_PL0, 44..49 ]
    reset: 0
  - ID: ES_PL0_BS
    what: Bundle Size
    location: [ ES_PL0, 50..53 ]
    reset: 0
  - ID: ES_PL0_DRI
    what: Data Register Index
    location: [ ES_PL0, 54..59 ]
    reset: 0
  - ID: ES_PL0_PIC
    what: Privileged Instruction Code
    location: [ ES_PL0, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL0_DC
    what: Debug Cause
    location: [ ES_PL0, 12..13 ]
    reset: 0
  - ID: ES_PL0_BN
    what: Breakpoint Number
    location: [ ES_PL0, 14 ]
    reset: 0
  - ID: ES_PL0_WN
    what: Watchpoint Number
    location: [ ES_PL0, 15 ]
    reset: 0
################ ES_PL1 ################
## Those are common to all ECs
  - ID: ES_PL1_EC
    what: Exception Class
    location: [ ES_PL1, 0..3 ]
    reset: 4
  - ID: ES_PL1_ED
    what: Exception Details
    location: [ ES_PL1, 4..63 ]
    reset: 0
  - ID: ES_PL1_OAPL
    what: Origin Absolute PL
    location: [ ES_PL1, 4..5 ]
    reset: 0
  - ID: ES_PL1_ORPL
    what: Origin Relative PL
    location: [ ES_PL1, 6..7 ]
    reset: 0
  - ID: ES_PL1_PTAPL
    what: Target Absolute PL
    location: [ ES_PL1, 8..9 ]
    reset: 0
  - ID: ES_PL1_PTRPL
    what: Target Relative PL
    location: [ ES_PL1, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL1_ITN
    what: InTerrupt Number
    location: [ ES_PL1, 12..16 ]
    reset: 0
  - ID: ES_PL1_ITL
    what: InTerrupt Level
    location: [ ES_PL1, 17..18 ]
    reset: 0
  - ID: ES_PL1_ITI
    what: InTerrupt Info
    location: [ ES_PL1, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL1_SN
    what: Syscall Number
    location: [ ES_PL1, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL1_HTC
    what: Hardware Trap Cause
    location: [ ES_PL1, 12..16 ]
    reset: 0
  - ID: ES_PL1_SFRT
    what: SFR Trap
    location: [ ES_PL1, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL1_SFRI
    what: SFR Instruction
    location: [ ES_PL1, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL1_GPRP
    what: GPR Pointer
    location: [ ES_PL1, 21..26 ]
    reset: 0
  - ID: ES_PL1_SFRP
    what: SFR Pointer
    location: [ ES_PL1, 27..35 ]
    reset: 0
  - ID: ES_PL1_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL1, 36 ]
    reset: 0
  - ID: ES_PL1_RWX
    what: Read Write Execute
    location: [ ES_PL1, 39..41 ]
    reset: 0
  - ID: ES_PL1_NTA
    what: Non-Trapping Access
    location: [ ES_PL1, 42 ]
    reset: 0
  - ID: ES_PL1_UCA
    what: Un-Cached Access
    location: [ ES_PL1, 43 ]
    reset: 0
  - ID: ES_PL1_AS
    what: Access Size
    location: [ ES_PL1, 44..49 ]
    reset: 0
  - ID: ES_PL1_BS
    what: Bundle Size
    location: [ ES_PL1, 50..53 ]
    reset: 0
  - ID: ES_PL1_DRI
    what: Data Register Index
    location: [ ES_PL1, 54..59 ]
    reset: 0
  - ID: ES_PL1_PIC
    what: Privileged Instruction Code
    location: [ ES_PL1, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL1_DC
    what: Debug Cause
    location: [ ES_PL1, 12..13 ]
    reset: 0
  - ID: ES_PL1_BN
    what: Breakpoint Number
    location: [ ES_PL1, 14 ]
    reset: 0
  - ID: ES_PL1_WN
    what: Watchpoint Number
    location: [ ES_PL1, 15 ]
    reset: 0
################ ES_PL2 ################
## Those are common to all ECs
  - ID: ES_PL2_EC
    what: Exception Class
    location: [ ES_PL2, 0..3 ]
    reset: 4
  - ID: ES_PL2_ED
    what: Exception Details
    location: [ ES_PL2, 4..63 ]
    reset: 0
  - ID: ES_PL2_OAPL
    what: Origin Absolute PL
    location: [ ES_PL2, 4..5 ]
    reset: 0
  - ID: ES_PL2_ORPL
    what: Origin Relative PL
    location: [ ES_PL2, 6..7 ]
    reset: 0
  - ID: ES_PL2_PTAPL
    what: Target Absolute PL
    location: [ ES_PL2, 8..9 ]
    reset: 0
  - ID: ES_PL2_PTRPL
    what: Target Relative PL
    location: [ ES_PL2, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL2_ITN
    what: InTerrupt Number
    location: [ ES_PL2, 12..16 ]
    reset: 0
  - ID: ES_PL2_ITL
    what: InTerrupt Level
    location: [ ES_PL2, 17..18 ]
    reset: 0
  - ID: ES_PL2_ITI
    what: InTerrupt Info
    location: [ ES_PL2, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL2_SN
    what: Syscall Number
    location: [ ES_PL2, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL2_HTC
    what: Hardware Trap Cause
    location: [ ES_PL2, 12..16 ]
    reset: 0
  - ID: ES_PL2_SFRT
    what: SFR Trap
    location: [ ES_PL2, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL2_SFRI
    what: SFR Instruction
    location: [ ES_PL2, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL2_GPRP
    what: GPR Pointer
    location: [ ES_PL2, 21..26 ]
    reset: 0
  - ID: ES_PL2_SFRP
    what: SFR Pointer
    location: [ ES_PL2, 27..35 ]
    reset: 0
  - ID: ES_PL2_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL2, 36 ]
    reset: 0
  - ID: ES_PL2_RWX
    what: Read Write Execute
    location: [ ES_PL2, 39..41 ]
    reset: 0
  - ID: ES_PL2_NTA
    what: Non-Trapping Access
    location: [ ES_PL2, 42 ]
    reset: 0
  - ID: ES_PL2_UCA
    what: Un-Cached Access
    location: [ ES_PL2, 43 ]
    reset: 0
  - ID: ES_PL2_AS
    what: Access Size
    location: [ ES_PL2, 44..49 ]
    reset: 0
  - ID: ES_PL2_BS
    what: Bundle Size
    location: [ ES_PL2, 50..53 ]
    reset: 0
  - ID: ES_PL2_DRI
    what: Data Register Index
    location: [ ES_PL2, 54..59 ]
    reset: 0
  - ID: ES_PL2_PIC
    what: Privileged Instruction Code
    location: [ ES_PL2, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL2_DC
    what: Debug Cause
    location: [ ES_PL2, 12..13 ]
    reset: 0
  - ID: ES_PL2_BN
    what: Breakpoint Number
    location: [ ES_PL2, 14 ]
    reset: 0
  - ID: ES_PL2_WN
    what: Watchpoint Number
    location: [ ES_PL2, 15 ]
    reset: 0
################ ES_PL3 ################
## Those are common to all ECs
  - ID: ES_PL3_EC
    what: Exception Class
    location: [ ES_PL3, 0..3 ]
    reset: 4
  - ID: ES_PL3_ED
    what: Exception Details
    location: [ ES_PL3, 4..63 ]
    reset: 0
  - ID: ES_PL3_OAPL
    what: Origin Absolute PL
    location: [ ES_PL3, 4..5 ]
    reset: 0
  - ID: ES_PL3_ORPL
    what: Origin Relative PL
    location: [ ES_PL3, 6..7 ]
    reset: 0
  - ID: ES_PL3_PTAPL
    what: Target Absolute PL
    location: [ ES_PL3, 8..9 ]
    reset: 0
  - ID: ES_PL3_PTRPL
    what: Target Relative PL
    location: [ ES_PL3, 10..11 ]
    reset: 0
## Those are particular to each EC
#### Interrupts
  - ID: ES_PL3_ITN
    what: InTerrupt Number
    location: [ ES_PL3, 12..16 ]
    reset: 0
  - ID: ES_PL3_ITL
    what: InTerrupt Level
    location: [ ES_PL3, 17..18 ]
    reset: 0
  - ID: ES_PL3_ITI
    what: InTerrupt Info
    location: [ ES_PL3, 19..28 ]
    reset: 0
#### Scalls
  - ID: ES_PL3_SN
    what: Syscall Number
    location: [ ES_PL3, 12..23 ]
    reset: 0
#### HW traps
  - ID: ES_PL3_HTC
    what: Hardware Trap Cause
    location: [ ES_PL3, 12..16 ]
    reset: 0
  - ID: ES_PL3_SFRT
    what: SFR Trap
    location: [ ES_PL3, 17 ]
    reset: 0
    description: >
      Trap caused by a SFR access
  - ID: ES_PL3_SFRI
    what: SFR Instruction
    location: [ ES_PL3, 18..20 ]
    reset: 0
    description: >
      Encoding of the SFR access instruction
  - ID: ES_PL3_GPRP
    what: GPR Pointer
    location: [ ES_PL3, 21..26 ]
    reset: 0
  - ID: ES_PL3_SFRP
    what: SFR Pointer
    location: [ ES_PL3, 27..35 ]
    reset: 0
  - ID: ES_PL3_DHT
    what: Disabled Hardware Trap
    location: [ ES_PL3, 36 ]
    reset: 0
  - ID: ES_PL3_RWX
    what: Read Write Execute
    location: [ ES_PL3, 39..41 ]
    reset: 0
  - ID: ES_PL3_NTA
    what: Non-Trapping Access
    location: [ ES_PL3, 42 ]
    reset: 0
  - ID: ES_PL3_UCA
    what: Un-Cached Access
    location: [ ES_PL3, 43 ]
    reset: 0
  - ID: ES_PL3_AS
    what: Access Size
    location: [ ES_PL3, 44..49 ]
    reset: 0
  - ID: ES_PL3_BS
    what: Bundle Size
    location: [ ES_PL3, 50..53 ]
    reset: 0
  - ID: ES_PL3_DRI
    what: Data Register Index
    location: [ ES_PL3, 54..59 ]
    reset: 0
  - ID: ES_PL3_PIC
    what: Privileged Instruction Code
    location: [ ES_PL3, 60..63 ]
    reset: 0
#### debug exceptions
  - ID: ES_PL3_DC
    what: Debug Cause
    location: [ ES_PL3, 12..13 ]
    reset: 0
  - ID: ES_PL3_BN
    what: Breakpoint Number
    location: [ ES_PL3, 14 ]
    reset: 0
  - ID: ES_PL3_WN
    what: Watchpoint Number
    location: [ ES_PL3, 15 ]
    reset: 0
################ TCR ################
  - ID: TCR_T0CE
    what: Timer 0 Count Enable
    location: [ TCR, 16 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer count enable.
  - ID: TCR_T1CE
    what: Timer 1 Count Enable
    location: [ TCR, 17 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer count enable.
  - ID: TCR_T0IE
    what: Timer 0 Interrupt Enable
    location: [ TCR, 18 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer interrupt generation enable.
  - ID: TCR_T1IE
    what: Timer 1 Interrupt Enable
    location: [ TCR, 19 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer interrupt generation enable.
  - ID: TCR_T0ST
    what: Timer 0 Status
    location: [ TCR, 20 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 timer status bit.
  - ID: TCR_T1ST
    what: Timer 1 Status
    location: [ TCR, 21 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 timer status bit.
  - ID: TCR_T0SI
    what: Stop Timer 0 in Idle
    location: [ TCR, 22 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T0 Stop in Idle
  - ID: TCR_T1SI
    what: Stop Timer 1 in Idle
    location: [ TCR, 23 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      T1 Stop in Idle
  - ID: TCR_WCE
    what: Watchdog Counting Enable
    location: [ TCR, 24 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Decounting Enable
  - ID: TCR_WIE
    what: Watchdog Interrupt Enable
    location: [ TCR, 25 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Interrupt Enable
  - ID: TCR_WUI
    what: Watchdog Underflow Inform
    location: [ TCR, 26 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Underflow Inform
  - ID: TCR_WUS
    what: Watchdog Underflow Status
    location: [ TCR, 27 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Underflow Status
  - ID: TCR_WSI
    what: Watchdog Stop in Idle
    location: [ TCR, 28 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Watchdog Stop in Idle
################ PM0 ################
  - ID: PM0_PM0
    what: Performance Monitor 0
    location: [ PM0, 0..63 ]
    owners: [ MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM0
    reset: 0
################ PM1 ################
  - ID: PM1_PM1
    what: Performance Monitor 1
    location: [ PM1, 0..63 ]
    owners: [ MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM1
    reset: 0
################ PM2 ################
  - ID: PM2_PM2
    what: Performance Monitor 2
    location: [ PM2, 0..63 ]
    owners: [ MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM2
    reset: 0
################ PM3 ################
  - ID: PM3_PM3
    what: Performance Monitor 3
    location: [ PM3, 0..63 ]
    owners: [ MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PM3
    reset: 0
################ PMSA ################
  - ID: PMSA_PMSA
    what: Performance Monitor Saved Address
    location: [ PMSA, 0..63 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: PMSA
    reset: 0
################ T0V ################
  - ID: T0V_T0V
    what: Timer 0 value
    location: [ T0V, 0..63 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T0V
    reset: 0
################ T1V ################
  - ID: T1V_T1V
    what: Timer 1 value
    location: [ T1V, 0..63 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T1V
    reset: 0
################ T0R ################
  - ID: T0R_T0R
    what: Timer 0 reload value
    location: [ T0R, 0..63 ]
    owners: [ MO_T0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T0R
    reset: 0
################ T1R ################
  - ID: T1R_T1R
    what: Timer 1 reload value
    location: [ T1R, 0..63 ]
    owners: [ MO_T1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: T1R
    reset: 0
################ WDV ################
  - ID: WDV_WDV
    what: Watchdog Value
    location: [ WDV, 0..63 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: WDV
    reset: 0
################ WDR ################
  - ID: WDR_WDR
    what: Watchdog Reload Value
    location: [ WDR, 0..63 ]
    owners: [ MO_WD ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    register: WDR
    reset: 0
################ PMC ################
  - ID: PMC_PM0C
    what: PM0 Configuration
    location: [ PMC, 0..5 ]
    owners: [ MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 0 Configuration.
  - ID: PMC_PM1C
    what: PM1 Configuration
    location: [ PMC, 7..12 ]
    owners: [ MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Performance Monitor 1 configuration.
  - ID: PMC_PM2C
    what: PM2 Configuration
    location: [ PMC, 14..19 ]
    owners: [ MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 2 configuration.
  - ID: PMC_PM3C
    what: PM3 Configuration
    location: [ PMC, 21..26 ]
    owners: [ MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x2
    description: >
      Performance Monitor 3 configuration.
  - ID: PMC_SAV
    what: Saved Address Valid
    location: [ PMC, 30 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Saved Address Valid
  - ID: PMC_PM0IE
    what: PM0 Interrupt Enable
    location: [ PMC, 32 ]
    owners: [ MO_PMIT MO_PM0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM0 Interrupt Enable
  - ID: PMC_PM1IE
    what: PM1 Interrupt Enable
    location: [ PMC, 33 ]
    owners: [ MO_PMIT MO_PM1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM1 Interrupt Enable
  - ID: PMC_PM2IE
    what: PM2 Interrupt Enable
    location: [ PMC, 34 ]
    owners: [ MO_PMIT MO_PM2 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM2 Interrupt Enable
  - ID: PMC_PM3IE
    what: PM3 Interrupt Enable
    location: [ PMC, 35 ]
    owners: [ MO_PMIT MO_PM3 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PM3 Interrupt Enable
  - ID: PMC_SAT
    what: Saved Address Type
    location: [ PMC, 36..37 ]
    owners: [ MO_PMIT ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Saved Address Type
################ PMC2 ################
################ PCR ################
  - ID: PCR_PID
    what: Processing Identifier in cluster
    location: [ PCR, 0..7 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Processing Identification.
  - ID: PCR_CID
    what: Cluster Identifier in system
    location: [ PCR, 8..15 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Cluster Identification.
  - ID: PCR_MID
    what: MPPA Identifier
    location: [ PCR, 16..23 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      MPPA Indetification.
  - ID: PCR_CAR
    what: Core Architecture Revision ID
    location: [ PCR, 24..27 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x0
    description: >
      Core Architecture Revision Identifier.
  - ID: PCR_CMA
    what: Core Micro-Architecture Revision ID
    location: [ PCR, 28..31 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0x0
    description: >
      Core Micro-Architecture Revision Identifier.
  - ID: PCR_SV
    what: System-On-Chip Version
    location: [ PCR, 32..39 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      System-On-Chip Version.
  - ID: PCR_ST
    what: System-On-Chip Type
    location: [ PCR, 40..43 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      System-On-Chip Type.
  - ID: PCR_BM
    what: Boot Mode
    location: [ PCR, 44..51 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: "Hardwired"
    description: >
      Boot Mode.
  - ID: PCR_COE
    what: COprocessor Enable
    location: [ PCR, 52 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
    description: >
      Coprocessor enable.
  - ID: PCR_L1CE
    what: L1 cache Coherency Enable
    location: [ PCR, 53 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      L1 cache coherency enable.
  - ID: PCR_DSEM
    what: Data Simple Ecc exception Mode
    location: [ PCR, 54 ]
    owners: [ MO_PCR ]
    rerrors: [ READ ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Data simple ECC exception mode.
################ MMC ################
  - ID: MMC_ASN
    what: Address Space Number
    location: [ MMC, 0..8 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Address Space Number.
  - ID: MMC_S
    what: Speculative
    location: [ MMC, 9 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Speculative access.
  - ID: MMC_SNE
    what: Speculative NOMAPPING Enable
    location: [ MMC, 14 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 1
    description: >
      Enable speculative memory instruction to trigger the NOMAPPING trap.
  - ID: MMC_SPE
    what: Speculative PROTECTION Enable
    location: [ MMC, 15 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Enable speculative memory instruction to trigger the PROTECTION trap.
  - ID: MMC_PTC
    what: Protection Trap Cause
    location: [ MMC, 16..17 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Protection Trap Cause.
  - ID: MMC_SW
    what: Select Way
    location: [ MMC, 18..21 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Way we want to write to / read from.
  - ID: MMC_SS
    what: Select Set
    location: [ MMC, 22..27 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Set we want to read from.
  - ID: MMC_SB
    what: Select Buffer
    location: [ MMC, 28 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Select the Buffer (JTLB or LTLB) we want to write to / read from.
  - ID: MMC_PAR
    what: PARity error flag
    location: [ MMC, 30 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      PARity error flag, set by TLBREAD and TLBPROBE when encountering parity errors.
  - ID: MMC_E
    what: Error Flag
    location: [ MMC, 31 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      Error Flag.
################ TEL ################
  - ID: TEL_ES
    what: Entry Status
    location: [ TEL, 0..1 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_CP
    what: Cache Policy
    location: [ TEL, 2..3 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_PA
    what: Protection Attributes
    location: [ TEL, 4..7 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_PS
    what: Page Size
    location: [ TEL, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEL_FN
    what: Frame Number
    location: [ TEL, 12..39 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ TEH ################
  - ID: TEH_ASN
    what: Address Space Number
    location: [ TEH, 0..8 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_G
    what: Global page indicator
    location: [ TEH, 9 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_VS
    what: Virtual Space
    location: [ TEH, 10..11 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: TEH_PN
    what: Page Number
    location: [ TEH, 12..40 ]
    owners: [ MO_MSG ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ DC ################
  - ID: DC_BE0
    what: Breakpoint 0 Enable
    location: [ DC, 0 ]
    owners: [ DO_B0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_BR0
    what: Breakpoint 0 Range
    location: [ DC, 1..6 ]
    owners: [ DO_B0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_BE1
    what: Breakpoint 1 Enable
    location: [ DC, 7 ]
    owners: [ DO_B1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_BR1
    what: Breakpoint 1 Range
    location: [ DC, 8..13 ]
    owners: [ DO_B1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_WE0
    what: Watchpoint 0 Enable
    location: [ DC, 14 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_WR0
    what: Watchpoint 0 Range
    location: [ DC, 15..20 ]
    owners: [ DO_W0 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_WE1
    what: Watchpoint 1 Enable
    location: [ DC, 21 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: DC_WR1
    what: Watchpoint 1 Range
    location: [ DC, 22..27 ]
    owners: [ DO_W1 ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ MES ################
  - ID: MES_PSE
    what: Program Simple Ecc
    location: [ MES, 0 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      SECC detected on memory answer to the instruction cache.
  - ID: MES_PILSY
    what: Program cache Invalidated Line following pSYs error.
    location: [ MES, 1 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_PILDE
    what: Program cache Invalidated Line following pDEcc error.
    location: [ MES, 2 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_PILPA
    what: Program cache Invalidated Line following pPArity error.
    location: [ MES, 3 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DSE
    what: Data Simple Ecc
    location: [ MES, 4 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
    description: >
      SECC detected on memory answer to the data cache.
  - ID: MES_DILSY
    what: Data cache Invalidated Line following dSYs error.
    location: [ MES, 5 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DILDE
    what: Data cache Invalidated Line following dDEcc error.
    location: [ MES, 6 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
  - ID: MES_DILPA
    what: Data cache Invalidated Line following dPArity error.
    location: [ MES, 7 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DDEE
    what: Data DEcc Error.
    location: [ MES, 8 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: MES_DSYE
    what: Data dSYs Error.
    location: [ MES, 9 ]
    owners: [ MO_MES ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
################ WS ################
  - ID: WS_WU0
    what: Wake-Up 0
    location: [ WS, 0 ]
    reset: 1
  - ID: WS_WU1
    what: Wake-Up 1
    location: [ WS, 1 ]
    reset: 1
  - ID: WS_WU2
    what: Wake-Up 2
    location: [ WS, 2 ]
    reset: 1
################ IPE ################
  - ID: IPE_FE
    what: Forward Events
    location: [ IPE, 0..15 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_BE
    what: Backward Events
    location: [ IPE, 16..31 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_FM
    what: Forward Mode
    location: [ IPE, 32..47 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
  - ID: IPE_BM
    what: Backward Modes
    location: [ IPE, 48..63 ]
    owners: [ MO_SYNC ]
    rerrors: [ READ0 ]
    werrors: [ TRAP_PRIVILEGE ]
    reset: 0
RegFile:
  - ID: SFR
    what: System Function Registers
    width: 64
    dwarfIds: 64..255
    registers:
      - { ID: PC, location: [ PC, 0 ], names: [ "$pc", "$s0" ], reset: "Hardwired", raccess: "GET", waccess: "NONE", width: 64, what: "Program Counter"}
      - { ID: PS, location: [ PS, 0..31 ], names: [ "$ps", "$s1" ], raccess: "GET", waccess: "WFX", width: 32, what: "Processor State"}
      - { ID: PCR, location: [ PCR, 0..63 ], names: [ "$pcr", "$s2" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_PCR ], what: "Processing Identification"}
      - { ID: RA, location: [ SRS, 3 ], names: [ "$ra", "$s3" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Return Address"}
      - { ID: CS, location: [ CS, 0..63 ], names: [ "$cs", "$s4" ], raccess: "GET", waccess: "WFX", width: 64, what: "Compute Status"}
      - { ID: CSIT, location: [ CSIT, 0..31 ], names: [ "$csit", "$s5" ], raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_CSIT ], what: "Compute Status arithmetic interrupt"}
      - { ID: AESPC, location: [ AESPC, 0 ], names: [ "$aespc", "$s6" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_CSIT ], what: "Arithmetic Exception Saved PC"}
      - { ID: LS, location: [ SRS, 7 ], names: [ "$ls", "$s7" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Start Address"}
      - { ID: LE, location: [ SRS, 8 ], names: [ "$le", "$s8" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Exit Address"}
      - { ID: LC, location: [ SRS, 9 ], names: [ "$lc", "$s9" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Loop Counter"}
      - { ID: IPE, location: [ IPE, 0..63 ], names: [ "$ipe", "$s10" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_SYNC ], what: "Inter Processor Event"}
      - { ID: MEN, location: [ MEN, 0..15 ], names: [ "$men", "$s11" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MEN ], what: "Misc External Notifications"}
      - { ID: PMC, location: [ PMC, 0..63 ], names: [ "$pmc", "$s12" ], raccess: "GET", waccess: "WFX", width: 64, what: "Performance Monitor Control"}
      - { ID: PM0, location: [ PM0, 0 ], names: [ "$pm0", "$s13" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM0 ], what: "Performance Monitor 0"}
      - { ID: PM1, location: [ PM1, 0 ], names: [ "$pm1", "$s14" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM1 ], what: "Performance Monitor 1"}
      - { ID: PM2, location: [ PM2, 0 ], names: [ "$pm2", "$s15" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM2 ], what: "Performance Monitor 2"}
      - { ID: PM3, location: [ PM3, 0 ], names: [ "$pm3", "$s16" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PM3 ], what: "Performance Monitor 3"}
      - { ID: PMSA, location: [ PMSA, 0 ], names: [ "$pmsa", "$s17" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_PMIT ], what: "Performance Monitor Saved Address" }
      - { ID: TCR, location: [ TCR, 0..31 ], names: [ "$tcr", "$s18" ], raccess: "GET", waccess: "WFX", width: 32, what: "Timer Control"}
      - { ID: T0V, location: [ T0V, 0 ], names: [ "$t0v", "$s19" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T0 ], what: "Timer 0 value"}
      - { ID: T1V, location: [ T1V, 0 ], names: [ "$t1v", "$s20" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T1 ], what: "Timer 1 value"}
      - { ID: T0R, location: [ T0R, 0 ], names: [ "$t0r", "$s21" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T0 ], what: "Timer 0 reload value"}
      - { ID: T1R, location: [ T1R, 0 ], names: [ "$t1r", "$s22" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_T1 ], what: "Timer 1 reload value"}
      - { ID: WDV, location: [ WDV, 0 ], names: [ "$wdv", "$s23" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_WD ], what: "Watchdog Value"}
      - { ID: WDR, location: [ WDR, 0 ], names: [ "$wdr", "$s24" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ MO_WD ], what: "Watchdog Reload"}
      - { ID: ILE, location: [ ILE, 0..31 ], names: [ "$ile", "$s25" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Enable"}
      - { ID: ILL, location: [ ILL, 0..63 ], names: [ "$ill", "$s26" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Level"}
      - { ID: ILR, location: [ ILR, 0..31 ], names: [ "$ilr", "$s27" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 64, what: "Interrupt Line Request"}
      - { ID: MMC, location: [ MMC, 0..31 ], names: [ "$mmc", "$s28" ], raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_MSG ], what: "Memory Management Control"}
      - { ID: TEL, location: [ TEL, 0..63 ], names: [ "$tel", "$s29" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MSG ], what: "TLB Entry Low"}
      - { ID: TEH, location: [ TEH, 0..63 ], names: [ "$teh", "$s30" ], raccess: "GET", waccess: "WFX", width: 64, owners: [ MO_MSG ], what: "TLB Entry High"}
      - { ID: IXC, location: [ IXC, 0..63 ], names: [ "$ixc", "$s31" ], reset: "0x00000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SYO, location: [ SYO, 0..31 ], names: [ "$syo", "$s32" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Syscall Owners"}
      - { ID: HTO, location: [ HTO, 0..31 ], names: [ "$hto", "$s33" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Hardware Trap Owners"}
      - { ID: ITO, location: [ ITO, 0..63 ], names: [ "$ito", "$s34" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "Interrupt Owners"}
      - { ID: DO, location: [ DO, 0..31 ], names: [ "$do", "$s35" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 32, what: "Debug Owners"}
      - { ID: MO, location: [ MO, 0..63 ], names: [ "$mo", "$s36" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "Miscellaneous Owners"}
      - { ID: PSO, location: [ PSO, 0..63 ], names: [ "$pso", "$s37" ], reset: "0x00000000", raccess: "GET", waccess: "NONE", width: 64, what: "PS register fields Owners"}
      - { ID: TPCM0, location: [ TPCM0, 0 ], names: [ "$res38", "$s38" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCM1, location: [ TPCM1, 0 ], names: [ "$res39", "$s39" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DC, location: [ DC, 0..31 ], names: [ "$dc", "$s40" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, what: "OCE (Debug) Control"}
      - { ID: DBA0, location: [ DBA0, 0 ], names: [ "$dba0", "$s41" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B0 ], what: "Breakpoint Address 0"}
      - { ID: DBA1, location: [ DBA1, 0 ], names: [ "$dba1", "$s42" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_B1 ], what: "Breakpoint Address 1"}
      - { ID: DWA0, location: [ DWA0, 0 ], names: [ "$dwa0", "$s43" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W0 ], what: "Watchpoint Address 0"}
      - { ID: DWA1, location: [ DWA1, 0 ], names: [ "$dwa1", "$s44" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, owners: [ DO_W1 ], what: "Watchpoint Address 1"}
      - { ID: MES, location: [ MES, 0..31 ], names: [ "$mes", "$s45" ], reset: "0x00000000", raccess: "GET", waccess: "WFX", width: 32, owners: [ MO_MES ], what: "Memory Error Status"}
      - { ID: WS, location: [ WS, 0..31 ], names: [ "$ws", "$s46" ], reset: "0x00000007", raccess: "GET", waccess: "WFX", width: 32, what: "Wake-Up Status"}
      - { ID: DC0, location: [ DCV2_0, 0..63 ], names: [ "$res47", "$s47" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DC1, location: [ DCV2_1, 0..63 ], names: [ "$res48", "$s48" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DC2, location: [ DCV2_2, 0..63 ], names: [ "$res49", "$s49" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DC3, location: [ DCV2_3, 0..63 ], names: [ "$res50", "$s50" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DBA2, location: [ DBA2, 0 ], names: [ "$res51", "$s51" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DBA3, location: [ DBA3, 0 ], names: [ "$res52", "$s52" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DWA2, location: [ DWA2, 0 ], names: [ "$res53", "$s53" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: DWA3, location: [ DWA3, 0 ], names: [ "$res54", "$s54" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCM2, location: [ TPCM2, 0 ], names: [ "$res55", "$s55" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCMC, location: [ TPCMC, 0..63 ], names: [ "$res56", "$s56" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: PM4, location: [ PM4, 0 ], names: [ "$res57", "$s57" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: PM5, location: [ PM5, 0 ], names: [ "$res58", "$s58" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: PM6, location: [ PM6, 0 ], names: [ "$res59", "$s59" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: PM7, location: [ PM7, 0 ], names: [ "$res60", "$s60" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: PMC2, location: [ PMC_2, 0..63 ], names: [ "$res61", "$s61" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SRHPC, location: [ SRHPC, 0 ], names: [ "$res62", "$s62" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: FRCC, location: [ FRCC, 0 ], names: [ "$res63", "$s63" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SPC_PL<r>, location: [ SRS, 64..67 ], names: [ "$spc_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Shadow PC PL <r>"}
      - { ID: SPS_PL0, location: [ SPS_PL0, 0..31 ], names: [ "$sps_pl0", "$s68" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 0"}
      - { ID: SPS_PL1, location: [ SPS_PL1, 0..31 ], names: [ "$sps_pl1", "$s69" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 1"}
      - { ID: SPS_PL2, location: [ SPS_PL2, 0..31 ], names: [ "$sps_pl2", "$s70" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 2"}
      - { ID: SPS_PL3, location: [ SPS_PL3, 0..31 ], names: [ "$sps_pl3", "$s71" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS PL 3"}
      - { ID: EA_PL<r>, location: [ SRS, 72..75 ], names: [ "$ea_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Effective Address PL<r>"}
      - { ID: EV_PL<r>, location: [ SRS, 76..79 ], names: [ "$ev_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Exception Vector PL <r>"}
      - { ID: SR_PL<r>, location: [ SRS, 80..83 ], names: [ "$sr_pl<r>", "$s<i>" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register PL <r>"}
      - { ID: ES_PL0, location: [ ES_PL0, 0..63 ], names: [ "$es_pl0", "$s84" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 0"}
      - { ID: ES_PL1, location: [ ES_PL1, 0..63 ], names: [ "$es_pl1", "$s85" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 1"}
      - { ID: ES_PL2, location: [ ES_PL2, 0..63 ], names: [ "$es_pl2", "$s86" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 2"}
      - { ID: ES_PL3, location: [ ES_PL3, 0..63 ], names: [ "$es_pl3", "$s87" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome PL 3"}
      - { ID: SID_PL0, location: [ SID_PL0, 0..63 ], names: [ "$res88", "$s88" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SID_PL1, location: [ SID_PL1, 0..63 ], names: [ "$res89", "$s89" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SID_PL2, location: [ SID_PL2, 0..63 ], names: [ "$res90", "$s90" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SID_PL3, location: [ SID_PL3, 0..63 ], names: [ "$res91", "$s91" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SR1_PL<r>, location: [ SRS, 92..95 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SYOW, location: [ SYO, 0..31 ], names: [ "$syow", "$s96" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to SYO register"}
      - { ID: HTOW, location: [ HTO, 0..31 ], names: [ "$htow", "$s97" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to HTO register"}
      - { ID: ITOW, location: [ ITO, 0..63 ], names: [ "$itow", "$s98" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to ITO register"}
      - { ID: DOW, location: [ DO, 0..31 ], names: [ "$dow", "$s99" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 32, what: "Alias to DO register"}
      - { ID: MOW, location: [ MO, 0..63 ], names: [ "$mow", "$s100" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to MO register"}
      - { ID: PSOW, location: [ PSO, 0..63 ], names: [ "$psow", "$s101" ], reset: "0x00000000", raccess: "NONE", waccess: "WFX", width: 64, what: "Alias to PSO register"}
      - { ID: RES<i>, location: [ SRS, 102..103 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC_PL0, location: [ TPCC_PL0, 0..63 ], names: [ "$res104", "$s104" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC_PL1, location: [ TPCC_PL1, 0..63 ], names: [ "$res105", "$s105" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC_PL2, location: [ TPCC_PL2, 0..63 ], names: [ "$res106", "$s106" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC_PL3, location: [ TPCC_PL3, 0..63 ], names: [ "$res107", "$s107" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: RES<i>, location: [ SRS, 108..127 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SPC, location: [ SRS, 128 ], names: [ "$spc", "$s128" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Shadow PC alias on SPC_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 129..131 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SPS, location: [ SPS, 0..31 ], names: [ "$sps", "$s132" ], raccess: "GET", waccess: "WFX", width: 32, what: "Shadow PS alias on PS_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 133..135 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: EA, location: [ SRS, 136 ], names: [ "$ea", "$s136" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Effective Address alias on EA_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 137..139 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: EV, location: [ SRS, 140 ], names: [ "$ev", "$s140" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "Exception Vector alias on EV_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 141..143 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SR, location: [ SRS, 144 ], names: [ "$sr", "$s144" ], reset: "0x00000000", raccess: "GET", waccess: "SET", width: 64, what: "System Register alias on SR_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 145..147 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: ES, location: [ ES, 0..63 ], names: [ "$es", "$s148" ], reset: "0x00000004", raccess: "GET", waccess: "WFX", width: 64, what: "Exception Syndrome alias on ES_PL<i>"}
      - { ID: RES<i>, location: [ SRS, 149..151 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SID, location: [ SID, 0..63 ], names: [ "$res152", "$s152" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: RES<i>, location: [ SRS, 153..155 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: SR1, location: [ SRS, 156 ], names: [ "$res156", "$s156" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: RES<i>, location: [ SRS, 157..167 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: TPCC, location: [ TPCC, 0..63 ], names: [ "$res168", "$s168" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: RES<i>, location: [ SRS, 169..255 ], names: [ "$res<i>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Reserved"}
      - { ID: VSFR<r>, location: [ SRS, 256..511 ], names: [ "$vsfr<r>", "$s<i>" ], reset: "0x00000000", raccess: "NONE", waccess: "NONE", width: 64, what: "Virtual SFR <r>"}
    nativeTypes: [ Int32, UInt32, Int64, UInt64 ]
    regClass: systemReg
    execution: "SFR[%0]"
  - ID: GPR
    what: General-Purpose Registers
    width: 64
    dwarfIds: 0..63
    registers:
      - { ID: R0, location: [ GRS, 0 ], names: [ "$r0", "$r0r1.lo", "$r0r1r2r3.x", ] }
      - { ID: R1, location: [ GRS, 1 ], names: [ "$r1", "$r0r1.hi", "$r0r1r2r3.y", ] }
      - { ID: R2, location: [ GRS, 2 ], names: [ "$r2", "$r2r3.lo", "$r0r1r2r3.z", ] }
      - { ID: R3, location: [ GRS, 3 ], names: [ "$r3", "$r2r3.hi", "$r0r1r2r3.t", ] }
      - { ID: R4, location: [ GRS, 4 ], names: [ "$r4", "$r4r5.lo", "$r4r5r6r7.x", ] }
      - { ID: R5, location: [ GRS, 5 ], names: [ "$r5", "$r4r5.hi", "$r4r5r6r7.y", ] }
      - { ID: R6, location: [ GRS, 6 ], names: [ "$r6", "$r6r7.lo", "$r4r5r6r7.z", ] }
      - { ID: R7, location: [ GRS, 7 ], names: [ "$r7", "$r6r7.hi", "$r4r5r6r7.t", ] }
      - { ID: R8, location: [ GRS, 8 ], names: [ "$r8", "$r8r9.lo", "$r8r9r10r11.x", ] }
      - { ID: R9, location: [ GRS, 9 ], names: [ "$r9", "$r8r9.hi", "$r8r9r10r11.y", ] }
      - { ID: R10, location: [ GRS, 10 ], names: [ "$r10", "$r10r11.lo", "$r8r9r10r11.z", ] }
      - { ID: R11, location: [ GRS, 11 ], names: [ "$r11", "$r10r11.hi", "$r8r9r10r11.t", ] }
      - { ID: R12, location: [ GRS, 12 ], names: [ "$r12", "$sp" ] }
      - { ID: R13, location: [ GRS, 13 ], names: [ "$r13", "$tp" ] }
      - { ID: R14, location: [ GRS, 14 ], names: [ "$r14", "$fp", "$r14r15.lo" ] }
      - { ID: R15, location: [ GRS, 15 ], names: [ "$r15", "$rp", "$r14r15.hi" ] }
      - { ID: R16, location: [ GRS, 16 ], names: [ "$r16", "$r16r17.lo", "$r16r17r18r19.x", ] }
      - { ID: R17, location: [ GRS, 17 ], names: [ "$r17", "$r16r17.hi", "$r16r17r18r19.y", ] }
      - { ID: R18, location: [ GRS, 18 ], names: [ "$r18", "$r18r19.lo", "$r16r17r18r19.z", ] }
      - { ID: R19, location: [ GRS, 19 ], names: [ "$r19", "$r18r19.hi", "$r16r17r18r19.t", ] }
      - { ID: R20, location: [ GRS, 20 ], names: [ "$r20", "$r20r21.lo", "$r20r21r22r23.x", ] }
      - { ID: R21, location: [ GRS, 21 ], names: [ "$r21", "$r20r21.hi", "$r20r21r22r23.y", ] }
      - { ID: R22, location: [ GRS, 22 ], names: [ "$r22", "$r22r23.lo", "$r20r21r22r23.z", ] }
      - { ID: R23, location: [ GRS, 23 ], names: [ "$r23", "$r22r23.hi", "$r20r21r22r23.t", ] }
      - { ID: R24, location: [ GRS, 24 ], names: [ "$r24", "$r24r25.lo", "$r24r25r26r27.x", ] }
      - { ID: R25, location: [ GRS, 25 ], names: [ "$r25", "$r24r25.hi", "$r24r25r26r27.y", ] }
      - { ID: R26, location: [ GRS, 26 ], names: [ "$r26", "$r26r27.lo", "$r24r25r26r27.z", ] }
      - { ID: R27, location: [ GRS, 27 ], names: [ "$r27", "$r26r27.hi", "$r24r25r26r27.t", ] }
      - { ID: R28, location: [ GRS, 28 ], names: [ "$r28", "$r28r29.lo", "$r28r29r30r31.x", ] }
      - { ID: R29, location: [ GRS, 29 ], names: [ "$r29", "$r28r29.hi", "$r28r29r30r31.y", ] }
      - { ID: R30, location: [ GRS, 30 ], names: [ "$r30", "$r30r31.lo", "$r28r29r30r31.z", ] }
      - { ID: R31, location: [ GRS, 31 ], names: [ "$r31", "$r30r31.hi", "$r28r29r30r31.t", ] }
      - { ID: R32, location: [ GRS, 32 ], names: [ "$r32", "$r32r33.lo", "$r32r33r34r35.x", ] }
      - { ID: R33, location: [ GRS, 33 ], names: [ "$r33", "$r32r33.hi", "$r32r33r34r35.y", ] }
      - { ID: R34, location: [ GRS, 34 ], names: [ "$r34", "$r34r35.lo", "$r32r33r34r35.z", ] }
      - { ID: R35, location: [ GRS, 35 ], names: [ "$r35", "$r34r35.hi", "$r32r33r34r35.t", ] }
      - { ID: R36, location: [ GRS, 36 ], names: [ "$r36", "$r36r37.lo", "$r36r37r38r39.x", ] }
      - { ID: R37, location: [ GRS, 37 ], names: [ "$r37", "$r36r37.hi", "$r36r37r38r39.y", ] }
      - { ID: R38, location: [ GRS, 38 ], names: [ "$r38", "$r38r39.lo", "$r36r37r38r39.z", ] }
      - { ID: R39, location: [ GRS, 39 ], names: [ "$r39", "$r38r39.hi", "$r36r37r38r39.t", ] }
      - { ID: R40, location: [ GRS, 40 ], names: [ "$r40", "$r40r41.lo", "$r40r41r42r43.x", ] }
      - { ID: R41, location: [ GRS, 41 ], names: [ "$r41", "$r40r41.hi", "$r40r41r42r43.y", ] }
      - { ID: R42, location: [ GRS, 42 ], names: [ "$r42", "$r42r43.lo", "$r40r41r42r43.z", ] }
      - { ID: R43, location: [ GRS, 43 ], names: [ "$r43", "$r42r43.hi", "$r40r41r42r43.t", ] }
      - { ID: R44, location: [ GRS, 44 ], names: [ "$r44", "$r44r45.lo", "$r44r45r46r47.x", ] }
      - { ID: R45, location: [ GRS, 45 ], names: [ "$r45", "$r44r45.hi", "$r44r45r46r47.y", ] }
      - { ID: R46, location: [ GRS, 46 ], names: [ "$r46", "$r46r47.lo", "$r44r45r46r47.z", ] }
      - { ID: R47, location: [ GRS, 47 ], names: [ "$r47", "$r46r47.hi", "$r44r45r46r47.t", ] }
      - { ID: R48, location: [ GRS, 48 ], names: [ "$r48", "$r48r49.lo", "$r48r49r50r51.x", ] }
      - { ID: R49, location: [ GRS, 49 ], names: [ "$r49", "$r48r49.hi", "$r48r49r50r51.y", ] }
      - { ID: R50, location: [ GRS, 50 ], names: [ "$r50", "$r50r51.lo", "$r48r49r50r51.z", ] }
      - { ID: R51, location: [ GRS, 51 ], names: [ "$r51", "$r50r51.hi", "$r48r49r50r51.t", ] }
      - { ID: R52, location: [ GRS, 52 ], names: [ "$r52", "$r52r53.lo", "$r52r53r54r55.x", ] }
      - { ID: R53, location: [ GRS, 53 ], names: [ "$r53", "$r52r53.hi", "$r52r53r54r55.y", ] }
      - { ID: R54, location: [ GRS, 54 ], names: [ "$r54", "$r54r55.lo", "$r52r53r54r55.z", ] }
      - { ID: R55, location: [ GRS, 55 ], names: [ "$r55", "$r54r55.hi", "$r52r53r54r55.t", ] }
      - { ID: R56, location: [ GRS, 56 ], names: [ "$r56", "$r56r57.lo", "$r56r57r58r59.x", ] }
      - { ID: R57, location: [ GRS, 57 ], names: [ "$r57", "$r56r57.hi", "$r56r57r58r59.y", ] }
      - { ID: R58, location: [ GRS, 58 ], names: [ "$r58", "$r58r59.lo", "$r56r57r58r59.z", ] }
      - { ID: R59, location: [ GRS, 59 ], names: [ "$r59", "$r58r59.hi", "$r56r57r58r59.t", ] }
      - { ID: R60, location: [ GRS, 60 ], names: [ "$r60", "$r60r61.lo", "$r60r61r62r63.x", ] }
      - { ID: R61, location: [ GRS, 61 ], names: [ "$r61", "$r60r61.hi", "$r60r61r62r63.y", ] }
      - { ID: R62, location: [ GRS, 62 ], names: [ "$r62", "$r62r63.lo", "$r60r61r62r63.z", ] }
      - { ID: R63, location: [ GRS, 63 ], names: [ "$r63", "$r62r63.hi", "$r60r61r62r63.t", ] }
    nativeTypes: [ Int32, UInt32, Float32, Int64, UInt64, Float64 ]
    regClass: singleReg
    shortName: r
    execution: "GPR[%0]"
  - ID: PGR
    what: Paired General Registers
    width: 128
    registers:
      - { ID: P0, location: [ GRS, 0, 1 ], names: [ "$r0r1", "$r0r1r2r3.lo" ] }
      - { ID: P2, location: [ GRS, 2, 3 ], names: [ "$r2r3", "$r0r1r2r3.hi" ] }
      - { ID: P4, location: [ GRS, 4, 5 ], names: [ "$r4r5", "$r4r5r6r7.lo" ] }
      - { ID: P6, location: [ GRS, 6, 7 ], names: [ "$r6r7", "$r4r5r6r7.hi" ] }
      - { ID: P8, location: [ GRS, 8, 9 ], names: [ "$r8r9", "$r8r9r10r11.lo" ] }
      - { ID: P10, location: [ GRS, 10, 11 ], names: [ "$r10r11", "$r8r9r10r11.hi" ] }
      - { ID: P12, location: [ GRS, 12, 13 ], names: [ "$r12r13", "$r12r13r14r15.lo" ] }
      - { ID: P14, location: [ GRS, 14, 15 ], names: [ "$r14r15", "$r12r13r14r15.hi" ] }
      - { ID: P16, location: [ GRS, 16, 17 ], names: [ "$r16r17", "$r16r17r18r19.lo" ] }
      - { ID: P18, location: [ GRS, 18, 19 ], names: [ "$r18r19", "$r16r17r18r19.hi" ] }
      - { ID: P20, location: [ GRS, 20, 21 ], names: [ "$r20r21", "$r20r21r22r23.lo" ] }
      - { ID: P22, location: [ GRS, 22, 23 ], names: [ "$r22r23", "$r20r21r22r23.hi" ] }
      - { ID: P24, location: [ GRS, 24, 25 ], names: [ "$r24r25", "$r24r25r26r27.lo" ] }
      - { ID: P26, location: [ GRS, 26, 27 ], names: [ "$r26r27", "$r24r25r26r27.hi" ] }
      - { ID: P28, location: [ GRS, 28, 29 ], names: [ "$r28r29", "$r28r29r30r31.lo" ] }
      - { ID: P30, location: [ GRS, 30, 31 ], names: [ "$r30r31", "$r28r29r30r31.hi" ] }
      - { ID: P32, location: [ GRS, 32, 33 ], names: [ "$r32r33", "$r32r33r34r35.lo" ] }
      - { ID: P34, location: [ GRS, 34, 35 ], names: [ "$r34r35", "$r32r33r34r35.hi" ] }
      - { ID: P36, location: [ GRS, 36, 37 ], names: [ "$r36r37", "$r36r37r38r39.lo" ] }
      - { ID: P38, location: [ GRS, 38, 39 ], names: [ "$r38r39", "$r36r37r38r39.hi" ] }
      - { ID: P40, location: [ GRS, 40, 41 ], names: [ "$r40r41", "$r40r41r42r43.lo" ] }
      - { ID: P42, location: [ GRS, 42, 43 ], names: [ "$r42r43", "$r40r41r42r43.hi" ] }
      - { ID: P44, location: [ GRS, 44, 45 ], names: [ "$r44r45", "$r44r45r46r47.lo" ] }
      - { ID: P46, location: [ GRS, 46, 47 ], names: [ "$r46r47", "$r44r45r46r47.hi" ] }
      - { ID: P48, location: [ GRS, 48, 49 ], names: [ "$r48r49", "$r48r49r50r51.lo" ] }
      - { ID: P50, location: [ GRS, 50, 51 ], names: [ "$r50r51", "$r48r49r50r51.hi" ] }
      - { ID: P52, location: [ GRS, 52, 53 ], names: [ "$r52r53", "$r52r53r54r55.lo" ] }
      - { ID: P54, location: [ GRS, 54, 55 ], names: [ "$r54r55", "$r52r53r54r55.hi" ] }
      - { ID: P56, location: [ GRS, 56, 57 ], names: [ "$r56r57", "$r56r57r58r59.lo" ] }
      - { ID: P58, location: [ GRS, 58, 59 ], names: [ "$r58r59", "$r56r57r58r59.hi" ] }
      - { ID: P60, location: [ GRS, 60, 61 ], names: [ "$r60r61", "$r60r61r62r63.lo" ] }
      - { ID: P62, location: [ GRS, 62, 63 ], names: [ "$r62r63", "$r60r61r62r63.hi" ] }
    nativeTypes: [ Int128, UInt128, Float128 ]
    regClass: pairedReg
    shortName: p
    execution: "PGR[%0]"
    multi: [ singleReg, singleReg ]
  - ID: QGR
    what: Quadruple General Registers
    width: 256
    registers:
      - { ID: Q0, location: [ GRS, 0, 1, 2, 3 ], names: [ "$r0r1r2r3" ] }
      - { ID: Q4, location: [ GRS, 4, 5, 6, 7 ], names: [ "$r4r5r6r7" ] }
      - { ID: Q8, location: [ GRS, 8, 9, 10, 11 ], names: [ "$r8r9r10r11" ] }
      - { ID: Q12, location: [ GRS, 12, 13, 14, 15 ], names: [ "$r12r13r14r15" ] }
      - { ID: Q16, location: [ GRS, 16, 17, 18, 19 ], names: [ "$r16r17r18r19" ] }
      - { ID: Q20, location: [ GRS, 20, 21, 22, 23 ], names: [ "$r20r21r22r23" ] }
      - { ID: Q24, location: [ GRS, 24, 25, 26, 27 ], names: [ "$r24r25r26r27" ] }
      - { ID: Q28, location: [ GRS, 28, 29, 30, 31 ], names: [ "$r28r29r30r31" ] }
      - { ID: Q32, location: [ GRS, 32, 33, 34, 35 ], names: [ "$r32r33r34r35" ] }
      - { ID: Q36, location: [ GRS, 36, 37, 38, 39 ], names: [ "$r36r37r38r39" ] }
      - { ID: Q40, location: [ GRS, 40, 41, 42, 43 ], names: [ "$r40r41r42r43" ] }
      - { ID: Q44, location: [ GRS, 44, 45, 46, 47 ], names: [ "$r44r45r46r47" ] }
      - { ID: Q48, location: [ GRS, 48, 49, 50, 51 ], names: [ "$r48r49r50r51" ] }
      - { ID: Q52, location: [ GRS, 52, 53, 54, 55 ], names: [ "$r52r53r54r55" ] }
      - { ID: Q56, location: [ GRS, 56, 57, 58, 59 ], names: [ "$r56r57r58r59" ] }
      - { ID: Q60, location: [ GRS, 60, 61, 62, 63 ], names: [ "$r60r61r62r63" ] }
    nativeTypes: [ Int128x2, UInt128x2 ]
    regClass: quadReg
    shortName: q
    execution: "QGR[%0]"
    multi: [ singleReg, singleReg, singleReg, singleReg ]
  - ID: XCR
    what: Extension Coprocessor Registers
    width: 64
    dwarfIds: 256..511
    registers:
      - { ID: C0, location: [ XRS, 0 ], names: [ "$a0_x", "$a0.x" ] }
      - { ID: C1, location: [ XRS, 1 ], names: [ "$a0_y", "$a0.y" ] }
      - { ID: C2, location: [ XRS, 2 ], names: [ "$a0_z", "$a0.z" ] }
      - { ID: C3, location: [ XRS, 3 ], names: [ "$a0_t", "$a0.t" ] }
      - { ID: C4, location: [ XRS, 4 ], names: [ "$a1_x", "$a1.x" ] }
      - { ID: C5, location: [ XRS, 5 ], names: [ "$a1_y", "$a1.y" ] }
      - { ID: C6, location: [ XRS, 6 ], names: [ "$a1_z", "$a1.z" ] }
      - { ID: C7, location: [ XRS, 7 ], names: [ "$a1_t", "$a1.t" ] }
      - { ID: C8, location: [ XRS, 8 ], names: [ "$a2_x", "$a2.x" ] }
      - { ID: C9, location: [ XRS, 9 ], names: [ "$a2_y", "$a2.y" ] }
      - { ID: C10, location: [ XRS, 10 ], names: [ "$a2_z", "$a2.z" ] }
      - { ID: C11, location: [ XRS, 11 ], names: [ "$a2_t", "$a2.t" ] }
      - { ID: C12, location: [ XRS, 12 ], names: [ "$a3_x", "$a3.x" ] }
      - { ID: C13, location: [ XRS, 13 ], names: [ "$a3_y", "$a3.y" ] }
      - { ID: C14, location: [ XRS, 14 ], names: [ "$a3_z", "$a3.z" ] }
      - { ID: C15, location: [ XRS, 15 ], names: [ "$a3_t", "$a3.t" ] }
      - { ID: C16, location: [ XRS, 16 ], names: [ "$a4_x", "$a4.x" ] }
      - { ID: C17, location: [ XRS, 17 ], names: [ "$a4_y", "$a4.y" ] }
      - { ID: C18, location: [ XRS, 18 ], names: [ "$a4_z", "$a4.z" ] }
      - { ID: C19, location: [ XRS, 19 ], names: [ "$a4_t", "$a4.t" ] }
      - { ID: C20, location: [ XRS, 20 ], names: [ "$a5_x", "$a5.x" ] }
      - { ID: C21, location: [ XRS, 21 ], names: [ "$a5_y", "$a5.y" ] }
      - { ID: C22, location: [ XRS, 22 ], names: [ "$a5_z", "$a5.z" ] }
      - { ID: C23, location: [ XRS, 23 ], names: [ "$a5_t", "$a5.t" ] }
      - { ID: C24, location: [ XRS, 24 ], names: [ "$a6_x", "$a6.x" ] }
      - { ID: C25, location: [ XRS, 25 ], names: [ "$a6_y", "$a6.y" ] }
      - { ID: C26, location: [ XRS, 26 ], names: [ "$a6_z", "$a6.z" ] }
      - { ID: C27, location: [ XRS, 27 ], names: [ "$a6_t", "$a6.t" ] }
      - { ID: C28, location: [ XRS, 28 ], names: [ "$a7_x", "$a7.x" ] }
      - { ID: C29, location: [ XRS, 29 ], names: [ "$a7_y", "$a7.y" ] }
      - { ID: C30, location: [ XRS, 30 ], names: [ "$a7_z", "$a7.z" ] }
      - { ID: C31, location: [ XRS, 31 ], names: [ "$a7_t", "$a7.t" ] }
      - { ID: C32, location: [ XRS, 32 ], names: [ "$a8_x", "$a8.x" ] }
      - { ID: C33, location: [ XRS, 33 ], names: [ "$a8_y", "$a8.y" ] }
      - { ID: C34, location: [ XRS, 34 ], names: [ "$a8_z", "$a8.z" ] }
      - { ID: C35, location: [ XRS, 35 ], names: [ "$a8_t", "$a8.t" ] }
      - { ID: C36, location: [ XRS, 36 ], names: [ "$a9_x", "$a9.x" ] }
      - { ID: C37, location: [ XRS, 37 ], names: [ "$a9_y", "$a9.y" ] }
      - { ID: C38, location: [ XRS, 38 ], names: [ "$a9_z", "$a9.z" ] }
      - { ID: C39, location: [ XRS, 39 ], names: [ "$a9_t", "$a9.t" ] }
      - { ID: C40, location: [ XRS, 40 ], names: [ "$a10_x", "$a10.x" ] }
      - { ID: C41, location: [ XRS, 41 ], names: [ "$a10_y", "$a10.y" ] }
      - { ID: C42, location: [ XRS, 42 ], names: [ "$a10_z", "$a10.z" ] }
      - { ID: C43, location: [ XRS, 43 ], names: [ "$a10_t", "$a10.t" ] }
      - { ID: C44, location: [ XRS, 44 ], names: [ "$a11_x", "$a11.x" ] }
      - { ID: C45, location: [ XRS, 45 ], names: [ "$a11_y", "$a11.y" ] }
      - { ID: C46, location: [ XRS, 46 ], names: [ "$a11_z", "$a11.z" ] }
      - { ID: C47, location: [ XRS, 47 ], names: [ "$a11_t", "$a11.t" ] }
      - { ID: C48, location: [ XRS, 48 ], names: [ "$a12_x", "$a12.x" ] }
      - { ID: C49, location: [ XRS, 49 ], names: [ "$a12_y", "$a12.y" ] }
      - { ID: C50, location: [ XRS, 50 ], names: [ "$a12_z", "$a12.z" ] }
      - { ID: C51, location: [ XRS, 51 ], names: [ "$a12_t", "$a12.t" ] }
      - { ID: C52, location: [ XRS, 52 ], names: [ "$a13_x", "$a13.x" ] }
      - { ID: C53, location: [ XRS, 53 ], names: [ "$a13_y", "$a13.y" ] }
      - { ID: C54, location: [ XRS, 54 ], names: [ "$a13_z", "$a13.z" ] }
      - { ID: C55, location: [ XRS, 55 ], names: [ "$a13_t", "$a13.t" ] }
      - { ID: C56, location: [ XRS, 56 ], names: [ "$a14_x", "$a14.x" ] }
      - { ID: C57, location: [ XRS, 57 ], names: [ "$a14_y", "$a14.y" ] }
      - { ID: C58, location: [ XRS, 58 ], names: [ "$a14_z", "$a14.z" ] }
      - { ID: C59, location: [ XRS, 59 ], names: [ "$a14_t", "$a14.t" ] }
      - { ID: C60, location: [ XRS, 60 ], names: [ "$a15_x", "$a15.x" ] }
      - { ID: C61, location: [ XRS, 61 ], names: [ "$a15_y", "$a15.y" ] }
      - { ID: C62, location: [ XRS, 62 ], names: [ "$a15_z", "$a15.z" ] }
      - { ID: C63, location: [ XRS, 63 ], names: [ "$a15_t", "$a15.t" ] }
      - { ID: C64, location: [ XRS, 64 ], names: [ "$a16_x", "$a16.x" ] }
      - { ID: C65, location: [ XRS, 65 ], names: [ "$a16_y", "$a16.y" ] }
      - { ID: C66, location: [ XRS, 66 ], names: [ "$a16_z", "$a16.z" ] }
      - { ID: C67, location: [ XRS, 67 ], names: [ "$a16_t", "$a16.t" ] }
      - { ID: C68, location: [ XRS, 68 ], names: [ "$a17_x", "$a17.x" ] }
      - { ID: C69, location: [ XRS, 69 ], names: [ "$a17_y", "$a17.y" ] }
      - { ID: C70, location: [ XRS, 70 ], names: [ "$a17_z", "$a17.z" ] }
      - { ID: C71, location: [ XRS, 71 ], names: [ "$a17_t", "$a17.t" ] }
      - { ID: C72, location: [ XRS, 72 ], names: [ "$a18_x", "$a18.x" ] }
      - { ID: C73, location: [ XRS, 73 ], names: [ "$a18_y", "$a18.y" ] }
      - { ID: C74, location: [ XRS, 74 ], names: [ "$a18_z", "$a18.z" ] }
      - { ID: C75, location: [ XRS, 75 ], names: [ "$a18_t", "$a18.t" ] }
      - { ID: C76, location: [ XRS, 76 ], names: [ "$a19_x", "$a19.x" ] }
      - { ID: C77, location: [ XRS, 77 ], names: [ "$a19_y", "$a19.y" ] }
      - { ID: C78, location: [ XRS, 78 ], names: [ "$a19_z", "$a19.z" ] }
      - { ID: C79, location: [ XRS, 79 ], names: [ "$a19_t", "$a19.t" ] }
      - { ID: C80, location: [ XRS, 80 ], names: [ "$a20_x", "$a20.x" ] }
      - { ID: C81, location: [ XRS, 81 ], names: [ "$a20_y", "$a20.y" ] }
      - { ID: C82, location: [ XRS, 82 ], names: [ "$a20_z", "$a20.z" ] }
      - { ID: C83, location: [ XRS, 83 ], names: [ "$a20_t", "$a20.t" ] }
      - { ID: C84, location: [ XRS, 84 ], names: [ "$a21_x", "$a21.x" ] }
      - { ID: C85, location: [ XRS, 85 ], names: [ "$a21_y", "$a21.y" ] }
      - { ID: C86, location: [ XRS, 86 ], names: [ "$a21_z", "$a21.z" ] }
      - { ID: C87, location: [ XRS, 87 ], names: [ "$a21_t", "$a21.t" ] }
      - { ID: C88, location: [ XRS, 88 ], names: [ "$a22_x", "$a22.x" ] }
      - { ID: C89, location: [ XRS, 89 ], names: [ "$a22_y", "$a22.y" ] }
      - { ID: C90, location: [ XRS, 90 ], names: [ "$a22_z", "$a22.z" ] }
      - { ID: C91, location: [ XRS, 91 ], names: [ "$a22_t", "$a22.t" ] }
      - { ID: C92, location: [ XRS, 92 ], names: [ "$a23_x", "$a23.x" ] }
      - { ID: C93, location: [ XRS, 93 ], names: [ "$a23_y", "$a23.y" ] }
      - { ID: C94, location: [ XRS, 94 ], names: [ "$a23_z", "$a23.z" ] }
      - { ID: C95, location: [ XRS, 95 ], names: [ "$a23_t", "$a23.t" ] }
      - { ID: C96, location: [ XRS, 96 ], names: [ "$a24_x", "$a24.x" ] }
      - { ID: C97, location: [ XRS, 97 ], names: [ "$a24_y", "$a24.y" ] }
      - { ID: C98, location: [ XRS, 98 ], names: [ "$a24_z", "$a24.z" ] }
      - { ID: C99, location: [ XRS, 99 ], names: [ "$a24_t", "$a24.t" ] }
      - { ID: C100, location: [ XRS, 100 ], names: [ "$a25_x", "$a25.x" ] }
      - { ID: C101, location: [ XRS, 101 ], names: [ "$a25_y", "$a25.y" ] }
      - { ID: C102, location: [ XRS, 102 ], names: [ "$a25_z", "$a25.z" ] }
      - { ID: C103, location: [ XRS, 103 ], names: [ "$a25_t", "$a25.t" ] }
      - { ID: C104, location: [ XRS, 104 ], names: [ "$a26_x", "$a26.x" ] }
      - { ID: C105, location: [ XRS, 105 ], names: [ "$a26_y", "$a26.y" ] }
      - { ID: C106, location: [ XRS, 106 ], names: [ "$a26_z", "$a26.z" ] }
      - { ID: C107, location: [ XRS, 107 ], names: [ "$a26_t", "$a26.t" ] }
      - { ID: C108, location: [ XRS, 108 ], names: [ "$a27_x", "$a27.x" ] }
      - { ID: C109, location: [ XRS, 109 ], names: [ "$a27_y", "$a27.y" ] }
      - { ID: C110, location: [ XRS, 110 ], names: [ "$a27_z", "$a27.z" ] }
      - { ID: C111, location: [ XRS, 111 ], names: [ "$a27_t", "$a27.t" ] }
      - { ID: C112, location: [ XRS, 112 ], names: [ "$a28_x", "$a28.x" ] }
      - { ID: C113, location: [ XRS, 113 ], names: [ "$a28_y", "$a28.y" ] }
      - { ID: C114, location: [ XRS, 114 ], names: [ "$a28_z", "$a28.z" ] }
      - { ID: C115, location: [ XRS, 115 ], names: [ "$a28_t", "$a28.t" ] }
      - { ID: C116, location: [ XRS, 116 ], names: [ "$a29_x", "$a29.x" ] }
      - { ID: C117, location: [ XRS, 117 ], names: [ "$a29_y", "$a29.y" ] }
      - { ID: C118, location: [ XRS, 118 ], names: [ "$a29_z", "$a29.z" ] }
      - { ID: C119, location: [ XRS, 119 ], names: [ "$a29_t", "$a29.t" ] }
      - { ID: C120, location: [ XRS, 120 ], names: [ "$a30_x", "$a30.x" ] }
      - { ID: C121, location: [ XRS, 121 ], names: [ "$a30_y", "$a30.y" ] }
      - { ID: C122, location: [ XRS, 122 ], names: [ "$a30_z", "$a30.z" ] }
      - { ID: C123, location: [ XRS, 123 ], names: [ "$a30_t", "$a30.t" ] }
      - { ID: C124, location: [ XRS, 124 ], names: [ "$a31_x", "$a31.x" ] }
      - { ID: C125, location: [ XRS, 125 ], names: [ "$a31_y", "$a31.y" ] }
      - { ID: C126, location: [ XRS, 126 ], names: [ "$a31_z", "$a31.z" ] }
      - { ID: C127, location: [ XRS, 127 ], names: [ "$a31_t", "$a31.t" ] }
      - { ID: C128, location: [ XRS, 128 ], names: [ "$a32_x", "$a32.x" ] }
      - { ID: C129, location: [ XRS, 129 ], names: [ "$a32_y", "$a32.y" ] }
      - { ID: C130, location: [ XRS, 130 ], names: [ "$a32_z", "$a32.z" ] }
      - { ID: C131, location: [ XRS, 131 ], names: [ "$a32_t", "$a32.t" ] }
      - { ID: C132, location: [ XRS, 132 ], names: [ "$a33_x", "$a33.x" ] }
      - { ID: C133, location: [ XRS, 133 ], names: [ "$a33_y", "$a33.y" ] }
      - { ID: C134, location: [ XRS, 134 ], names: [ "$a33_z", "$a33.z" ] }
      - { ID: C135, location: [ XRS, 135 ], names: [ "$a33_t", "$a33.t" ] }
      - { ID: C136, location: [ XRS, 136 ], names: [ "$a34_x", "$a34.x" ] }
      - { ID: C137, location: [ XRS, 137 ], names: [ "$a34_y", "$a34.y" ] }
      - { ID: C138, location: [ XRS, 138 ], names: [ "$a34_z", "$a34.z" ] }
      - { ID: C139, location: [ XRS, 139 ], names: [ "$a34_t", "$a34.t" ] }
      - { ID: C140, location: [ XRS, 140 ], names: [ "$a35_x", "$a35.x" ] }
      - { ID: C141, location: [ XRS, 141 ], names: [ "$a35_y", "$a35.y" ] }
      - { ID: C142, location: [ XRS, 142 ], names: [ "$a35_z", "$a35.z" ] }
      - { ID: C143, location: [ XRS, 143 ], names: [ "$a35_t", "$a35.t" ] }
      - { ID: C144, location: [ XRS, 144 ], names: [ "$a36_x", "$a36.x" ] }
      - { ID: C145, location: [ XRS, 145 ], names: [ "$a36_y", "$a36.y" ] }
      - { ID: C146, location: [ XRS, 146 ], names: [ "$a36_z", "$a36.z" ] }
      - { ID: C147, location: [ XRS, 147 ], names: [ "$a36_t", "$a36.t" ] }
      - { ID: C148, location: [ XRS, 148 ], names: [ "$a37_x", "$a37.x" ] }
      - { ID: C149, location: [ XRS, 149 ], names: [ "$a37_y", "$a37.y" ] }
      - { ID: C150, location: [ XRS, 150 ], names: [ "$a37_z", "$a37.z" ] }
      - { ID: C151, location: [ XRS, 151 ], names: [ "$a37_t", "$a37.t" ] }
      - { ID: C152, location: [ XRS, 152 ], names: [ "$a38_x", "$a38.x" ] }
      - { ID: C153, location: [ XRS, 153 ], names: [ "$a38_y", "$a38.y" ] }
      - { ID: C154, location: [ XRS, 154 ], names: [ "$a38_z", "$a38.z" ] }
      - { ID: C155, location: [ XRS, 155 ], names: [ "$a38_t", "$a38.t" ] }
      - { ID: C156, location: [ XRS, 156 ], names: [ "$a39_x", "$a39.x" ] }
      - { ID: C157, location: [ XRS, 157 ], names: [ "$a39_y", "$a39.y" ] }
      - { ID: C158, location: [ XRS, 158 ], names: [ "$a39_z", "$a39.z" ] }
      - { ID: C159, location: [ XRS, 159 ], names: [ "$a39_t", "$a39.t" ] }
      - { ID: C160, location: [ XRS, 160 ], names: [ "$a40_x", "$a40.x" ] }
      - { ID: C161, location: [ XRS, 161 ], names: [ "$a40_y", "$a40.y" ] }
      - { ID: C162, location: [ XRS, 162 ], names: [ "$a40_z", "$a40.z" ] }
      - { ID: C163, location: [ XRS, 163 ], names: [ "$a40_t", "$a40.t" ] }
      - { ID: C164, location: [ XRS, 164 ], names: [ "$a41_x", "$a41.x" ] }
      - { ID: C165, location: [ XRS, 165 ], names: [ "$a41_y", "$a41.y" ] }
      - { ID: C166, location: [ XRS, 166 ], names: [ "$a41_z", "$a41.z" ] }
      - { ID: C167, location: [ XRS, 167 ], names: [ "$a41_t", "$a41.t" ] }
      - { ID: C168, location: [ XRS, 168 ], names: [ "$a42_x", "$a42.x" ] }
      - { ID: C169, location: [ XRS, 169 ], names: [ "$a42_y", "$a42.y" ] }
      - { ID: C170, location: [ XRS, 170 ], names: [ "$a42_z", "$a42.z" ] }
      - { ID: C171, location: [ XRS, 171 ], names: [ "$a42_t", "$a42.t" ] }
      - { ID: C172, location: [ XRS, 172 ], names: [ "$a43_x", "$a43.x" ] }
      - { ID: C173, location: [ XRS, 173 ], names: [ "$a43_y", "$a43.y" ] }
      - { ID: C174, location: [ XRS, 174 ], names: [ "$a43_z", "$a43.z" ] }
      - { ID: C175, location: [ XRS, 175 ], names: [ "$a43_t", "$a43.t" ] }
      - { ID: C176, location: [ XRS, 176 ], names: [ "$a44_x", "$a44.x" ] }
      - { ID: C177, location: [ XRS, 177 ], names: [ "$a44_y", "$a44.y" ] }
      - { ID: C178, location: [ XRS, 178 ], names: [ "$a44_z", "$a44.z" ] }
      - { ID: C179, location: [ XRS, 179 ], names: [ "$a44_t", "$a44.t" ] }
      - { ID: C180, location: [ XRS, 180 ], names: [ "$a45_x", "$a45.x" ] }
      - { ID: C181, location: [ XRS, 181 ], names: [ "$a45_y", "$a45.y" ] }
      - { ID: C182, location: [ XRS, 182 ], names: [ "$a45_z", "$a45.z" ] }
      - { ID: C183, location: [ XRS, 183 ], names: [ "$a45_t", "$a45.t" ] }
      - { ID: C184, location: [ XRS, 184 ], names: [ "$a46_x", "$a46.x" ] }
      - { ID: C185, location: [ XRS, 185 ], names: [ "$a46_y", "$a46.y" ] }
      - { ID: C186, location: [ XRS, 186 ], names: [ "$a46_z", "$a46.z" ] }
      - { ID: C187, location: [ XRS, 187 ], names: [ "$a46_t", "$a46.t" ] }
      - { ID: C188, location: [ XRS, 188 ], names: [ "$a47_x", "$a47.x" ] }
      - { ID: C189, location: [ XRS, 189 ], names: [ "$a47_y", "$a47.y" ] }
      - { ID: C190, location: [ XRS, 190 ], names: [ "$a47_z", "$a47.z" ] }
      - { ID: C191, location: [ XRS, 191 ], names: [ "$a47_t", "$a47.t" ] }
      - { ID: C192, location: [ XRS, 192 ], names: [ "$a48_x", "$a48.x" ] }
      - { ID: C193, location: [ XRS, 193 ], names: [ "$a48_y", "$a48.y" ] }
      - { ID: C194, location: [ XRS, 194 ], names: [ "$a48_z", "$a48.z" ] }
      - { ID: C195, location: [ XRS, 195 ], names: [ "$a48_t", "$a48.t" ] }
      - { ID: C196, location: [ XRS, 196 ], names: [ "$a49_x", "$a49.x" ] }
      - { ID: C197, location: [ XRS, 197 ], names: [ "$a49_y", "$a49.y" ] }
      - { ID: C198, location: [ XRS, 198 ], names: [ "$a49_z", "$a49.z" ] }
      - { ID: C199, location: [ XRS, 199 ], names: [ "$a49_t", "$a49.t" ] }
      - { ID: C200, location: [ XRS, 200 ], names: [ "$a50_x", "$a50.x" ] }
      - { ID: C201, location: [ XRS, 201 ], names: [ "$a50_y", "$a50.y" ] }
      - { ID: C202, location: [ XRS, 202 ], names: [ "$a50_z", "$a50.z" ] }
      - { ID: C203, location: [ XRS, 203 ], names: [ "$a50_t", "$a50.t" ] }
      - { ID: C204, location: [ XRS, 204 ], names: [ "$a51_x", "$a51.x" ] }
      - { ID: C205, location: [ XRS, 205 ], names: [ "$a51_y", "$a51.y" ] }
      - { ID: C206, location: [ XRS, 206 ], names: [ "$a51_z", "$a51.z" ] }
      - { ID: C207, location: [ XRS, 207 ], names: [ "$a51_t", "$a51.t" ] }
      - { ID: C208, location: [ XRS, 208 ], names: [ "$a52_x", "$a52.x" ] }
      - { ID: C209, location: [ XRS, 209 ], names: [ "$a52_y", "$a52.y" ] }
      - { ID: C210, location: [ XRS, 210 ], names: [ "$a52_z", "$a52.z" ] }
      - { ID: C211, location: [ XRS, 211 ], names: [ "$a52_t", "$a52.t" ] }
      - { ID: C212, location: [ XRS, 212 ], names: [ "$a53_x", "$a53.x" ] }
      - { ID: C213, location: [ XRS, 213 ], names: [ "$a53_y", "$a53.y" ] }
      - { ID: C214, location: [ XRS, 214 ], names: [ "$a53_z", "$a53.z" ] }
      - { ID: C215, location: [ XRS, 215 ], names: [ "$a53_t", "$a53.t" ] }
      - { ID: C216, location: [ XRS, 216 ], names: [ "$a54_x", "$a54.x" ] }
      - { ID: C217, location: [ XRS, 217 ], names: [ "$a54_y", "$a54.y" ] }
      - { ID: C218, location: [ XRS, 218 ], names: [ "$a54_z", "$a54.z" ] }
      - { ID: C219, location: [ XRS, 219 ], names: [ "$a54_t", "$a54.t" ] }
      - { ID: C220, location: [ XRS, 220 ], names: [ "$a55_x", "$a55.x" ] }
      - { ID: C221, location: [ XRS, 221 ], names: [ "$a55_y", "$a55.y" ] }
      - { ID: C222, location: [ XRS, 222 ], names: [ "$a55_z", "$a55.z" ] }
      - { ID: C223, location: [ XRS, 223 ], names: [ "$a55_t", "$a55.t" ] }
      - { ID: C224, location: [ XRS, 224 ], names: [ "$a56_x", "$a56.x" ] }
      - { ID: C225, location: [ XRS, 225 ], names: [ "$a56_y", "$a56.y" ] }
      - { ID: C226, location: [ XRS, 226 ], names: [ "$a56_z", "$a56.z" ] }
      - { ID: C227, location: [ XRS, 227 ], names: [ "$a56_t", "$a56.t" ] }
      - { ID: C228, location: [ XRS, 228 ], names: [ "$a57_x", "$a57.x" ] }
      - { ID: C229, location: [ XRS, 229 ], names: [ "$a57_y", "$a57.y" ] }
      - { ID: C230, location: [ XRS, 230 ], names: [ "$a57_z", "$a57.z" ] }
      - { ID: C231, location: [ XRS, 231 ], names: [ "$a57_t", "$a57.t" ] }
      - { ID: C232, location: [ XRS, 232 ], names: [ "$a58_x", "$a58.x" ] }
      - { ID: C233, location: [ XRS, 233 ], names: [ "$a58_y", "$a58.y" ] }
      - { ID: C234, location: [ XRS, 234 ], names: [ "$a58_z", "$a58.z" ] }
      - { ID: C235, location: [ XRS, 235 ], names: [ "$a58_t", "$a58.t" ] }
      - { ID: C236, location: [ XRS, 236 ], names: [ "$a59_x", "$a59.x" ] }
      - { ID: C237, location: [ XRS, 237 ], names: [ "$a59_y", "$a59.y" ] }
      - { ID: C238, location: [ XRS, 238 ], names: [ "$a59_z", "$a59.z" ] }
      - { ID: C239, location: [ XRS, 239 ], names: [ "$a59_t", "$a59.t" ] }
      - { ID: C240, location: [ XRS, 240 ], names: [ "$a60_x", "$a60.x" ] }
      - { ID: C241, location: [ XRS, 241 ], names: [ "$a60_y", "$a60.y" ] }
      - { ID: C242, location: [ XRS, 242 ], names: [ "$a60_z", "$a60.z" ] }
      - { ID: C243, location: [ XRS, 243 ], names: [ "$a60_t", "$a60.t" ] }
      - { ID: C244, location: [ XRS, 244 ], names: [ "$a61_x", "$a61.x" ] }
      - { ID: C245, location: [ XRS, 245 ], names: [ "$a61_y", "$a61.y" ] }
      - { ID: C246, location: [ XRS, 246 ], names: [ "$a61_z", "$a61.z" ] }
      - { ID: C247, location: [ XRS, 247 ], names: [ "$a61_t", "$a61.t" ] }
      - { ID: C248, location: [ XRS, 248 ], names: [ "$a62_x", "$a62.x" ] }
      - { ID: C249, location: [ XRS, 249 ], names: [ "$a62_y", "$a62.y" ] }
      - { ID: C250, location: [ XRS, 250 ], names: [ "$a62_z", "$a62.z" ] }
      - { ID: C251, location: [ XRS, 251 ], names: [ "$a62_t", "$a62.t" ] }
      - { ID: C252, location: [ XRS, 252 ], names: [ "$a63_x", "$a63.x" ] }
      - { ID: C253, location: [ XRS, 253 ], names: [ "$a63_y", "$a63.y" ] }
      - { ID: C254, location: [ XRS, 254 ], names: [ "$a63_z", "$a63.z" ] }
      - { ID: C255, location: [ XRS, 255 ], names: [ "$a63_t", "$a63.t" ] }
    nativeTypes: [ Int64, UInt64 ]
  - ID: XBR
    what: Extension Block Registers
    width: 128
    registers:
      - { ID: B0, location: [ XRS, 0, 1 ], names: [ "$a0_lo", "$a0.lo" ] }
      - { ID: B1, location: [ XRS, 2, 3 ], names: [ "$a0_hi", "$a0.hi" ] }
      - { ID: B2, location: [ XRS, 4, 5 ], names: [ "$a1_lo", "$a1.lo" ] }
      - { ID: B3, location: [ XRS, 6, 7 ], names: [ "$a1_hi", "$a1.hi" ] }
      - { ID: B4, location: [ XRS, 8, 9 ], names: [ "$a2_lo", "$a2.lo" ] }
      - { ID: B5, location: [ XRS, 10, 11 ], names: [ "$a2_hi", "$a2.hi" ] }
      - { ID: B6, location: [ XRS, 12, 13 ], names: [ "$a3_lo", "$a3.lo" ] }
      - { ID: B7, location: [ XRS, 14, 15 ], names: [ "$a3_hi", "$a3.hi" ] }
      - { ID: B8, location: [ XRS, 16, 17 ], names: [ "$a4_lo", "$a4.lo" ] }
      - { ID: B9, location: [ XRS, 18, 19 ], names: [ "$a4_hi", "$a4.hi" ] }
      - { ID: B10, location: [ XRS, 20, 21 ], names: [ "$a5_lo", "$a5.lo" ] }
      - { ID: B11, location: [ XRS, 22, 23 ], names: [ "$a5_hi", "$a5.hi" ] }
      - { ID: B12, location: [ XRS, 24, 25 ], names: [ "$a6_lo", "$a6.lo" ] }
      - { ID: B13, location: [ XRS, 26, 27 ], names: [ "$a6_hi", "$a6.hi" ] }
      - { ID: B14, location: [ XRS, 28, 29 ], names: [ "$a7_lo", "$a7.lo" ] }
      - { ID: B15, location: [ XRS, 30, 31 ], names: [ "$a7_hi", "$a7.hi" ] }
      - { ID: B16, location: [ XRS, 32, 33 ], names: [ "$a8_lo", "$a8.lo" ] }
      - { ID: B17, location: [ XRS, 34, 35 ], names: [ "$a8_hi", "$a8.hi" ] }
      - { ID: B18, location: [ XRS, 36, 37 ], names: [ "$a9_lo", "$a9.lo" ] }
      - { ID: B19, location: [ XRS, 38, 39 ], names: [ "$a9_hi", "$a9.hi" ] }
      - { ID: B20, location: [ XRS, 40, 41 ], names: [ "$a10_lo", "$a10.lo" ] }
      - { ID: B21, location: [ XRS, 42, 43 ], names: [ "$a10_hi", "$a10.hi" ] }
      - { ID: B22, location: [ XRS, 44, 45 ], names: [ "$a11_lo", "$a11.lo" ] }
      - { ID: B23, location: [ XRS, 46, 47 ], names: [ "$a11_hi", "$a11.hi" ] }
      - { ID: B24, location: [ XRS, 48, 49 ], names: [ "$a12_lo", "$a12.lo" ] }
      - { ID: B25, location: [ XRS, 50, 51 ], names: [ "$a12_hi", "$a12.hi" ] }
      - { ID: B26, location: [ XRS, 52, 53 ], names: [ "$a13_lo", "$a13.lo" ] }
      - { ID: B27, location: [ XRS, 54, 55 ], names: [ "$a13_hi", "$a13.hi" ] }
      - { ID: B28, location: [ XRS, 56, 57 ], names: [ "$a14_lo", "$a14.lo" ] }
      - { ID: B29, location: [ XRS, 58, 59 ], names: [ "$a14_hi", "$a14.hi" ] }
      - { ID: B30, location: [ XRS, 60, 61 ], names: [ "$a15_lo", "$a15.lo" ] }
      - { ID: B31, location: [ XRS, 62, 63 ], names: [ "$a15_hi", "$a15.hi" ] }
      - { ID: B32, location: [ XRS, 64, 65 ], names: [ "$a16_lo", "$a16.lo" ] }
      - { ID: B33, location: [ XRS, 66, 67 ], names: [ "$a16_hi", "$a16.hi" ] }
      - { ID: B34, location: [ XRS, 68, 69 ], names: [ "$a17_lo", "$a17.lo" ] }
      - { ID: B35, location: [ XRS, 70, 71 ], names: [ "$a17_hi", "$a17.hi" ] }
      - { ID: B36, location: [ XRS, 72, 73 ], names: [ "$a18_lo", "$a18.lo" ] }
      - { ID: B37, location: [ XRS, 74, 75 ], names: [ "$a18_hi", "$a18.hi" ] }
      - { ID: B38, location: [ XRS, 76, 77 ], names: [ "$a19_lo", "$a19.lo" ] }
      - { ID: B39, location: [ XRS, 78, 79 ], names: [ "$a19_hi", "$a19.hi" ] }
      - { ID: B40, location: [ XRS, 80, 81 ], names: [ "$a20_lo", "$a20.lo" ] }
      - { ID: B41, location: [ XRS, 82, 83 ], names: [ "$a20_hi", "$a20.hi" ] }
      - { ID: B42, location: [ XRS, 84, 85 ], names: [ "$a21_lo", "$a21.lo" ] }
      - { ID: B43, location: [ XRS, 86, 87 ], names: [ "$a21_hi", "$a21.hi" ] }
      - { ID: B44, location: [ XRS, 88, 89 ], names: [ "$a22_lo", "$a22.lo" ] }
      - { ID: B45, location: [ XRS, 90, 91 ], names: [ "$a22_hi", "$a22.hi" ] }
      - { ID: B46, location: [ XRS, 92, 93 ], names: [ "$a23_lo", "$a23.lo" ] }
      - { ID: B47, location: [ XRS, 94, 95 ], names: [ "$a23_hi", "$a23.hi" ] }
      - { ID: B48, location: [ XRS, 96, 97 ], names: [ "$a24_lo", "$a24.lo" ] }
      - { ID: B49, location: [ XRS, 98, 99 ], names: [ "$a24_hi", "$a24.hi" ] }
      - { ID: B50, location: [ XRS, 100, 101 ], names: [ "$a25_lo", "$a25.lo" ] }
      - { ID: B51, location: [ XRS, 102, 103 ], names: [ "$a25_hi", "$a25.hi" ] }
      - { ID: B52, location: [ XRS, 104, 105 ], names: [ "$a26_lo", "$a26.lo" ] }
      - { ID: B53, location: [ XRS, 106, 107 ], names: [ "$a26_hi", "$a26.hi" ] }
      - { ID: B54, location: [ XRS, 108, 109 ], names: [ "$a27_lo", "$a27.lo" ] }
      - { ID: B55, location: [ XRS, 110, 111 ], names: [ "$a27_hi", "$a27.hi" ] }
      - { ID: B56, location: [ XRS, 112, 113 ], names: [ "$a28_lo", "$a28.lo" ] }
      - { ID: B57, location: [ XRS, 114, 115 ], names: [ "$a28_hi", "$a28.hi" ] }
      - { ID: B58, location: [ XRS, 116, 117 ], names: [ "$a29_lo", "$a29.lo" ] }
      - { ID: B59, location: [ XRS, 118, 119 ], names: [ "$a29_hi", "$a29.hi" ] }
      - { ID: B60, location: [ XRS, 120, 121 ], names: [ "$a30_lo", "$a30.lo" ] }
      - { ID: B61, location: [ XRS, 122, 123 ], names: [ "$a30_hi", "$a30.hi" ] }
      - { ID: B62, location: [ XRS, 124, 125 ], names: [ "$a31_lo", "$a31.lo" ] }
      - { ID: B63, location: [ XRS, 126, 127 ], names: [ "$a31_hi", "$a31.hi" ] }
      - { ID: B64, location: [ XRS, 128, 129 ], names: [ "$a32_lo", "$a32.lo" ] }
      - { ID: B65, location: [ XRS, 130, 131 ], names: [ "$a32_hi", "$a32.hi" ] }
      - { ID: B66, location: [ XRS, 132, 133 ], names: [ "$a33_lo", "$a33.lo" ] }
      - { ID: B67, location: [ XRS, 134, 135 ], names: [ "$a33_hi", "$a33.hi" ] }
      - { ID: B68, location: [ XRS, 136, 137 ], names: [ "$a34_lo", "$a34.lo" ] }
      - { ID: B69, location: [ XRS, 138, 139 ], names: [ "$a34_hi", "$a34.hi" ] }
      - { ID: B70, location: [ XRS, 140, 141 ], names: [ "$a35_lo", "$a35.lo" ] }
      - { ID: B71, location: [ XRS, 142, 143 ], names: [ "$a35_hi", "$a35.hi" ] }
      - { ID: B72, location: [ XRS, 144, 145 ], names: [ "$a36_lo", "$a36.lo" ] }
      - { ID: B73, location: [ XRS, 146, 147 ], names: [ "$a36_hi", "$a36.hi" ] }
      - { ID: B74, location: [ XRS, 148, 149 ], names: [ "$a37_lo", "$a37.lo" ] }
      - { ID: B75, location: [ XRS, 150, 151 ], names: [ "$a37_hi", "$a37.hi" ] }
      - { ID: B76, location: [ XRS, 152, 153 ], names: [ "$a38_lo", "$a38.lo" ] }
      - { ID: B77, location: [ XRS, 154, 155 ], names: [ "$a38_hi", "$a38.hi" ] }
      - { ID: B78, location: [ XRS, 156, 157 ], names: [ "$a39_lo", "$a39.lo" ] }
      - { ID: B79, location: [ XRS, 158, 159 ], names: [ "$a39_hi", "$a39.hi" ] }
      - { ID: B80, location: [ XRS, 160, 161 ], names: [ "$a40_lo", "$a40.lo" ] }
      - { ID: B81, location: [ XRS, 162, 163 ], names: [ "$a40_hi", "$a40.hi" ] }
      - { ID: B82, location: [ XRS, 164, 165 ], names: [ "$a41_lo", "$a41.lo" ] }
      - { ID: B83, location: [ XRS, 166, 167 ], names: [ "$a41_hi", "$a41.hi" ] }
      - { ID: B84, location: [ XRS, 168, 169 ], names: [ "$a42_lo", "$a42.lo" ] }
      - { ID: B85, location: [ XRS, 170, 171 ], names: [ "$a42_hi", "$a42.hi" ] }
      - { ID: B86, location: [ XRS, 172, 173 ], names: [ "$a43_lo", "$a43.lo" ] }
      - { ID: B87, location: [ XRS, 174, 175 ], names: [ "$a43_hi", "$a43.hi" ] }
      - { ID: B88, location: [ XRS, 176, 177 ], names: [ "$a44_lo", "$a44.lo" ] }
      - { ID: B89, location: [ XRS, 178, 179 ], names: [ "$a44_hi", "$a44.hi" ] }
      - { ID: B90, location: [ XRS, 180, 181 ], names: [ "$a45_lo", "$a45.lo" ] }
      - { ID: B91, location: [ XRS, 182, 183 ], names: [ "$a45_hi", "$a45.hi" ] }
      - { ID: B92, location: [ XRS, 184, 185 ], names: [ "$a46_lo", "$a46.lo" ] }
      - { ID: B93, location: [ XRS, 186, 187 ], names: [ "$a46_hi", "$a46.hi" ] }
      - { ID: B94, location: [ XRS, 188, 189 ], names: [ "$a47_lo", "$a47.lo" ] }
      - { ID: B95, location: [ XRS, 190, 191 ], names: [ "$a47_hi", "$a47.hi" ] }
      - { ID: B96, location: [ XRS, 192, 193 ], names: [ "$a48_lo", "$a48.lo" ] }
      - { ID: B97, location: [ XRS, 194, 195 ], names: [ "$a48_hi", "$a48.hi" ] }
      - { ID: B98, location: [ XRS, 196, 197 ], names: [ "$a49_lo", "$a49.lo" ] }
      - { ID: B99, location: [ XRS, 198, 199 ], names: [ "$a49_hi", "$a49.hi" ] }
      - { ID: B100, location: [ XRS, 200, 201 ], names: [ "$a50_lo", "$a50.lo" ] }
      - { ID: B101, location: [ XRS, 202, 203 ], names: [ "$a50_hi", "$a50.hi" ] }
      - { ID: B102, location: [ XRS, 204, 205 ], names: [ "$a51_lo", "$a51.lo" ] }
      - { ID: B103, location: [ XRS, 206, 207 ], names: [ "$a51_hi", "$a51.hi" ] }
      - { ID: B104, location: [ XRS, 208, 209 ], names: [ "$a52_lo", "$a52.lo" ] }
      - { ID: B105, location: [ XRS, 210, 211 ], names: [ "$a52_hi", "$a52.hi" ] }
      - { ID: B106, location: [ XRS, 212, 213 ], names: [ "$a53_lo", "$a53.lo" ] }
      - { ID: B107, location: [ XRS, 214, 215 ], names: [ "$a53_hi", "$a53.hi" ] }
      - { ID: B108, location: [ XRS, 216, 217 ], names: [ "$a54_lo", "$a54.lo" ] }
      - { ID: B109, location: [ XRS, 218, 219 ], names: [ "$a54_hi", "$a54.hi" ] }
      - { ID: B110, location: [ XRS, 220, 221 ], names: [ "$a55_lo", "$a55.lo" ] }
      - { ID: B111, location: [ XRS, 222, 223 ], names: [ "$a55_hi", "$a55.hi" ] }
      - { ID: B112, location: [ XRS, 224, 225 ], names: [ "$a56_lo", "$a56.lo" ] }
      - { ID: B113, location: [ XRS, 226, 227 ], names: [ "$a56_hi", "$a56.hi" ] }
      - { ID: B114, location: [ XRS, 228, 229 ], names: [ "$a57_lo", "$a57.lo" ] }
      - { ID: B115, location: [ XRS, 230, 231 ], names: [ "$a57_hi", "$a57.hi" ] }
      - { ID: B116, location: [ XRS, 232, 233 ], names: [ "$a58_lo", "$a58.lo" ] }
      - { ID: B117, location: [ XRS, 234, 235 ], names: [ "$a58_hi", "$a58.hi" ] }
      - { ID: B118, location: [ XRS, 236, 237 ], names: [ "$a59_lo", "$a59.lo" ] }
      - { ID: B119, location: [ XRS, 238, 239 ], names: [ "$a59_hi", "$a59.hi" ] }
      - { ID: B120, location: [ XRS, 240, 241 ], names: [ "$a60_lo", "$a60.lo" ] }
      - { ID: B121, location: [ XRS, 242, 243 ], names: [ "$a60_hi", "$a60.hi" ] }
      - { ID: B122, location: [ XRS, 244, 245 ], names: [ "$a61_lo", "$a61.lo" ] }
      - { ID: B123, location: [ XRS, 246, 247 ], names: [ "$a61_hi", "$a61.hi" ] }
      - { ID: B124, location: [ XRS, 248, 249 ], names: [ "$a62_lo", "$a62.lo" ] }
      - { ID: B125, location: [ XRS, 250, 251 ], names: [ "$a62_hi", "$a62.hi" ] }
      - { ID: B126, location: [ XRS, 252, 253 ], names: [ "$a63_lo", "$a63.lo" ] }
      - { ID: B127, location: [ XRS, 254, 255 ], names: [ "$a63_hi", "$a63.hi" ] }
    nativeTypes: [ Int128, UInt128 ]
  - ID: XVR
    what: Extension Vector Registers
    width: 256
    registers:
      - { ID: A0, location: [ XRS, 0, 1, 2, 3 ], names: [ "$a0", "$a0a1.lo", "$a0a1a2a3.x" ] }
      - { ID: A1, location: [ XRS, 4, 5, 6, 7 ], names: [ "$a1", "$a0a1.hi", "$a0a1a2a3.y" ] }
      - { ID: A2, location: [ XRS, 8, 9, 10, 11 ], names: [ "$a2", "$a2a3.lo", "$a0a1a2a3.z" ] }
      - { ID: A3, location: [ XRS, 12, 13, 14, 15 ], names: [ "$a3", "$a2a3.hi", "$a0a1a2a3.t" ] }
      - { ID: A4, location: [ XRS, 16, 17, 18, 19 ], names: [ "$a4", "$a4a5.lo", "$a4a5a6a7.x" ] }
      - { ID: A5, location: [ XRS, 20, 21, 22, 23 ], names: [ "$a5", "$a4a5.hi", "$a4a5a6a7.y" ] }
      - { ID: A6, location: [ XRS, 24, 25, 26, 27 ], names: [ "$a6", "$a6a7.lo", "$a4a5a6a7.z" ] }
      - { ID: A7, location: [ XRS, 28, 29, 30, 31 ], names: [ "$a7", "$a6a7.hi", "$a4a5a6a7.t" ] }
      - { ID: A8, location: [ XRS, 32, 33, 34, 35 ], names: [ "$a8", "$a8a9.lo", "$a8a9a10a11.x" ] }
      - { ID: A9, location: [ XRS, 36, 37, 38, 39 ], names: [ "$a9", "$a8a9.hi", "$a8a9a10a11.y" ] }
      - { ID: A10, location: [ XRS, 40, 41, 42, 43 ], names: [ "$a10", "$a10a11.lo", "$a8a9a10a11.z" ] }
      - { ID: A11, location: [ XRS, 44, 45, 46, 47 ], names: [ "$a11", "$a10a11.hi", "$a8a9a10a11.t" ] }
      - { ID: A12, location: [ XRS, 48, 49, 50, 51 ], names: [ "$a12", "$a12a13.lo", "$a12a13a14a15.x" ] }
      - { ID: A13, location: [ XRS, 52, 53, 54, 55 ], names: [ "$a13", "$a12a13.hi", "$a12a13a14a15.y" ] }
      - { ID: A14, location: [ XRS, 56, 57, 58, 59 ], names: [ "$a14", "$a14a15.lo", "$a12a13a14a15.z" ] }
      - { ID: A15, location: [ XRS, 60, 61, 62, 63 ], names: [ "$a15", "$a14a15.hi", "$a12a13a14a15.t" ] }
      - { ID: A16, location: [ XRS, 64, 65, 66, 67 ], names: [ "$a16", "$a16a17.lo", "$a16a17a18a19.x" ] }
      - { ID: A17, location: [ XRS, 68, 69, 70, 71 ], names: [ "$a17", "$a16a17.hi", "$a16a17a18a19.y" ] }
      - { ID: A18, location: [ XRS, 72, 73, 74, 75 ], names: [ "$a18", "$a18a19.lo", "$a16a17a18a19.z" ] }
      - { ID: A19, location: [ XRS, 76, 77, 78, 79 ], names: [ "$a19", "$a18a19.hi", "$a16a17a18a19.t" ] }
      - { ID: A20, location: [ XRS, 80, 81, 82, 83 ], names: [ "$a20", "$a20a21.lo", "$a20a21a22a23.x" ] }
      - { ID: A21, location: [ XRS, 84, 85, 86, 87 ], names: [ "$a21", "$a20a21.hi", "$a20a21a22a23.y" ] }
      - { ID: A22, location: [ XRS, 88, 89, 90, 91 ], names: [ "$a22", "$a22a23.lo", "$a20a21a22a23.z" ] }
      - { ID: A23, location: [ XRS, 92, 93, 94, 95 ], names: [ "$a23", "$a22a23.hi", "$a20a21a22a23.t" ] }
      - { ID: A24, location: [ XRS, 96, 97, 98, 99 ], names: [ "$a24", "$a24a25.lo", "$a24a25a26a27.x" ] }
      - { ID: A25, location: [ XRS, 100, 101, 102, 103 ], names: [ "$a25", "$a24a25.hi", "$a24a25a26a27.y" ] }
      - { ID: A26, location: [ XRS, 104, 105, 106, 107 ], names: [ "$a26", "$a26a27.lo", "$a24a25a26a27.z" ] }
      - { ID: A27, location: [ XRS, 108, 109, 110, 111 ], names: [ "$a27", "$a26a27.hi", "$a24a25a26a27.t" ] }
      - { ID: A28, location: [ XRS, 112, 113, 114, 115 ], names: [ "$a28", "$a28a29.lo", "$a28a29a30a31.x" ] }
      - { ID: A29, location: [ XRS, 116, 117, 118, 119 ], names: [ "$a29", "$a28a29.hi", "$a28a29a30a31.y" ] }
      - { ID: A30, location: [ XRS, 120, 121, 122, 123 ], names: [ "$a30", "$a30a31.lo", "$a28a29a30a31.z" ] }
      - { ID: A31, location: [ XRS, 124, 125, 126, 127 ], names: [ "$a31", "$a30a31.hi", "$a28a29a30a31.t" ] }
      - { ID: A32, location: [ XRS, 128, 129, 130, 131 ], names: [ "$a32", "$a32a33.lo", "$a32a33a34a35.x" ] }
      - { ID: A33, location: [ XRS, 132, 133, 134, 135 ], names: [ "$a33", "$a32a33.hi", "$a32a33a34a35.y" ] }
      - { ID: A34, location: [ XRS, 136, 137, 138, 139 ], names: [ "$a34", "$a34a35.lo", "$a32a33a34a35.z" ] }
      - { ID: A35, location: [ XRS, 140, 141, 142, 143 ], names: [ "$a35", "$a34a35.hi", "$a32a33a34a35.t" ] }
      - { ID: A36, location: [ XRS, 144, 145, 146, 147 ], names: [ "$a36", "$a36a37.lo", "$a36a37a38a39.x" ] }
      - { ID: A37, location: [ XRS, 148, 149, 150, 151 ], names: [ "$a37", "$a36a37.hi", "$a36a37a38a39.y" ] }
      - { ID: A38, location: [ XRS, 152, 153, 154, 155 ], names: [ "$a38", "$a38a39.lo", "$a36a37a38a39.z" ] }
      - { ID: A39, location: [ XRS, 156, 157, 158, 159 ], names: [ "$a39", "$a38a39.hi", "$a36a37a38a39.t" ] }
      - { ID: A40, location: [ XRS, 160, 161, 162, 163 ], names: [ "$a40", "$a40a41.lo", "$a40a41a42a43.x" ] }
      - { ID: A41, location: [ XRS, 164, 165, 166, 167 ], names: [ "$a41", "$a40a41.hi", "$a40a41a42a43.y" ] }
      - { ID: A42, location: [ XRS, 168, 169, 170, 171 ], names: [ "$a42", "$a42a43.lo", "$a40a41a42a43.z" ] }
      - { ID: A43, location: [ XRS, 172, 173, 174, 175 ], names: [ "$a43", "$a42a43.hi", "$a40a41a42a43.t" ] }
      - { ID: A44, location: [ XRS, 176, 177, 178, 179 ], names: [ "$a44", "$a44a45.lo", "$a44a45a46a47.x" ] }
      - { ID: A45, location: [ XRS, 180, 181, 182, 183 ], names: [ "$a45", "$a44a45.hi", "$a44a45a46a47.y" ] }
      - { ID: A46, location: [ XRS, 184, 185, 186, 187 ], names: [ "$a46", "$a46a47.lo", "$a44a45a46a47.z" ] }
      - { ID: A47, location: [ XRS, 188, 189, 190, 191 ], names: [ "$a47", "$a46a47.hi", "$a44a45a46a47.t" ] }
      - { ID: A48, location: [ XRS, 192, 193, 194, 195 ], names: [ "$a48", "$a48a49.lo", "$a48a49a50a51.x" ] }
      - { ID: A49, location: [ XRS, 196, 197, 198, 199 ], names: [ "$a49", "$a48a49.hi", "$a48a49a50a51.y" ] }
      - { ID: A50, location: [ XRS, 200, 201, 202, 203 ], names: [ "$a50", "$a50a51.lo", "$a48a49a50a51.z" ] }
      - { ID: A51, location: [ XRS, 204, 205, 206, 207 ], names: [ "$a51", "$a50a51.hi", "$a48a49a50a51.t" ] }
      - { ID: A52, location: [ XRS, 208, 209, 210, 211 ], names: [ "$a52", "$a52a53.lo", "$a52a53a54a55.x" ] }
      - { ID: A53, location: [ XRS, 212, 213, 214, 215 ], names: [ "$a53", "$a52a53.hi", "$a52a53a54a55.y" ] }
      - { ID: A54, location: [ XRS, 216, 217, 218, 219 ], names: [ "$a54", "$a54a55.lo", "$a52a53a54a55.z" ] }
      - { ID: A55, location: [ XRS, 220, 221, 222, 223 ], names: [ "$a55", "$a54a55.hi", "$a52a53a54a55.t" ] }
      - { ID: A56, location: [ XRS, 224, 225, 226, 227 ], names: [ "$a56", "$a56a57.lo", "$a56a57a58a59.x" ] }
      - { ID: A57, location: [ XRS, 228, 229, 230, 231 ], names: [ "$a57", "$a56a57.hi", "$a56a57a58a59.y" ] }
      - { ID: A58, location: [ XRS, 232, 233, 234, 235 ], names: [ "$a58", "$a58a59.lo", "$a56a57a58a59.z" ] }
      - { ID: A59, location: [ XRS, 236, 237, 238, 239 ], names: [ "$a59", "$a58a59.hi", "$a56a57a58a59.t" ] }
      - { ID: A60, location: [ XRS, 240, 241, 242, 243 ], names: [ "$a60", "$a60a61.lo", "$a60a61a62a63.x" ] }
      - { ID: A61, location: [ XRS, 244, 245, 246, 247 ], names: [ "$a61", "$a60a61.hi", "$a60a61a62a63.y" ] }
      - { ID: A62, location: [ XRS, 248, 249, 250, 251 ], names: [ "$a62", "$a62a63.lo", "$a60a61a62a63.z" ] }
      - { ID: A63, location: [ XRS, 252, 253, 254, 255 ], names: [ "$a63", "$a62a63.hi", "$a60a61a62a63.t" ] }
    nativeTypes: [ Int128x2, UInt128x2 ]
  - ID: XTR
    what: Extension Tile Registers
    width: 512
    registers:
      - { ID: T0, location: [ XRS, 0, 1, 2, 3, 4, 5, 6, 7 ], names: [ "$a0a1", "$a0a1a2a3.lo" ] }
      - { ID: T1, location: [ XRS, 8, 9, 10, 11, 12, 13, 14, 15 ], names: [ "$a2a3", "$a0a1a2a3.hi" ] }
      - { ID: T2, location: [ XRS, 16, 17, 18, 19, 20, 21, 22, 23 ], names: [ "$a4a5", "$a4a5a6a7.lo" ] }
      - { ID: T3, location: [ XRS, 24, 25, 26, 27, 28, 29, 30, 31 ], names: [ "$a6a7", "$a4a5a6a7.hi" ] }
      - { ID: T4, location: [ XRS, 32, 33, 34, 35, 36, 37, 38, 39 ], names: [ "$a8a9", "$a8a9a10a11.lo" ] }
      - { ID: T5, location: [ XRS, 40, 41, 42, 43, 44, 45, 46, 47 ], names: [ "$a10a11", "$a8a9a10a11.hi" ] }
      - { ID: T6, location: [ XRS, 48, 49, 50, 51, 52, 53, 54, 55 ], names: [ "$a12a13", "$a12a13a14a15.lo" ] }
      - { ID: T7, location: [ XRS, 56, 57, 58, 59, 60, 61, 62, 63 ], names: [ "$a14a15", "$a12a13a14a15.hi" ] }
      - { ID: T8, location: [ XRS, 64, 65, 66, 67, 68, 69, 70, 71 ], names: [ "$a16a17", "$a16a17a18a19.lo" ] }
      - { ID: T9, location: [ XRS, 72, 73, 74, 75, 76, 77, 78, 79 ], names: [ "$a18a19", "$a16a17a18a19.hi" ] }
      - { ID: T10, location: [ XRS, 80, 81, 82, 83, 84, 85, 86, 87 ], names: [ "$a20a21", "$a20a21a22a23.lo" ] }
      - { ID: T11, location: [ XRS, 88, 89, 90, 91, 92, 93, 94, 95 ], names: [ "$a22a23", "$a20a21a22a23.hi" ] }
      - { ID: T12, location: [ XRS, 96, 97, 98, 99, 100, 101, 102, 103 ], names: [ "$a24a25", "$a24a25a26a27.lo" ] }
      - { ID: T13, location: [ XRS, 104, 105, 106, 107, 108, 109, 110, 111 ], names: [ "$a26a27", "$a24a25a26a27.hi" ] }
      - { ID: T14, location: [ XRS, 112, 113, 114, 115, 116, 117, 118, 119 ], names: [ "$a28a29", "$a28a29a30a31.lo" ] }
      - { ID: T15, location: [ XRS, 120, 121, 122, 123, 124, 125, 126, 127 ], names: [ "$a30a31", "$a28a29a30a31.hi" ] }
      - { ID: T16, location: [ XRS, 128, 129, 130, 131, 132, 133, 134, 135 ], names: [ "$a32a33", "$a32a33a34a35.lo" ] }
      - { ID: T17, location: [ XRS, 136, 137, 138, 139, 140, 141, 142, 143 ], names: [ "$a34a35", "$a32a33a34a35.hi" ] }
      - { ID: T18, location: [ XRS, 144, 145, 146, 147, 148, 149, 150, 151 ], names: [ "$a36a37", "$a36a37a38a39.lo" ] }
      - { ID: T19, location: [ XRS, 152, 153, 154, 155, 156, 157, 158, 159 ], names: [ "$a38a39", "$a36a37a38a39.hi" ] }
      - { ID: T20, location: [ XRS, 160, 161, 162, 163, 164, 165, 166, 167 ], names: [ "$a40a41", "$a40a41a42a43.lo" ] }
      - { ID: T21, location: [ XRS, 168, 169, 170, 171, 172, 173, 174, 175 ], names: [ "$a42a43", "$a40a41a42a43.hi" ] }
      - { ID: T22, location: [ XRS, 176, 177, 178, 179, 180, 181, 182, 183 ], names: [ "$a44a45", "$a44a45a46a47.lo" ] }
      - { ID: T23, location: [ XRS, 184, 185, 186, 187, 188, 189, 190, 191 ], names: [ "$a46a47", "$a44a45a46a47.hi" ] }
      - { ID: T24, location: [ XRS, 192, 193, 194, 195, 196, 197, 198, 199 ], names: [ "$a48a49", "$a48a49a50a51.lo" ] }
      - { ID: T25, location: [ XRS, 200, 201, 202, 203, 204, 205, 206, 207 ], names: [ "$a50a51", "$a48a49a50a51.hi" ] }
      - { ID: T26, location: [ XRS, 208, 209, 210, 211, 212, 213, 214, 215 ], names: [ "$a52a53", "$a52a53a54a55.lo" ] }
      - { ID: T27, location: [ XRS, 216, 217, 218, 219, 220, 221, 222, 223 ], names: [ "$a54a55", "$a52a53a54a55.hi" ] }
      - { ID: T28, location: [ XRS, 224, 225, 226, 227, 228, 229, 230, 231 ], names: [ "$a56a57", "$a56a57a58a59.lo" ] }
      - { ID: T29, location: [ XRS, 232, 233, 234, 235, 236, 237, 238, 239 ], names: [ "$a58a59", "$a56a57a58a59.hi" ] }
      - { ID: T30, location: [ XRS, 240, 241, 242, 243, 244, 245, 246, 247 ], names: [ "$a60a61", "$a60a61a62a63.lo" ] }
      - { ID: T31, location: [ XRS, 248, 249, 250, 251, 252, 253, 254, 255 ], names: [ "$a62a63", "$a60a61a62a63.hi" ] }
    nativeTypes: [ Int128x4, UInt128x4 ]
  - ID: XMR
    what: Extension Matrix Registers
    width: 1024
    registers:
      - { ID: M0, location: [ XRS, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ], names: [ "$a0a1a2a3" ] }
      - { ID: M1, location: [ XRS, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ], names: [ "$a4a5a6a7" ] }
      - { ID: M2, location: [ XRS, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 ], names: [ "$a8a9a10a11" ] }
      - { ID: M3, location: [ XRS, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 ], names: [ "$a12a13a14a15" ] }
      - { ID: M4, location: [ XRS, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 ], names: [ "$a16a17a18a19" ] }
      - { ID: M5, location: [ XRS, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95 ], names: [ "$a20a21a22a23" ] }
      - { ID: M6, location: [ XRS, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111 ], names: [ "$a24a25a26a27" ] }
      - { ID: M7, location: [ XRS, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127 ], names: [ "$a28a29a30a31" ] }
      - { ID: M8, location: [ XRS, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143 ], names: [ "$a32a33a34a35" ] }
      - { ID: M9, location: [ XRS, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159 ], names: [ "$a36a37a38a39" ] }
      - { ID: M10, location: [ XRS, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175 ], names: [ "$a40a41a42a43" ] }
      - { ID: M11, location: [ XRS, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191 ], names: [ "$a44a45a46a47" ] }
      - { ID: M12, location: [ XRS, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207 ], names: [ "$a48a49a50a51" ] }
      - { ID: M13, location: [ XRS, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223 ], names: [ "$a52a53a54a55" ] }
      - { ID: M14, location: [ XRS, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239 ], names: [ "$a56a57a58a59" ] }
      - { ID: M15, location: [ XRS, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 ], names: [ "$a60a61a62a63" ] }
    nativeTypes: [ Int128x8, UInt128x8 ]
  - ID: X2R
    what: Extension 2-Register Buffer
    width: 0
    registers:
      - { ID: G0, location: [ XRS, 0 ], names: [ "$a0..a1" ] }
      - { ID: G1, location: [ XRS, 8 ], names: [ "$a2..a3" ] }
      - { ID: G2, location: [ XRS, 16 ], names: [ "$a4..a5" ] }
      - { ID: G3, location: [ XRS, 24 ], names: [ "$a6..a7" ] }
      - { ID: G4, location: [ XRS, 32 ], names: [ "$a8..a9" ] }
      - { ID: G5, location: [ XRS, 40 ], names: [ "$a10..a11" ] }
      - { ID: G6, location: [ XRS, 48 ], names: [ "$a12..a13" ] }
      - { ID: G7, location: [ XRS, 56 ], names: [ "$a14..a15" ] }
      - { ID: G8, location: [ XRS, 64 ], names: [ "$a16..a17" ] }
      - { ID: G9, location: [ XRS, 72 ], names: [ "$a18..a19" ] }
      - { ID: G10, location: [ XRS, 80 ], names: [ "$a20..a21" ] }
      - { ID: G11, location: [ XRS, 88 ], names: [ "$a22..a23" ] }
      - { ID: G12, location: [ XRS, 96 ], names: [ "$a24..a25" ] }
      - { ID: G13, location: [ XRS, 104 ], names: [ "$a26..a27" ] }
      - { ID: G14, location: [ XRS, 112 ], names: [ "$a28..a29" ] }
      - { ID: G15, location: [ XRS, 120 ], names: [ "$a30..a31" ] }
      - { ID: G16, location: [ XRS, 128 ], names: [ "$a32..a33" ] }
      - { ID: G17, location: [ XRS, 136 ], names: [ "$a34..a35" ] }
      - { ID: G18, location: [ XRS, 144 ], names: [ "$a36..a37" ] }
      - { ID: G19, location: [ XRS, 152 ], names: [ "$a38..a39" ] }
      - { ID: G20, location: [ XRS, 160 ], names: [ "$a40..a41" ] }
      - { ID: G21, location: [ XRS, 168 ], names: [ "$a42..a43" ] }
      - { ID: G22, location: [ XRS, 176 ], names: [ "$a44..a45" ] }
      - { ID: G23, location: [ XRS, 184 ], names: [ "$a46..a47" ] }
      - { ID: G24, location: [ XRS, 192 ], names: [ "$a48..a49" ] }
      - { ID: G25, location: [ XRS, 200 ], names: [ "$a50..a51" ] }
      - { ID: G26, location: [ XRS, 208 ], names: [ "$a52..a53" ] }
      - { ID: G27, location: [ XRS, 216 ], names: [ "$a54..a55" ] }
      - { ID: G28, location: [ XRS, 224 ], names: [ "$a56..a57" ] }
      - { ID: G29, location: [ XRS, 232 ], names: [ "$a58..a59" ] }
      - { ID: G30, location: [ XRS, 240 ], names: [ "$a60..a61" ] }
      - { ID: G31, location: [ XRS, 248 ], names: [ "$a62..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer2Reg
    shortName: g
    execution: "X2R[%0]"
  - ID: X4R
    what: Extension 4-Register Buffer
    width: 0
    registers:
      - { ID: H0, location: [ XRS, 0 ], names: [ "$a0..a3" ] }
      - { ID: H1, location: [ XRS, 16 ], names: [ "$a4..a7" ] }
      - { ID: H2, location: [ XRS, 32 ], names: [ "$a8..a11" ] }
      - { ID: H3, location: [ XRS, 48 ], names: [ "$a12..a15" ] }
      - { ID: H4, location: [ XRS, 64 ], names: [ "$a16..a19" ] }
      - { ID: H5, location: [ XRS, 80 ], names: [ "$a20..a23" ] }
      - { ID: H6, location: [ XRS, 96 ], names: [ "$a24..a27" ] }
      - { ID: H7, location: [ XRS, 112 ], names: [ "$a28..a31" ] }
      - { ID: H8, location: [ XRS, 128 ], names: [ "$a32..a35" ] }
      - { ID: H9, location: [ XRS, 144 ], names: [ "$a36..a39" ] }
      - { ID: H10, location: [ XRS, 160 ], names: [ "$a40..a43" ] }
      - { ID: H11, location: [ XRS, 176 ], names: [ "$a44..a47" ] }
      - { ID: H12, location: [ XRS, 192 ], names: [ "$a48..a51" ] }
      - { ID: H13, location: [ XRS, 208 ], names: [ "$a52..a55" ] }
      - { ID: H14, location: [ XRS, 224 ], names: [ "$a56..a59" ] }
      - { ID: H15, location: [ XRS, 240 ], names: [ "$a60..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer4Reg
    shortName: h
    execution: "X4R[%0]"
  - ID: X8R
    what: Extension 8-Register Buffer
    width: 0
    registers:
      - { ID: I0, location: [ XRS, 0 ], names: [ "$a0..a7" ] }
      - { ID: I1, location: [ XRS, 32 ], names: [ "$a8..a15" ] }
      - { ID: I2, location: [ XRS, 64 ], names: [ "$a16..a23" ] }
      - { ID: I3, location: [ XRS, 96 ], names: [ "$a24..a31" ] }
      - { ID: I4, location: [ XRS, 128 ], names: [ "$a32..a39" ] }
      - { ID: I5, location: [ XRS, 160 ], names: [ "$a40..a47" ] }
      - { ID: I6, location: [ XRS, 192 ], names: [ "$a48..a55" ] }
      - { ID: I7, location: [ XRS, 224 ], names: [ "$a56..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer8Reg
    shortName: i
    execution: "X8R[%0]"
  - ID: X16R
    what: Extension 16-Register Buffer
    width: 0
    registers:
      - { ID: J0, location: [ XRS, 0 ], names: [ "$a0..a15" ] }
      - { ID: J1, location: [ XRS, 64 ], names: [ "$a16..a31" ] }
      - { ID: J2, location: [ XRS, 128 ], names: [ "$a32..a47" ] }
      - { ID: J3, location: [ XRS, 192 ], names: [ "$a48..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer16Reg
    shortName: j
    execution: "X16R[%0]"
  - ID: X32R
    what: Extension 32-Register Buffer
    width: 0
    registers:
      - { ID: K0, location: [ XRS, 0 ], names: [ "$a0..a31" ] }
      - { ID: K1, location: [ XRS, 128 ], names: [ "$a32..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer32Reg
    shortName: k
    execution: "X32R[%0]"
  - ID: X64R
    what: Extension 64-Register Buffer
    width: 0
    registers:
      - { ID: L0, location: [ XRS, 0 ], names: [ "$a0..a63" ] }
    nativeTypes: [ Void ]
    regClass: buffer64Reg
    shortName: l
    execution: "X64R[%0]"
Relocation:
  - ID: rel16
    what: 16 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_16 ]
    elfIds: [ 1 ]
    fields: [ HALF ]
  - ID: rel32
    what: 32 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_32 ]
    elfIds: [ 2 ]
    fields: [ WORD ]
  - ID: rel64
    what: 64 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_64 ]
    elfIds: [ 3 ]
    fields: [ DOUBLE ]
  - ID: pcrel_signed16
    what: extended 16 bits PC relative address
    overflow: Signed
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S16_PCREL ]
    elfIds: [ 4 ]
    fields: [ signed16 ]
    operands: [ signed16 ]
  - ID: pcrel17
    what: extended 17 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL17 ]
    elfIds: [ 5 ]
    fields: [ pcrel17 ]
    operands: [ pcrel17 ]
  - ID: pcrel27
    what: extended 27 bits relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL27 ]
    elfIds: [ 6 ]
    fields: [ pcrel27 ]
    operands: [ pcrel27 ]
  - ID: pcrel32
    what: 32 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_32_PCREL ]
    elfIds: [ 7 ]
    fields: [ WORD ]
  - ID: pcrel_signed37
    what: extended 37 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S37_PCREL_UP27, R_KVX_S37_PCREL_LO10 ]
    elfIds: [ 9, 8 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: pcrel_signed43
    what: extended 43 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S43_PCREL_EX6, R_KVX_S43_PCREL_UP27, R_KVX_S43_PCREL_LO10 ]
    elfIds: [ 12, 11, 10 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: pcrel_signed64
    what: 64 bits PC relative relocation on symbol + addend
    syntax: '@pcrel'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S64_PCREL_EX27, R_KVX_S64_PCREL_UP27, R_KVX_S64_PCREL_LO10 ]
    elfIds: [ 15, 14, 13 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: pcrel64
    what: 64 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_64_PCREL ]
    elfIds: [ 16 ]
    fields: [ DOUBLE ]
  - ID: signed16
    what: extended 16 bits relocation on symbol + addend
    overflow: Signed
    type: Rel_s_a
    linker: [ R_KVX_S16 ]
    elfIds: [ 17 ]
    fields: [ signed16 ]
    operands: [ signed16 ]
  - ID: signed32
    what: extended 32 bits relocation on symbol + addend
    syntax: '@signed32'
    type: Rel_s_a
    linker: [ R_KVX_S32_UP27, R_KVX_S32_LO5 ]
    elfIds: [ 19, 18 ]
    fields: [ upper27, lower5 ]
    operands: [ upper27_lower5 ]
  - ID: signed37
    what: extended 37 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S37_UP27, R_KVX_S37_LO10 ]
    elfIds: [ 21, 20 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotoff_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_GOTOFF_UP27, R_KVX_S37_GOTOFF_LO10 ]
    elfIds: [ 23, 22 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotoff_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_GOTOFF_EX6, R_KVX_S43_GOTOFF_UP27, R_KVX_S43_GOTOFF_LO10 ]
    elfIds: [ 26, 25, 24 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: gotoff_32
    what: 32 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_32_GOTOFF ]
    elfIds: [ 27 ]
    fields: [ WORD ]
  - ID: gotoff_64
    what: 64 bits GOT relative relocation on symbol + addend
    syntax: '@gotoff'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_64_GOTOFF ]
    elfIds: [ 28 ]
    fields: [ DOUBLE ]
  - ID: got_32
    what: 32 bits GOT relative relocation on symbol + addend
    overflow: Unsigned
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_32_GOT ]
    elfIds: [ 29 ]
    fields: [ WORD ]
  - ID: got_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_GOT_UP27, R_KVX_S37_GOT_LO10 ]
    elfIds: [ 31, 30 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: got_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_GOT_EX6, R_KVX_S43_GOT_UP27, R_KVX_S43_GOT_LO10 ]
    elfIds: [ 34, 33, 32 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: got_64
    what: 64 bits GOT relative relocation on symbol + addend
    syntax: '@got'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_64_GOT ]
    elfIds: [ 35 ]
    fields: [ DOUBLE ]
  - ID: glob_dat
    what: pointer sized GOT entry
    underflow: 1
    type: Rel_s
    relative: GOT
    linker: [ R_KVX_GLOB_DAT ]
    elfIds: [ 36 ]
    fields: [ WORD ]
  - ID: copy
    what: Copy relocation
    type: Rel_s_a
    linker: [ R_KVX_COPY ]
    elfIds: [ 37 ]
    fields: [ WORD ]
  - ID: jump_slot
    what: Pointer-sized jump slot relocation
    type: Rel_s_a
    linker: [ R_KVX_JMP_SLOT ]
    elfIds: [ 38 ]
    fields: [ WORD ]
  - ID: relative
    what: Pointer-sized relative relocation on base + addend
    relative: BASE
    type: Rel_s_a
    linker: [ R_KVX_RELATIVE ]
    elfIds: [ 39 ]
    fields: [ WORD ]
  - ID: signed43
    what: extended 43 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S43_EX6, R_KVX_S43_UP27, R_KVX_S43_LO10 ]
    elfIds: [ 42, 41, 40 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: signed64
    what: 64 bits relocation on symbol + addend
    type: Rel_s_a
    linker: [ R_KVX_S64_EX27, R_KVX_S64_UP27, R_KVX_S64_LO10 ]
    elfIds: [ 45, 44, 43 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: gotaddr_signed37
    what: extended 37 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S37_GOTADDR_UP27, R_KVX_S37_GOTADDR_LO10 ]
    elfIds: [ 47, 46 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: gotaddr_signed43
    what: extended 43 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S43_GOTADDR_EX6, R_KVX_S43_GOTADDR_UP27, R_KVX_S43_GOTADDR_LO10 ]
    elfIds: [ 50, 49, 48 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: gotaddr_signed64
    what: 64 bits PC relative address of GOT
    syntax: '@gotaddr'
    type: Rel_s_a
    relative: PC
    linker: [ R_KVX_S64_GOTADDR_EX27, R_KVX_S64_GOTADDR_UP27, R_KVX_S64_GOTADDR_LO10 ]
    elfIds: [ 53, 52, 51 ]
    fields: [ extend27, upper27, lower10 ]
    operands: [ extend27_upper27_lower10 ]
  - ID: dtpmod64
    what: 64 bits relocation for dynamic module identifier
    type: Rel_s_a
    linker: [ R_KVX_64_DTPMOD ]
    elfIds: [ 54 ]
    fields: [ DOUBLE ]
  - ID: dtpoff64
    what: 64 bits relocation for offset of symbol + addend relative to dynamic TLS block
    type: Rel_s_a
    linker: [ R_KVX_64_DTPOFF ]
    elfIds: [ 55 ]
    fields: [ DOUBLE ]
  - ID: dtpoff_signed37
    what: extended 37 bits relocation for offset on symbol + addend relative to dynamic TLS block
    syntax: '@dtpoff'
    type: Rel_s_a
    linker: [ R_KVX_S37_TLS_DTPOFF_UP27, R_KVX_S37_TLS_DTPOFF_LO10 ]
    elfIds: [ 57, 56 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: dtpoff_signed43
    what: extended 43 bits relocation for offset on symbol + addend relative to dynamic TLS block
    syntax: '@tlsgd'
    type: Rel_s_a
    linker: [ R_KVX_S43_TLS_DTPOFF_EX6, R_KVX_S43_TLS_DTPOFF_UP27, R_KVX_S43_TLS_DTPOFF_LO10 ]
    elfIds: [ 60, 59, 58 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsgd_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS GD descriptor
    syntax: '@tlsgd'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_GD_UP27, R_KVX_S37_TLS_GD_LO10 ]
    elfIds: [ 62, 61 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsgd_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS GD descriptor
    syntax: '@tlsgd'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_GD_EX6, R_KVX_S43_TLS_GD_UP27, R_KVX_S43_TLS_GD_LO10 ]
    elfIds: [ 65, 64, 63 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsld_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS LD descriptor
    syntax: '@tlsld'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_LD_UP27, R_KVX_S37_TLS_LD_LO10 ]
    elfIds: [ 67, 66 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsld_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS LD descriptor
    syntax: '@tlsld'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_LD_EX6, R_KVX_S43_TLS_LD_UP27, R_KVX_S43_TLS_LD_LO10 ]
    elfIds: [ 70, 69, 68 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tpoff64
    what: 64 bits relocation for offset of symbol + addend in static TLS block for TLS IE
    relative: TP
    type: Rel_s_a
    linker: [ R_KVX_64_TPOFF ]
    elfIds: [ 71 ]
    fields: [ DOUBLE ]
  - ID: tlsie_signed37
    what: extended 37 bits GOT relative relocation on symbol + addend for TLS IE descriptor
    syntax: '@tlsie'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S37_TLS_IE_UP27, R_KVX_S37_TLS_IE_LO10 ]
    elfIds: [ 73, 72 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsie_signed43
    what: extended 43 bits GOT relative relocation on symbol + addend for TLS IE descriptor
    syntax: '@tlsie'
    type: Rel_s_a
    relative: GOT
    linker: [ R_KVX_S43_TLS_IE_EX6, R_KVX_S43_TLS_IE_UP27, R_KVX_S43_TLS_IE_LO10 ]
    elfIds: [ 76, 75, 74 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
  - ID: tlsle_signed37
    what: extended 37 bits TP relative relocation on symbol + addend for TLS LE
    syntax: '@tlsle'
    type: Rel_s_a
    relative: TP
    linker: [ R_KVX_S37_TLS_LE_UP27, R_KVX_S37_TLS_LE_LO10 ]
    elfIds: [ 78, 77 ]
    fields: [ upper27, lower10 ]
    operands: [ upper27_lower10 ]
  - ID: tlsle_signed43
    what: extended 43 bits TP relative relocation on symbol + addend for TLS LE
    syntax: '@tlsle'
    type: Rel_s_a
    relative: TP
    linker: [ R_KVX_S43_TLS_LE_EX6, R_KVX_S43_TLS_LE_UP27, R_KVX_S43_TLS_LE_LO10 ]
    elfIds: [ 81, 80, 79 ]
    fields: [ extend6, upper27, lower10 ]
    operands: [ extend6_upper27_lower10 ]
## Adding basic relocation here to avoid to change all relocation elf ids
  - ID: rel8
    what: 8 bits relocation on symbol + addend
    overflow: Unsigned
    type: Rel_s_a
    linker: [ R_KVX_8 ]
    elfIds: [ 82 ]
    fields: [ BYTE ]
  - ID: pcrel11
    what: extended 11 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_PCREL11 ]
    elfIds: [ 83 ]
    fields: [ pcrel11 ]
    operands: [ pcrel11 ]
  - ID: pcrel38
    what: extended 38 bits PC relative relocation on symbol + addend
    overflow: Signed
    underflow: 1
    type: Rel_s_a
    relative: PC
    scaling: 2
    linker: [ R_KVX_S38_PCREL_UP27, R_KVX_S38_PCREL_LO11 ]
    elfIds: [ 85, 84 ]
    fields: [ upper27, lower11 ]
    operands: [ upper27_lower11 ]
Reservation:
  - ID: ALL
    what: Instruction must be alone in instruction bundle.
    requirements: [ 8 ]
    resources: [ ISSUE ]
  - ID: ALU_TINY
    what: Instruction must issue on one of the four TINY units.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY.X
    what: Instruction with one immediate extension, must issue on one of the four TINY units.
    requirements: [ 2, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY.Y
    what: Instruction with two immediate extensions, must issue on one of the four TINY units.
    requirements: [ 3, 1 ]
    resources: [ ISSUE, TINY ]
  - ID: ALU_TINY_CRRP
    what: Instruction must issue on one of the four TINY units and uses the coprocessor read ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR12 ]
  - ID: ALU_TINY_CRWL_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRWL_CRWH.X
    what: Instruction with one immediate extension, must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRWL_CRWH.Y
    what: Instruction with two immediate extensions, must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13, SR14 ]
  - ID: ALU_TINY_CRRP_CRWL_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR12, SR13, SR14 ]
  - ID: ALU_TINY_CRWL
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR13 ]
  - ID: ALU_TINY_CRWH
    what: Instruction must issue on one of the four TINY units and uses the coprocessor write ports.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, SR14 ]
  - ID: ALU_NOP
    what: Instruction is a no-operation.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, SR15 ]
  - ID: ALU_LITE
    what: Instruction must issue on one of the two LITE units.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE.X
    what: Instruction with one immediate extension, must issue on one of the two LITE units.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE.Y
    what: Instruction with two immediate extensions, must issue on one of the two LITE units.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, LITE, TINY ]
  - ID: ALU_LITE_CRWL
    what: Instruction must issue on one of the two LITE units and writes to low part of coprocessor register.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY, SR13 ]
  - ID: ALU_LITE_CRWH
    what: Instruction must issue on one of the two LITE units and writes to high part of coprocessor register.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, LITE, TINY, SR14 ]
  - ID: ALU_FULL
    what: Instruction must issue on the ALU0.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: ALU_FULL.X
    what: Instruction with one immediate extension, must issue on the ALU0.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: ALU_FULL.Y
    what: Instruction with two immediate extensions, must issue on the ALU0.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LITE, FULL ]
  - ID: BCU
    what: Instruction must issue on the BCU.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, BCU ]
  - ID: BCU_XFER
    what: Instruction must issue on the BCU and unconditionally transfers control.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, BCU, XFER ]
  - ID: BCU_CRRP_CRWL_CRWH
    what: Instruction must issue on the BCU and uses the coprocessor read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, BCU, SR12, SR13, SR14 ]
  - ID: BCU_TINY_AUXW_CRRP
    what: Instruction must issue on the BCU, uses the auxiliary write port and uses the coprocessor read ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, BCU, TINY, AUXW, SR12 ]
  - ID: BCU_TINY_TINY_MAU_XNOP
    what: Instruction must issue on the BCU and uses the MAU write port, exclude NOPs.
    requirements: [ 1, 1, 2, 1, 4 ]
    resources: [ ISSUE, BCU, TINY, MAU, SR15 ]
  - ID: EXT
    what: Instruction must issue on the EXT.
    requirements: [ 1, 1 ]
    resources: [ ISSUE, EXT ]
  - ID: LSU
    what: Instruction must issue on the LSU.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU.X
    what: Instruction with one immediate extension, must issue on the LSU.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU.Y
    what: Instruction with two immediate extensions, must issue on the LSU.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, TINY, LSU ]
  - ID: LSU_CRRP
    what: Instruction must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_CRRP.X
    what: Instruction with one immediate extension, must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_CRRP.Y
    what: Instruction with two immediate extensions, must issue on the LSU and reads a coprocessor register pair.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, SR12 ]
  - ID: LSU_AUXR
    what: Instruction must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXR.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXR.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary read port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR ]
  - ID: LSU_AUXW
    what: Instruction must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXW.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXW.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary write port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXW ]
  - ID: LSU_AUXR_AUXW
    what: Instruction must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 1, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: LSU_AUXR_AUXW.X
    what: Instruction with one immediate extension, must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 2, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: LSU_AUXR_AUXW.Y
    what: Instruction with two immediate extensions, must issue on the LSU, and requires the auxiliary read and write ports.
    requirements: [ 3, 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, LSU, AUXR, AUXW ]
  - ID: MAU
    what: Instruction must issue on the MAU.
    requirements: [ 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU.X
    what: Instruction with one immediate extension, must issue on the MAU.
    requirements: [ 2, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU.Y
    what: Instruction with two immediate extensions, must issue on the MAU.
    requirements: [ 3, 1, 1 ]
    resources: [ ISSUE, TINY, MAU ]
  - ID: MAU_AUXR
    what: Instruction must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 1, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
  - ID: MAU_AUXR.X
    what: Instruction with one immediate extension, must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 2, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
  - ID: MAU_AUXR.Y
    what: Instruction with two immediate extensions, must issue on the MAU, and requires the auxiliary read port.
    requirements: [ 3, 1, 1, 1 ]
    resources: [ ISSUE, TINY, MAU, AUXR ]
Resource:
  - ID: ISSUE
    what: Issue slots counted in 32-bit syllables.
    availability: 8
  - ID: TINY
    what: Tiny ALU function units.
    availability: 4
  - ID: LITE
    what: Lite ALU function units.
    availability: 2
  - ID: FULL
    what: Full ALU function units.
    availability: 1
  - ID: LSU
    what: Load/Store function unit.
    availability: 1
  - ID: MAU
    what: Multiply and FP function unit (MAU).
    availability: 1
  - ID: BCU
    what: Branch and control unit.
    availability: 1
  - ID: EXT
    what: Extension coprocessor units.
    availability: 1
  - ID: AUXR
    what: Auxiliary core register read port shared with LSU (256 bits).
    availability: 1
  - ID: AUXW
    what: Auxiliary core register write port shared with LSU (256 bits).
    availability: 1
  - ID: XFER
    what: Unconditional control-flow transfer (XFER).
    availability: 1
  - ID: MEMW
    what: Memory write or memory read-modify-write resource (MEMW).
    availability: 1
  - ID: SR12
    what: Coprocessor 256-bit register read pair port (CRRP).
    availability: 1
  - ID: SR13
    what: Coprocessor 128-bit register write low half port (CRWL).
    availability: 1
  - ID: SR14
    what: Coprocessor 128-bit register write high half port (CRWH).
    availability: 1
  - ID: SR15
    what: No-operation (NOP).
    availability: 4
Scheduling:
  - ID: ALL
    bundling: ALL
    reservation: ALL
  - ID: BCU
    bundling: BCU
    reservation: BCU
  - ID: BCU_XFER
    bundling: BCU
    reservation: BCU_XFER
  - ID: BCU_TINY_TINY_MAU_XNOP
    bundling: BCU
    reservation: BCU_TINY_TINY_MAU_XNOP
  - ID: BCU_CRRP_CRWL_CRWH
    bundling: BCU
    reservation: BCU_CRRP_CRWL_CRWH
  - ID: BCU_TINY_AUXW_CRRP
    bundling: BCU
    reservation: BCU_TINY_AUXW_CRRP
  - ID: ALU_NOP
    bundling: NOP
    reservation: ALU_NOP
  - ID: EXT
    bundling: EXT
    reservation: EXT
  - ID: ALU_TINY
    bundling: TINY
    reservation: ALU_TINY
  - ID: ALU_TINY.X
    bundling: TINY.X
    reservation: ALU_TINY.X
  - ID: ALU_TINY.Y
    bundling: TINY.Y
    reservation: ALU_TINY.Y
  - ID: ALU_TINY_CRRP
    bundling: TINY
    reservation: ALU_TINY_CRRP
  - ID: ALU_TINY_CRWL_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRWL_CRWH
  - ID: ALU_TINY_CRWL_CRWH.X
    bundling: TINY.X
    reservation: ALU_TINY_CRWL_CRWH.X
  - ID: ALU_TINY_CRWL_CRWH.Y
    bundling: TINY.Y
    reservation: ALU_TINY_CRWL_CRWH.Y
  - ID: ALU_TINY_CRRP_CRWL_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRRP_CRWL_CRWH
  - ID: ALU_TINY_CRWL
    bundling: TINY
    reservation: ALU_TINY_CRWL
  - ID: ALU_TINY_CRWH
    bundling: TINY
    reservation: ALU_TINY_CRWH
  - ID: ALU_LITE
    bundling: LITE
    reservation: ALU_LITE
  - ID: ALU_LITE.X
    bundling: LITE.X
    reservation: ALU_LITE.X
  - ID: ALU_LITE.Y
    bundling: LITE.Y
    reservation: ALU_LITE.Y
  - ID: ALU_LITE_CRWL
    bundling: LITE
    reservation: ALU_LITE_CRWL
  - ID: ALU_LITE_CRWH
    bundling: LITE
    reservation: ALU_LITE_CRWH
  - ID: ALU_FULL
    bundling: FULL
    reservation: ALU_FULL
  - ID: ALU_FULL.X
    bundling: FULL.X
    reservation: ALU_FULL.X
  - ID: ALU_FULL.Y
    bundling: FULL.Y
    reservation: ALU_FULL.Y
  - ID: MAU
    bundling: MAU
    reservation: MAU
  - ID: MAU.X
    bundling: MAU.X
    reservation: MAU.X
  - ID: MAU.Y
    bundling: MAU.Y
    reservation: MAU.Y
  - ID: MAU_AUXR
    bundling: MAU
    reservation: MAU_AUXR
  - ID: MAU_AUXR.X
    bundling: MAU.X
    reservation: MAU_AUXR.X
  - ID: MAU_AUXR.Y
    bundling: MAU.Y
    reservation: MAU_AUXR.Y
  - ID: LSU
    bundling: LSU
    reservation: LSU
  - ID: LSU.X
    bundling: LSU.X
    reservation: LSU.X
  - ID: LSU.Y
    bundling: LSU.Y
    reservation: LSU.Y
  - ID: LSU_CRRP
    bundling: LSU
    reservation: LSU_CRRP
  - ID: LSU_CRRP.X
    bundling: LSU.X
    reservation: LSU_CRRP.X
  - ID: LSU_CRRP.Y
    bundling: LSU.Y
    reservation: LSU_CRRP.Y
  - ID: LSU_AUXR
    bundling: LSU
    reservation: LSU_AUXR
  - ID: LSU_AUXR.X
    bundling: LSU.X
    reservation: LSU_AUXR.X
  - ID: LSU_AUXR.Y
    bundling: LSU.Y
    reservation: LSU_AUXR.Y
  - ID: LSU_AUXW
    bundling: LSU
    reservation: LSU_AUXW
  - ID: LSU_AUXW.X
    bundling: LSU.X
    reservation: LSU_AUXW.X
  - ID: LSU_AUXW.Y
    bundling: LSU.Y
    reservation: LSU_AUXW.Y
  - ID: LSU_AUXR_AUXW
    bundling: LSU
    reservation: LSU_AUXR_AUXW
  - ID: LSU_AUXR_AUXW.X
    bundling: LSU.X
    reservation: LSU_AUXR_AUXW.X
  - ID: LSU_AUXR_AUXW.Y
    bundling: LSU.Y
    reservation: LSU_AUXR_AUXW.Y
Simulated:
  - ID: ADJUST
    what: Adjust Stack Pointer
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2, %3"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: singleReg
        usage: Left
        proxy: "%2"
        stages: 1
      - action: "Read"
        method:
          Immediate: signed10
        usage: Right
        proxy: "%3"
        stages: 0
  - ID: GETPC
    what: Get Program Counter
    scheduling: BCU
    syntax: "%0 %1"
    parameters:
      - action: Write
        method:
          Register: PC
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          Immediate: pcrel27
        proxy: "%2"
        stages: 0
  - ID: SET_GOTP
    what: Get System Register in PIC Mode
    scheduling: ALL
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
      - action: Read
        method:
          RegClass: systemReg
        proxy: "%2"
        stages: 1
      - action: Read
        method:
          Immediate: wrapped32
        proxy: "%4"
        stages: 1
  - ID: GNUASM
    what: GNU ASM Statement.
    scheduling: ALL
    syntax: "%0"
    parameters:
      - action: WriteList
        method:
          RegClass: ""
        stages: 2
      - action: ReadList
        method:
          RegClass: ""
        stages: 1
  - ID: GNUASM_CFG
    what: GNU ASM Statement.
    scheduling: ALL
    syntax: "%0"
    properties: "Conditional Control"
    parameters:
      - action: WriteList
        method:
          RegClass: ""
        stages: 2
      - action: Read
        method:
          Immediate: pcrel27
        usage: Target
        stages: 1
      - action: ReadList
        method:
          RegClass: ""
        stages: 1
  - ID: MOVP
    what: Move of paired registers
    scheduling: ALU_LITE
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: pairedReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%2"
        stages: 1
  - ID: COMPOSEP
    what: Pair register composition
    scheduling: ALU_FULL
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: pairedReg
        proxy: "%1"
        stages: 2
      - action: Read
        method:
          RegClass: singleReg
        usage: Left
        proxy: "%2"
        stages: 1
      - action: "Read"
        method:
          RegClass: singleReg
        usage: Right
        proxy: "%3"
        stages: 1
  - ID: EXTRACTP
    what: Pair register extraction
    scheduling: ALU_LITE
    syntax: "unspecified"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 2
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 1
  - ID: MOVC
    what: Predicated move on true predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
  - ID: MOVPC
    what: Predicated paired move on true predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: pairedReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 2
  - ID: MOVCF
    what: Predicated move on false predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%3"
        stages: 2
  - ID: MOVPCF
    what: Predicated paired move on false predicate
    scheduling: ALU_LITE
    syntax: "%0 %1 = %2 %3"
    parameters:
      - action: Write
        method:
         RegClass: pairedReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
        usage: Pred
      - action: Read
        method:
          RegClass: pairedReg
        proxy: "%3"
        stages: 2
  - ID: SYSCALL
    what: Simulated System Call with result operand
    scheduling: ALL
    syntax: "%0 %1 = %2"
    parameters:
      - action: Write
        method:
          RegClass: singleReg
        proxy: "%1"
        stages: 3
      - action: Read
        method:
          RegClass: singleReg
        proxy: "%2"
        stages: 2
Storage:
  - ID: AESPC
    what: Arithmetic Exception Saved PC
    kind: Special
    width: 64
    count: 1
  - ID: PM0
    what: Performance Monitor 0
    kind: Special
    width: 64
    count: 1
  - ID: PM1
    what: Performance Monitor 1
    kind: Special
    width: 64
    count: 1
  - ID: PM2
    what: Performance Monitor 2
    kind: Special
    width: 64
    count: 1
  - ID: PM3
    what: Performance Monitor 3
    kind: Special
    width: 64
    count: 1
  - ID: PM4
    what: Performance Monitor 4
    kind: Special
    width: 64
    count: 1
  - ID: PM5
    what: Performance Monitor 5
    kind: Special
    width: 64
    count: 1
  - ID: PM6
    what: Performance Monitor 6
    kind: Special
    width: 64
    count: 1
  - ID: PM7
    what: Performance Monitor 7
    kind: Special
    width: 64
    count: 1
  - ID: PMSA
    what: Performance Monitor Saved Address
    kind: Special
    width: 64
    count: 1
  - ID: T0V
    what: Timer 0 value
    kind: Special
    width: 64
    count: 1
  - ID: T1V
    what: Timer 1 value
    kind: Special
    width: 64
    count: 1
  - ID: T0R
    what: Timer 0 reload value
    kind: Special
    width: 64
    count: 1
  - ID: T1R
    what: Timer 1 reload value
    kind: Special
    width: 64
    count: 1
  - ID: WDV
    what: Watchdog Value
    kind: Special
    width: 64
    count: 1
  - ID: WDR
    what: Watchdog Reload Value
    kind: Special
    width: 64
    count: 1
  - ID: MEN
    what: Miscellaneous External Notifications
    kind: Special
    width: 1
    count: 16
  - ID: PC
    what: Program Counter
    kind: Control
    width: 64
    count: 1
  - ID: PS
    what: Processing Status
    kind: Special
    width: 1
    count: 64
  - ID: SPS
    what: Shadow Processing Status
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL0
    what: Shadow Processing Status for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL1
    what: Shadow Processing Status for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL2
    what: Shadow Processing Status for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: SPS_PL3
    what: Shadow Processing Status for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: CS
    what: Compute Status
    kind: Special
    width: 1
    count: 64
  - ID: DBA0
    what: Debug Breakpoint Address 0
    kind: Special
    width: 64
    count: 1
  - ID: DBA1
    what: Debug Breakpoint Address 1
    kind: Special
    width: 64
    count: 1
  - ID: DBA2
    what: Debug Breakpoint Address 2
    kind: Special
    width: 64
    count: 1
  - ID: DBA3
    what: Debug Breakpoint Address 3
    kind: Special
    width: 64
    count: 1
  - ID: DWA0
    what: Debug Watchpoint address 0
    kind: Special
    width: 64
    count: 1
  - ID: DWA1
    what: Debug Watchpoint address 1
    kind: Special
    width: 64
    count: 1
  - ID: DWA2
    what: Debug Watchpoint address 2
    kind: Special
    width: 64
    count: 1
  - ID: DWA3
    what: Debug Watchpoint address 3
    kind: Special
    width: 64
    count: 1
  - ID: CSIT
    what: Compute Status arithmetic Interrupt
    kind: Special
    width: 1
    count: 32
  - ID: ES
    what: Exception Syndrome
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL0
    what: Exception Syndrome for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL1
    what: Exception Syndrome for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL2
    what: Exception Syndrome for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: ES_PL3
    what: Exception Syndrome for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: SID
    what: Coolidge V2, Stream ID
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL0
    what: Coolidge V2, Stream ID for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL1
    what: Coolidge V2, Stream ID for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL2
    what: Coolidge V2, Stream ID for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: SID_PL3
    what: Coolidge V2, Stream ID for Privilege Level 3
    kind: Special
    width: 1
    count: 64
  - ID: IXC
    what: Coolidge V2, Inter-Extension Communications
    kind: Special
    width: 1
    count: 64
  - ID: TEL
    what: TLB Entry Low
    kind: Special
    width: 1
    count: 64
  - ID: TEH
    what: TLB Entry High
    kind: Special
    width: 1
    count: 64
  - ID: TPCM0
    what: Trace PC Message 0
    kind: Special
    width: 64
    count: 1
  - ID: TPCM1
    what: Trace PC Message 1
    kind: Special
    width: 64
    count: 1
  - ID: TPCM2
    what: Trace PC Message 2
    kind: Special
    width: 1
    count: 64
  - ID: TPCMC
    what: Trace PC Message Control
    kind: Special
    width: 1
    count: 64
  - ID: DC
    what: Debug Control
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_0
    what: Debug Control watchpoint/breakpoint 0
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_1
    what: Debug Control watchpoint/breakpoint 1
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_2
    what: Debug Control watchpoint/breakpoint 2
    kind: Special
    width: 1
    count: 64
  - ID: DCV2_3
    what: Debug Control watchpoint/breakpoint 3
    kind: Special
    width: 1
    count: 64
  - ID: SRS
    what: System Register Storage
    kind: Special
    width: 64
    count: 512
  - ID: GRS
    what: General Register Storage
    kind: Register
    width: 64
    count: 64
  - ID: XRS
    what: Extension Register Storage
    kind: Register
    width: 64
    count: 256
  - ID: MEM
    what: Data Memory
    kind: Memory
    width: 8
  - ID: NPC
    what: Program Counter of Next Bundle
    kind: Control
    width: 64
    count: 1
  - ID: TCR
    what: Timer Control Register
    kind: Special
    width: 1
    count: 64
  - ID: PMC
    what: Performance Monitor Control Register
    kind: Special
    width: 1
    count: 64
  - ID: PMC_2
    what: Performance Monitor Control Register 2
    kind: Special
    width: 1
    count: 64
  - ID: SRHPC
    what: Last sequence rupture helper PC when uninferrable
    kind: Special
    width: 64
    count: 1
  - ID: FRCC
    what: Free running cycle counter
    kind: Special
    width: 64
    count: 1
  - ID: PCR
    what: Processing Identification Register
    kind: Special
    width: 1
    count: 64
  - ID: SYO
    what: SYscalls Owners
    kind: Special
    width: 1
    count: 32
  - ID: HTO
    what: Hardware Trap Owners
    kind: Special
    width: 1
    count: 32
  - ID: ITO
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 64
  - ID: ILE
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 32
  - ID: ILL
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 64
  - ID: ILR
    what: Interrupt Owners
    kind: Special
    width: 1
    count: 32
  - ID: IPE
    what: Inter Process Event
    kind: Special
    width: 1
    count: 64
  - ID: DO
    what: Debug Owners
    kind: Special
    width: 1
    count: 32
  - ID: MO
    what: Miscellaneous Owners
    kind: Special
    width: 1
    count: 64
  - ID: PSO
    what: Processor Status register Owners
    kind: Special
    width: 1
    count: 64
  - ID: MMC
    what: Memory Management Control
    kind: Special
    width: 1
    count: 64
  - ID: MES
    what: Memory Error Status
    kind: Special
    width: 1
    count: 64
  - ID: WS
    what: Wake-up Status
    kind: Special
    width: 1
    count: 64
  - ID: TPCC
    what: Coolidge V2, Trace PC Context
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL0
    what: Coolidge V2, Trace PC Context for Privilege Level 0
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL1
    what: Coolidge V2, Trace PC Context for Privilege Level 1
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL2
    what: Coolidge V2, Trace PC Context for Privilege Level 2
    kind: Special
    width: 1
    count: 64
  - ID: TPCC_PL3
    what: Coolidge V2, Trace PC Context for Privilege Level 3
    kind: Special
    width: 1
    count: 64
Synthetic:
  - ID: COPYD
    what: Copy Double Word
    formats: [ ALU_DWRI ]
    instruction: IORD
    specialize: { "%3": 0 }
    syntax: "%0 %1 = %2"
  - ID: NOTD
    what: Complement Double Word
    formats: [ ALU_DWRI ]
    instruction: EORD
    specialize: { "%3": "-1" }
    properties: { '%0': Bitwise }
    syntax: "%0 %1 = %2"
  - ID: NEGD
    what: Negate Double Word
    formats: [ ALU_DWRI ]
    instruction: SBFD
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: SBMM8
    what: Swapped Bit Matrix Multiplication 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    instruction: SBMM8D
  - ID: SBMMT8
    what: Swapped Bit Matrix Multiplication Transposed 8$\times$8
    formats: [ ALU_BWRR, ALU_BWRR.M, ALU_DBMWRI, ALU_DBMWRI.X, ALU_DBMWRI.Y ]
    instruction: SBMMT8D
  - ID: ORD
    what: Legacy form of IORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: IORD
  - ID: NORD
    what: Legacy form of NIORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: NIORD
  - ID: ORND
    what: Legacy form of IORND
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: IORND
  - ID: XORD
    what: Alias of EORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: EORD
  - ID: NXORD
    what: Alias of NEORD
    formats: [ ALU_DWRR, ALU_DWRR.M, ALU_DWRI, ALU_DWRI.X, ALU_DWRI.Y ]
    instruction: NEORD
  - ID: ORW
    what: Legacy form of IORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: IORW
  - ID: NORW
    what: Legacy form of NIORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: NIORW
  - ID: ORNW
    what: Legacy form of IORNW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: IORNW
  - ID: XORW
    what: Alias of EORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: EORW
  - ID: NXORW
    what: Alias of NEORW
    formats: [ ALU_WRIW, ALU_WRIW.X, ALU_WWRR0 ]
    instruction: NEORW
  - ID: ABSD
    what: Absolute Value of Double Word
    formats: [ ALU_DWRI ]
    instruction: ABDD
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: ZXBD
    what: Zero Extend Byte to Double Word
    formats: [ ALU_WRIW ]
    instruction: ANDW
    specialize: { "%3": "0xFF" }
    syntax: "%0 %1 = %2"
  - ID: SXBD
    what: Sign Extend Byte to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b000111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: ZXHD
    what: Zero Extend Half Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFZ
    specialize: { "%3": "0b001111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: SXHD
    what: Sign Extend Half Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b001111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: ZXWD
    what: Zero Extend Word to Double Word
    formats: [ ALU_WRIW ]
    instruction: ANDW
    specialize: { "%3": "-1" }
    syntax: "%0 %1 = %2"
  - ID: SXWD
    what: Sign Extend Word to Double Word
    formats: [ ALU_WRB ]
    instruction: EXTFS
    specialize: { "%3": "0b011111", "%4": "0b000000" }
    syntax: "%0 %1 = %2"
  - ID: SATDH
    what: Saturate Double Word to Half Word
    formats: [ ALU_DSWRI ]
    instruction: SATD
    specialize: { "%3": "16" }
    syntax: "%0 %1 = %2"
  - ID: SATDW
    what: Saturate Double Word to Word
    formats: [ ALU_DSWRI ]
    instruction: SATD
    specialize: { "%3": "32" }
    syntax: "%0 %1 = %2"
  - ID: COPYW
    what: Copy Word
    formats: [ ALU_WRIW ]
    instruction: IORW
    specialize: { "%3": 0 }
    syntax: "%0 %1 = %2"
  - ID: NOTW
    what: Complement Word
    formats: [ ALU_WRIW ]
    instruction: EORW
    specialize: { "%3": "-1" }
    properties: { '%0': Bitwise }
    syntax: "%0 %1 = %2"
  - ID: NEGW
    what: Negate Word
    formats: [ ALU_WRIW ]
    instruction: SBFW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSW
    what: Absolute Value of Word
    formats: [ ALU_WRIW ]
    instruction: ABDW
    specialize: { "%3": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGWP
    what: Negate Word Pair
    formats: [ ALU_WPWRR0.M ]
    instruction: SBFWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: FSBFWC
    what: Floating-Point Subtract From Word Complex
    class: FPU
    formats: [ MAU_FDDD1 ]
    instruction: FSBFWP
  - ID: FSBFWCP
    what: Floating-Point Subtract From Word Complex Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    instruction: FSBFWQ
  - ID: FSBFDC
    what: Floating-Point Subtract Double Word Complex
    class: FPU
    formats: [ MAU_FQQQ0 ]
    instruction: FSBFDP
  - ID: FADDWC
    what: Floating-Point Add From Word Complex
    class: FPU
    formats: [ MAU_FDDD1 ]
    instruction: FADDWP
  - ID: FADDWCP
    what: Floating-Point Add Word Complex Pair
    class: FPU
    formats: [ MAU_FQQQ1 ]
    instruction: FADDWQ
  - ID: FADDDC
    what: Floating-Point Add From Double Word Complex
    class: FPU
    formats: [ MAU_FQQQ0 ]
    instruction: FADDDP
  - ID: ABSWP
    what: Absolute Value of Word Pair
    formats: [ ALU_WPWRR0.M ]
    instruction: ABDWP
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: NEGHQ
    what: Negate Word Half Word Quadruple
    formats: [ ALU_HQWRR0.M ]
    instruction: SBFHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: ABSHQ
    what: Absolute Value of Half Word Quadruple
    formats: [ ALU_HQWRR0.M ]
    instruction: ABDHQ
    specialize: { "%3": "0", "%4": "0" }
    syntax: "%0 %1 = %2"
  - ID: XCOPYO
    what: Copy Extension Octuple Word
    formats: [ BCU_AVEOI, BCU_AVOEI ]
    instruction: ALIGNV
    specialize: { "%3": "-1", "%4": 0 }
    syntax: "%0 %1 = %2"
  - ID: XMOVEFO
    what: Move From Coprocessor Octuple Word
    formats: [ BCU_AOEOI, BCU_AOOEI ]
    instruction: ALIGNO
    specialize: { "%3": "-1", "%4": 0 }
    syntax: "%0 %1 = %2"
  - ID: XMOVETQ
    what: Move To Coprocessor Quadruple Word (Coolidge V2)
    formats: [ ALU_MTWQE, ALU_MTWQO ]
    instruction: MOVETQ
  - ID: LORD
    what: Alias of LIORD
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    instruction: LIORD
  - ID: LNORD
    what: Alias of LNIORD
    formats: [ ALU_DWRR, ALU_DWRR.M ]
    instruction: LNIORD
  - ID: LORW
    what: Alias of LIORW
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    instruction: LIORW
  - ID: LNORW
    what: Alias of LNIORW
    formats: [ ALU_WWRR1, ALU_WWRR1.W ]
    instruction: LNIORW
  - ID: LORWP
    what: Alias of LIORWP
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    instruction: LIORWP
  - ID: LNORWP
    what: Alias of LNIORWP
    formats: [ ALU_WPWRR1, ALU_WPWRR1.M ]
    instruction: LNIORWP
  - ID: LORHQ
    what: Alias of LIORHQ
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    instruction: LIORHQ
  - ID: LNORHQ
    what: Alias of LNIORHQ
    formats: [ ALU_HQWRR1, ALU_HQWRR1.M ]
    instruction: LNIORHQ
